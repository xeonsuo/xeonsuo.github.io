<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>spring 文档手册 | Calico's Space</title><meta name="author" content="Calico"><meta name="copyright" content="Calico"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="spring 框架介绍   核心容器 核心容器由以下模块组成，spring-core， spring-beans，spring-context，spring-context-support，和spring-expression （Spring表达式语言）。 spring-core和spring-beans模块提供了框架的基础功能，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模">
<meta property="og:type" content="article">
<meta property="og:title" content="spring 文档手册">
<meta property="og:url" content="http://xeons.cn/2023/03/03/spring-guide/index.html">
<meta property="og:site_name" content="Calico&#39;s Space">
<meta property="og:description" content="spring 框架介绍   核心容器 核心容器由以下模块组成，spring-core， spring-beans，spring-context，spring-context-support，和spring-expression （Spring表达式语言）。 spring-core和spring-beans模块提供了框架的基础功能，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xeons.cn/2023/03/03/spring-guide/spring.jpg">
<meta property="article:published_time" content="2023-03-02T16:00:00.000Z">
<meta property="article:author" content="Calico">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xeons.cn/2023/03/03/spring-guide/spring.jpg"><link rel="shortcut icon" href="/images/calico-ss.png"><link rel="canonical" href="http://xeons.cn/2023/03/03/spring-guide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f97e3791752fae830e3db5ba194c6cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'spring 文档手册',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-12 00:05:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Calico's Space" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/loading_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Calico's Space"><span class="site-name">Calico's Space</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">spring 文档手册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-02T16:00:00.000Z" title="发表于 2023-03-03 00:00:00">2023-03-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/spring/">spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="spring 文档手册"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="spring-框架介绍"><a href="#spring-框架介绍" class="headerlink" title="spring 框架介绍"></a>spring 框架介绍</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./spring-guide/bec342f79c5cf84f90ff5eb800258e9a_1656048338919.png"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/03/03/spring-guide/bec342f79c5cf84f90ff5eb800258e9a_1656048338919.png" class="">

<p><strong>核心容器</strong></p>
<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-introduction"><em>核心容器</em></a>由以下模块组成，spring-core， spring-beans，spring-context，spring-context-support，和spring-expression （Spring表达式语言）。</p>
<p>spring-core和spring-beans模块<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-introduction">提供了框架的基础功能</a>，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模式的实现。你不再需要编程去实现单例模式，允许你把依赖关系的配置和描述从程序逻辑中解耦。</p>
<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#context-introduction"><em>上下文</em></a>（spring-context）模块建立在由<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-introduction"><em>Core和Beans</em></a>模块提供的坚实的基础上：它提供一个框架式的对象访问方式，类似于一个JNDI注册表。上下文模块从Beans模块继承其功能，并添加支持国际化（使用，例如，资源集合），事件传播，资源负载，并且透明创建上下文，例如，Servlet容器。Context模块还支持Java EE的功能，如EJB，JMX和基本的远程处理。ApplicationContext接口是Context模块的焦点。 spring-context-support支持整合普通第三方库到Spring应用程序上下文，特别是用于高速缓存（ehcache，JCache）和调度（CommonJ，Quartz）的支持。</p>
<p>spring-expression模块提供了强大的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/expressions.html"><em>表达式语言</em></a>去支持查询和操作运行时对象图。这是对JSP 2.1规范中规定的统一表达式语言（unified EL）的扩展。该语言支持设置和获取属性值，属性分配，方法调用，访问数组，集合和索引器的内容，逻辑和算术运算，变量命名以及从Spring的IoC容器中以名称检索对象。 它还支持列表投影和选择以及常见的列表聚合。</p>
<p><strong>AOP和Instrumentation</strong></p>
<p>spring-aop模块提供了一个符合<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/aop.html#aop-introduction"><em>AOP</em></a>联盟（要求）的面向方面的编程实现，例如，允许您定义方法拦截器和切入点（pointcuts），以便干净地解耦应该被分离的功能实现。 使用源级元数据(source-level metadata)功能，您还可以以类似于.NET属性的方式将行为信息合并到代码中。</p>
<p>单独的spring-aspects模块，提供了与AspectJ的集成。</p>
<p>spring-instrument模块提供了类植入(instrumentation)支持和类加载器的实现,可以应用在特定的应用服务器中。该spring-instrument-tomcat 模块包含了支持Tomcat的植入代理。</p>
<p><strong>消息</strong></p>
<p>Spring框架4包括spring-messaging(消息传递模块)，其中包含来自Spring Integration的项目，例如，Message，MessageChannel，MessageHandler，和其他用来传输消息的基础应用。该模块还包括一组用于将消息映射到方法的注释(annotations)，类似于基于Spring MVC注释的编程模型。</p>
<p><strong>数据访问&#x2F;集成</strong></p>
<p>数据访问&#x2F;集成层由JDBC，ORM，OXM，JMS和事务模块组成。</p>
<p>spring-jdbc模块提供了一个<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/jdbc.html#jdbc-introduction">JDBC</a> –抽象层，消除了需要的繁琐的JDBC编码和数据库厂商特有的错误代码解析。</p>
<p>spring-tx模块支持用于实现特殊接口和所有POJO（普通Java对象）的类的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/transaction.html">编程和声明式事务</a> 管理。</p>
<p>spring-orm模块为流行的对象关系映射(<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/orm.html#orm-introduction">object-relational mapping</a> )API提供集成层，包括JPA和Hibernate。使用spring-orm模块，您可以将这些O &#x2F; R映射框架与Spring提供的所有其他功能结合使用，例如前面提到的简单声明性事务管理功能。</p>
<p>spring-oxm模块提供了一个支持<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/oxm.html">对象&#x2F; XML映射</a>实现的抽象层，如JAXB，Castor，JiBX和XStream。</p>
<p>spring-jms模块(<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/jms.html">Java Messaging Service</a>) 包含用于生产和消费消息的功能。自Spring Framework 4.1以来，它提供了与 spring-messaging模块的集成。</p>
<p><strong>Web</strong></p>
<p>Web层由spring-web，spring-webmvc和spring-websocket 模块组成。</p>
<p>spring-web模块提供基本的面向Web的集成功能，例如多部分文件上传功能，以及初始化一个使用了Servlet侦听器和面向Web的应用程序上下文的IoC容器。它还包含一个HTTP客户端和Spring的远程支持的Web相关部分。</p>
<p>spring-webmvc模块（也称为Web-Servlet模块）包含用于Web应用程序的Spring的模型-视图-控制器(<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/mvc.html#mvc-introduction"><em>MVC</em></a>)和REST Web Services实现。 Spring的MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。</p>
<p><strong>测试</strong></p>
<p>spring-test模块支持使用JUnit或TestNG对Spring组件进行<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/unit-testing.html">单元测试</a>和 <a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/integration-testing.html">集成测试</a>。它提供了Spring ApplicationContexts的一致<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/integration-testing.html#testcontext-ctx-management">加载</a>和这些上下文的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/integration-testing.html#testcontext-ctx-management-caching">缓存</a>。它还提供可用于独立测试代码的<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/unit-testing.html#mock-objects">模仿(mock)对象</a>。</p>
<h2 id="Spring-IoC和beans的介绍"><a href="#Spring-IoC和beans的介绍" class="headerlink" title="Spring IoC和beans的介绍"></a>Spring IoC和beans的介绍</h2><p>IoC又叫依赖注入（DI）。它描述了对象的定义和依赖的一个过程，也就是说，依赖的对象通过构造参数、工厂方法参数或者属性注入，当对象实例化后依赖的对象才被创建，当创建bean后容器注入这些依赖对象。这个过程基本上是反向的，因此命名为控制反转（IoC），它通过直接使用构造类来控制实例化，或者定义它们之间的依赖关系，或者类似于服务定位模式的一种机制。</p>
<p>org.springframework.beans和org.springframework.context是Spring框架中IoC容器的基础，<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</a>接口提供一种高级的配置机制能够管理任何类型的对象。<a target="_blank" rel="noopener" href="http://ifeve.com/spring-ioc-1-2/href=%22http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/ApplicationContext.html">ApplicationContext</a>是BeanFactory的子接口。它能更容易集成Spring的AOP功能、消息资源处理（比如在国际化中使用）、事件发布和特定的上下文应用层比如在网站应用中的WebApplicationContext。</p>
<h3 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a><strong>容器介绍</strong></h3><p>org.springframework.context.ApplicationContext接口代表了Spring Ioc容器，它负责实例化、配置、组装之前的beans。容器通过读取配置元数据获取对象的实例化、配置和组装的描述信息。它配置的0元数据用xml、Java注解或Java代码表示。它允许你表示组成你应用的对象以及这些对象之间丰富的内部依赖关系。</p>
<p>Spring提供几个开箱即用的ApplicationContext接口的实现类。在独立应用程序中通常创建一个<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html">ClassPathXmlApplicationContext</a>或<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-framework/docs/5.0.0.M5/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html">FileSystemXmlApplicationContext</a>实例对象。虽然XML是用于定义配置元数据的传统格式，你也可以指示容器使用Java注解或代码作为元数据格式，但要通过提供少量XML配置来声明启用对这些附加元数据格式的支持。</p>
<p>在大多数应用场景中，显示用户代码不需要实例化一个或多个Spring IoC容器的实例。比如在web应用场景中，在web.xml中简单的8行（或多点）样板式的xml配置文件就可以搞定（参见第3.15.4节“Web应用程序的便利的ApplicationContext实例化”）。如果你正在使用Eclipse开发环境中的<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring Tool Suite</a>插件，你只需要鼠标点点或者键盘敲敲就能轻松搞定这几行配置。</p>
<h3 id="配置bean的元数据"><a href="#配置bean的元数据" class="headerlink" title="配置bean的元数据"></a><strong>配置bean的元数据</strong></h3><p>配置元数据传统上以简单直观的XML格式提供</p>
<blockquote>
<p>基于XML的元数据不是允许配置元数据的唯一形式，Spring IoC容器与实际写入配置元数据的格式是分离的。这些天许多的开发者在他们的Spring应用中选择基于<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-java">Java配置</a>。</p>
</blockquote>
<p>更多关于Spring容器使用其他形式的元数据信息，请查看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-annotation-config">基于注解配置：</a> 在Spring2.5中有过介绍支持基于注解的配置元数据</li>
<li><a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/html/beans.html#beans-java">基于Java配置：</a> 从Spring3.0开始，由Spring JavaConfig提供的许多功能已经成为Spring框架中的核心部分。这样你可以使用Java程序而不是XML文件定义外部应用程序中的bean类。使用这些新功能，可以查看@Configuration,@Bean,@Import和@DependsOn这些注解</li>
</ul>
<p>Spring配置由必须容器管理的一个或通常多个定义好的bean组成。基于XML配置的元数据中，这些bean通过标签定义在顶级标签内部。在Java配置中通常在使用@Configuration注解的类中使用@Bean注解方法。</p>
<blockquote>
<p>基于目前spring被广泛应用和spring-boot的火爆，基于java的配置成为主流方式。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="容器实例化"><a href="#容器实例化" class="headerlink" title="容器实例化"></a>容器实例化</h3><p><strong>使用AnnotationConfigApplicationContext实例化Spring容器</strong></p>
<p>下面的部分介绍Spring的AnnotationConfigApplicationContext，Spring 3.0的新内容。这个通用的ApplicationContext实现不仅可以接受@Configuration注解类为输入，还可以接受使用JSR-330元数据注解的简单类和@Component类。</p>
<p>当@Configuration注解的类作为输入时，@Configuration类本身会被注册为一个bean，在这个类中所有用@Bean注解的方法都会被定义为一个bean。</p>
<p>当使用@Component和JSR-330类时，它们被注册为bean的定义，并且假设在有必要时使用这些类内部诸如@Autowired或@Inject之类的DI元数据。</p>
<p><strong>简单构造</strong></p>
<p>实例化使用@Configuration类作为输入实例化AnnotationConfigApplicationContext和实例化ClassPathXmlApplicationContext时使用Spring的XML文件作为输入的方式大致相同。这在无XML配置的Spring容器时使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class); </span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class); </span><br><span class="line">    myService.doStuff(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如上所述，AnnotationConfigApplicationContext不限于仅使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Configuration</a>类。任何<a target="_blank" rel="noopener" href="https://ddkk.com/">@Component</a>或JSR-330注解的类都可以作为输入提供给构造函数。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class); </span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class); </span><br><span class="line">    myService.doStuff(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面假设MyServiceImpl、Dependency1和Dependency2都用了Spring的依赖注入的注解，例如<a target="_blank" rel="noopener" href="https://ddkk.com/">@Autowired</a>。</p>
<p><strong>使用register(Class<code>&lt;?&gt;</code>…)的方式构建容器</strong></p>
<p>也可以使用无参构造函数实例化AnnotationConfigApplicationContext，然后使用register()方法配置。当使用编程方式构建AnnotationConfigApplicationContext时，这种方法特别有用。</p>
<p><strong>使用scan（String …）组件扫描</strong></p>
<p>启用组件扫描，只需要在你的<a target="_blank" rel="noopener" href="https://ddkk.com/">@Configuration</a>类中做如下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>有Spring使用经验的用户，对Spring XML的context的声明非常熟悉：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>在上面的例子中，com.acme将会被扫描，它会寻找任何<a target="_blank" rel="noopener" href="https://ddkk.com/">@Component</a>注解的类，这些类将会在Spring的容器中被注册成为一个bean。AnnotationConfigApplicationContext暴露的scan(String…)方法以达到相同组件扫描的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(); </span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>); </span><br><span class="line">    ctx.refresh(); </span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>记住：使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Configuration</a>注解的类是使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Component</a>进行元注解，所以它们也是组件扫描的候选，假设AppConfig被定义在com.acme这个包下（或者它下面的任何包），它们都会在调用scan()方法期间被找出来，然后在refresh()方法中它们所有的<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>方法都会被处理，在容器中注册成为bean。</p>
<p><strong>AnnotationConfigWebApplicationContext对于web应用的支持</strong></p>
<p>AnnotationConfigApplicationContext在WebApplicationContext中的变体为<br>AnnotationConfigWebApplicationContext。当配置Spring ContextLoaderListener servlet 监听器、Spring MVC DispatcherServlet的时候，可以用此实现。下面为配置典型的Spring MVC DispatcherServlet的web.xml代码段。注意contextClass上下文参数和init-param的使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext </span></span><br><span class="line"><span class="comment">        instead of the default XmlWebApplicationContext --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> </span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext </span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited </span></span><br><span class="line"><span class="comment">        fully-qualified @Configuration classes. Fully-qualified packages may also be </span></span><br><span class="line"><span class="comment">        specified for component-scanning --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext </span></span><br><span class="line"><span class="comment">            instead of the default XmlWebApplicationContext --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span> </span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext </span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited </span></span><br><span class="line"><span class="comment">            and fully-qualified @Configuration classes --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span> </span><br></pre></td></tr></table></figure>



<h3 id="使用-Bean注解"><a href="#使用-Bean注解" class="headerlink" title="使用@Bean注解"></a><strong>使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>注解</strong></h3><p><a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>是XML元素方法级注解的直接模拟。它支持由提供的一些属性，例如：<a target="_blank" rel="noopener" href="http://ddkk.com/">init-method</a>，<a target="_blank" rel="noopener" href="http://ddkk.com/">destroy-method</a>，<a target="_blank" rel="noopener" href="http://ddkk.com/">autowiring</a>和name。</p>
<p>您可以在<a target="_blank" rel="noopener" href="https://ddkk.com/">@Configuration</a>或<a target="_blank" rel="noopener" href="https://ddkk.com/">@Component</a>注解的类中使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>注解。</p>
<p><strong>定义一个bean</strong></p>
<p>要定义一个bean，只需在一个方法上使用<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>注解。您可以使用此方法在指定方法返回值类型的ApplicationContext中注册bean定义。默认情况下，bean名称与方法名称相同。以下是<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>方法声明的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这种配置完全和下面的Spring XML配置等价：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>两种声明都可以使得一个名为transferService的bean在ApplicationContext可用，绑定到TransferServiceImpl类型的对象实例上：</p>
<p>transferService -&gt; com.acme.TransferServiceImpl</p>
<p><strong>Bean 依赖</strong></p>
<p><a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>注解方法可以具有描述构建该bean所需依赖关系的任意数量的参数。例如，如果我们的TransferService需要一个AccountRepository，我们可以通过一个方法参数实现该依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这种解决原理和基于构造函数的依赖注入几乎相同，请参考相关章节，查看详细信息。</p>
<p><strong>生命周期回调</strong></p>
<p>任何使用了<a target="_blank" rel="noopener" href="https://ddkk.com/">@Bean</a>定义了的类都支持常规生命周期回调，并且可以使用JSR-250中的<a target="_blank" rel="noopener" href="https://ddkk.com/">@PostConstruct</a>和<a target="_blank" rel="noopener" href="https://ddkk.com/">@PreDestroy</a>注解，详细信息，参考JSR-250注解。</p>
<p>完全支持常规的Spring生命周期回调。如果一个bean实现了InitializingBean，DisposableBean或Lifecycle接口，它们的相关方法就会被容器调用。</p>
<p>完全支持*Aware系列的接口，例如：BeanFactoryAware，BeanNameAware，MessageSourceAware，ApplicationContextAware等。</p>
<p>一个完整的基于java配置的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">(AccountRepository accountRepository)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepositoryConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTestConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// return new DataSource </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class); </span><br><span class="line">    <span class="comment">// everything wires up across configuration classes... </span></span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class); </span><br><span class="line">    transferService.transfer(<span class="number">100.00</span>, <span class="string">&quot;A123&quot;</span>, <span class="string">&quot;C456&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="profiles-定义（不同环境）"><a href="#profiles-定义（不同环境）" class="headerlink" title="profiles 定义（不同环境）"></a>profiles 定义（不同环境）</h3><p>Bean定义profiles是在核心容器中允许不同的bean在不同环境注册的机制。</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/Profile">@Profile</a></strong></p>
<p>当一个或者多个特定的profiles被激活，<a target="_blank" rel="noopener" href="https://github.com/Profile">@Profile</a>注解允许你指定一个有资格的组件来注册。使用我们上面的例子，我们可以按照下面的重写dataSource配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandaloneDataConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>() </span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL) </span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>) </span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>) </span><br><span class="line">            .build(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JndiDataConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod=&quot;&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(); </span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>如前所述，使用<a target="_blank" rel="noopener" href="https://github.com/Bean">@Bean</a>方法，通常会选择使用程序话的JNDI查找：要么使用Spring的 JndiTemplate&#x2F;JndiLocatorDelegate帮助要么直接使用上面展示的JNDI InitialContext，而不是强制声明返回类型为FactoryBean的JndiObjectFactoryBean变体。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Profile">@Profile</a>可以被用作为创建一个自定义组合注解的元注解。下面的例子定义了一个<a target="_blank" rel="noopener" href="https://github.com/Production">@Production</a>注解，它可以被用作替换<a target="_blank" rel="noopener" href="https://github.com/Profile">@Profile</a>（“production”）的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Production &#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在仅仅包含一个特殊bean的配置类中，<a target="_blank" rel="noopener" href="https://github.com/Profile">@Profile</a>也可以被声明在方法级别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">devDataSource</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>() </span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL) </span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>) </span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>) </span><br><span class="line">            .build(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="meta">@Profile(&quot;production&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">productionDataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(); </span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>XML对应元素的profile属性。我们上面的示例配置可以重写为下面的两个XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>激活profile</strong></p>
<p>现在我们已经更新了我们的配置，我们仍然需要说明哪个profile是激活的。如果我们现在开始我们示例应用程序，我们将会看到一个NoSuchBeanDefinitionException被抛出，因为容器找不到一个名为dataSource的Spring bean。<br>激活一个profile可以通过多种方式完成，但是大多数情况下，最直接的办法就是通过存在ApplicationContext当中的环境变量的API进行编程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(); </span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;dev&quot;</span>); </span><br><span class="line">ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); </span><br><span class="line">ctx.refresh(); </span><br></pre></td></tr></table></figure>

<p>除此之外，profiles也可以通过声明spring.profiles.active属性来激活，这个可以通过在系统环境变量，JVM系统属性，web.xml中的servlet上下文环境参数，甚至JNDI的入口（请参考 3.13.3, “PropertySource abstraction”）。在集成测试中，激活profiles可以通过在Spring-test模块中的<a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>注解来声明（参见“使用profiles来配置上下文环境”章节）。</p>
<p>注意，profiles不是“二者选一”的命题；它可以一次激活多个profiles。以编程的方式来看，简单的传递多个profile名字给接受String 可变变量参数的setActiveProfiles()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;profile1&quot;</span>, <span class="string">&quot;profile2&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>在声明式中，spring.profiles.active可以接受以逗号分隔的profile 名称列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=<span class="string">&quot;profile1,profile2&quot;</span> </span><br></pre></td></tr></table></figure>

<p><strong>默认的profile</strong></p>
<p>默认配置文件表示默认启用的配置文件。考虑以下几点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataConfig</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>() </span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL) </span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>) </span><br><span class="line">            .build(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果没有profile是激活状态，上面的dataSource将会被创建；这种方式可以被看做是对一个或者多个bean提供了一种默认的定义方式。如果启用任何的profile，那么默认的profile都不会被应用。<br>在上下文环境可以使用setDefaultProfiles()或者spring.profiles.default属性来修改默认的profile名字。</p>
<h3 id="属性源抽象"><a href="#属性源抽象" class="headerlink" title="属性源抽象"></a>属性源抽象</h3><p>Spring 环境抽象提供了可配置的属性源层次结构的搜索操作。为了充分的解释，请考虑下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>(); </span><br><span class="line"><span class="type">Environment</span> <span class="variable">env</span> <span class="operator">=</span> ctx.getEnvironment(); </span><br><span class="line"><span class="type">boolean</span> <span class="variable">containsFoo</span> <span class="operator">=</span> env.containsProperty(<span class="string">&quot;foo&quot;</span>); </span><br><span class="line">System.out.println(<span class="string">&quot;Does my environment contain the &#x27;foo&#x27; property? &quot;</span> + containsFoo); </span><br></pre></td></tr></table></figure>

<p>在上面的代码段中，我们看到了一个高级别的方法来要求Spring是否为当前环境定义foo属性。为了回答这个问题，环境对象对一组PropertySource对象执行搜索。一个PropertySource是对任何key-value资源的简单抽象，并且Spring 的标准环境是由两个PropertySource配置的，一个表示一系列的JVM 系统属性(System.getProperties()),一个表示一系列的系统环境变量(System.getenv())。</p>
<blockquote>
<p>这些默认的属性资源存在于StandardEnvironment，可以在应用中独立使用。StandardServletEnvironment包含其他默认的属性资源，包括servlet配置和servlet上下文参数。它可以选择性的启用JndiPropertySource。详细信息请查看javadocs。</p>
</blockquote>
<p>具体的说，当使用StandardEnvironment时，如果在运行时系统属性或者环境变量中包括foo，那么调用env.containsProperty(“foo”)方法将会返回true。</p>
<p>搜索是按照层级执行的。默认情况，系统属性优先于环境变量，所以这两个地方同时存在属性foo的时候，调用env.getProperty(“foo”)将会返回系统属性中的foo值。注意，属性值不会被合并而是被之前的值覆盖。对于一个普通的StandardServletEnvironment，它完整的层次结构如下，最顶端的优先级最高：</p>
<ul>
<li>ServletConfig参数(如果适用，例如DispatcherServlet上下文环境)</li>
<li>ServletContext参数(web.xml中的context-param)</li>
<li>JNDI环境变量(“java:comp&#x2F;env&#x2F;”)</li>
<li>JVM系统属性(“-D”命令行参数)</li>
<li>JVM系统环境变量(操作系统环境变量)</li>
</ul>
<p>更重要的是，整个机制都是可配置的。也许你有个自定义的属性来源，你想把它集成到这个搜到里面。这也没问题，只需简单的实现和实例化自己的PropertySource，并把它添加到当前环境的PropertySources集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>(); </span><br><span class="line"><span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> ctx.getEnvironment().getPropertySources(); </span><br><span class="line">sources.addFirst(<span class="keyword">new</span> <span class="title class_">MyPropertySource</span>()); </span><br></pre></td></tr></table></figure>

<p>在上面的代码中，MyPropertySource被添加到搜索中的最高优先级。如果它包含了一个foo属性，在任何其他的PropertySource中的foo属性之前它会被检测到并返回。MutablePropertySources API暴露了很多允许精确操作该属性源集合的方法。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PropertySource">@PropertySource</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/PropertySource">@PropertySource</a>注解对添加一个PropertySource到Spring的环境变量中提供了一个便捷的和声明式的机制。<br>给出一个名为”app.properties”的文件，它含了testbean.name&#x3D;myTestBean的键值对，下面的<a target="_blank" rel="noopener" href="https://github.com/Configuration">@Configuration</a>类使用<a target="_blank" rel="noopener" href="https://github.com/PropertySource">@PropertySource</a>的方式来调用testBean.getName()，将会返回”myTestBean”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> Environment env; </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"> <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(); </span><br><span class="line">  testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>)); </span><br><span class="line">  <span class="keyword">return</span> testBean; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>任何出现在<a target="_blank" rel="noopener" href="https://github.com/PropertySource">@PropertySource</a>中的资源位置占位符都会被注册在环境变量中的资源解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123; </span><br><span class="line"> <span class="meta">@Autowired</span> </span><br><span class="line"> Environment env; </span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span> </span><br><span class="line"> <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>(); </span><br><span class="line">  testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>)); </span><br><span class="line">  <span class="keyword">return</span> testBean; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>假设”my.placeholder”已经在其中的一个资源中被注册，例如：系统属性或环境变量，占位符将会被正确的值解析。如果没有，”default&#x2F;path”将会使用默认值。如果没有默认值，而且无法解释属性，则抛出IllegalArgumentException异常。</p>
<h3 id="容器-ApplicationContext-的额外功能"><a href="#容器-ApplicationContext-的额外功能" class="headerlink" title="容器(ApplicationContext)的额外功能"></a>容器(ApplicationContext)的额外功能</h3><p>org.springframework.beans.factory包提供基本的功能来管理和操作bean，包括以编程的方式。The org.springframework.context包增加了ApplicationContext接口，它继承了BeanFactory接口，除了以面向应用框架的风格扩展接口来提供一些额外的功能。</p>
<p>为了增强BeanFactory在面向框架风格的功能，上下文的包还提供了以下的功能：</p>
<ul>
<li>通过MessageSource接口访问i18n风格的消息</li>
<li>通过ResourceLoader接口访问类似URL和文件资源</li>
<li>通过ApplicationEventPublisher接口，即bean实现ApplicationListener接口来进行事件发布</li>
<li>通过HierarchicalBeanFactory接口实现加载多个(分层)上下文，允许每个上下文只关注特定的层，例如应用中的web层</li>
</ul>
<h4 id="标准和自定义事件"><a href="#标准和自定义事件" class="headerlink" title="标准和自定义事件"></a>标准和自定义事件</h4><p>ApplicationEvent类和ApplicationListener接口提供了ApplicationContext中的事件处理。如果一个bean实现了ApplicationListener接口，然后它被部署到上下问中，那么每次ApplicationEvent发布到ApplicationContext中时，bean都会收到通知。本质上，这是观察者模型。</p>
<blockquote>
<p>从Spring 4.2开始，事件的基础得到了重要的提升，并提供了基于注解模型及任意事件发布的能力，这个对象不一定非要继承ApplicationEvent。当这个对象被发布时，我们把他包装在事件中。</p>
</blockquote>
<p>Spring提供了一下的标准事件：</p>
<p><strong>内置事件</strong></p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ContextRefreshedEvent</td>
<td align="left">当ApplicationContext被初始化或者被刷新的时候发布，例如，在ConfigurableApplicationContext接口上调用refresh()方法。”初始化”在这里意味着所有的bean被加载，后置处理器被检测到并且被激活，单例的预加载，以及ApplicationContext对象可以使用。只要上下文还没有被关闭，refresh就可以被触发多次，前提所选的ApplicationContext支持热刷新。例如，XmlWebApplicationContext支持热刷新，而GenericApplicationContext不支持。</td>
</tr>
<tr>
<td align="left">ContextStartedEvent</td>
<td align="left">当ApplicationContext启动时发布，在ConfigurableApplicationContext接口上调用start()方法。”已启动”意味着所有bean的生命周期会接受到一个明确的启动信号。通常这个信号用来停止后的重启，但是他也可以被用来启动没有配置为自动启动的组件，例如，在初始化时还没启动的组件。</td>
</tr>
<tr>
<td align="left">ContextStoppedEvent</td>
<td align="left">当ApplicationContext 停止时发布，在ConfigurableApplicationContext接口上调用stop()方法。”停止”意味这所有的bean的生命周期都会受到一个明确的停止信号。通过调用start()方法可以重启一个已经停止的上下文。</td>
</tr>
<tr>
<td align="left">ContextClosedEvent</td>
<td align="left">当ApplicationContext 关闭时发布，在ConfigurableApplicationContext接口上调用close()方法。”关闭”意味着所有的单例bean都会被销毁。关闭的上下文就是它生命周期的末尾。它不能刷新或者重启。</td>
</tr>
<tr>
<td align="left">RequestHandledEvent</td>
<td align="left">接受一个HTTP请求的时候，一个特定的web时间会通知所有的bean。这个时间的发布是在请求完成。此事件仅适用于使用Spring的DispatcherServlet的Web应用程序。</td>
</tr>
</tbody></table>
<p>你可以创建并发布自己的自定义事件。这个例子演示了一个继承Spring ApplicationEvent的简单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackListEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String test; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlackListEvent</span><span class="params">(Object source, String address, String test)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(source); </span><br><span class="line">        <span class="built_in">this</span>.address = address; </span><br><span class="line">        <span class="built_in">this</span>.test = test; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// accessor and other methods... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>为了发布一个自定义的ApplicationEvent，在ApplicationEventPublisher中调用publishEvent()方法。通常在实现了ApplicationEventPublisherAware接口并把它注册为一个Spring bean的时候它就完成了。下面的例子展示了这么一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailService</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList; </span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.blackList = blackList; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.publisher = publisher; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String address, String text)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address)) &#123; </span><br><span class="line">            <span class="type">BlackListEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackListEvent</span>(<span class="built_in">this</span>, address, text); </span><br><span class="line">            publisher.publishEvent(event); </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// send email... </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在配置时，Spring容器将检测到EmailService实现了ApplicationEventPublisherAware，并将自动调用setApplicationEventPublisher()方法。实际上，传入的参数将是Spring容器本身;您只需通过ApplicationEventPublisher接口与应用程序上下文进行交互。</p>
<p>为了自定义ApplicationEvent，创建一个试下了ApplicationListener的类并把他注册为一个Spring bean。下面例子展示这样一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackListNotifier</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;BlackListEvent&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotificationAddress</span><span class="params">(String notificationAddress)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.notificationAddress = notificationAddress; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(BlackListEvent event)</span> &#123; </span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress... </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>请注意，ApplicationListener通常用你自定义的事件BlackListEvent类型参数化的。这意味着onApplicationEvent()方法可以保持类型安全，避免向下转型的需要。您可以根据需要注册许多的事件侦听器，但请注意，默认情况下，事件侦听器将同步接收事件。这意味着publishEvent()方法会阻塞直到所有的监听者都处理完。这种同步和单线程方法的一个优点是，如果事务上下文可用，它就会在发布者的事务上下文中处理。如果必须需要其他的时间发布策略，请参考javadoc的 Spring ApplicationEventMulticaster 接口。</p>
<p>下面例子展示了使用配置和注册上述每个类的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.EmailService&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;blackList&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.spammer@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>known.hacker@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>john.doe@example.org<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;blackListNotifier&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.BlackListNotifier&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;notificationAddress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blacklist@example.org&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>把他们放在一起，当调用emailService的sendEmail()方法时，如果有任何应该被列入黑名单的邮件，那么自定义的BlackListEvent事件会被发布。blackListNotifier 会被注册为一个ApplicationListener，从而接受BlackListEvent，届时通知适当的参与者。</p>
<blockquote>
<p>Spring 的事件机制的设计是用在Spring bean和相同应用上下文的简单通讯。然而，对于更复杂的企业集成需求，单独维护Spring Integration工程对构建著名的Spring编程模型轻量级，面向模式，事件驱动架构提供了完整的支持。</p>
</blockquote>
<p><strong>基于注解的事件监听器</strong></p>
<p>从Spring 4.2开始，一个事件监听器可以通过EventListener注解注册在任何managed bean的公共方法上。BlackListNotifier可以重写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackListNotifier</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notificationAddress; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNotificationAddress</span><span class="params">(String notificationAddress)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.notificationAddress = notificationAddress; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> &#123; </span><br><span class="line">        <span class="comment">// notify appropriate parties via notificationAddress... </span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如上所示，方法签名实际上会推断出它监听的是哪一个类型的事件。这也适用于泛型嵌套，只要你在过滤的时候可以根据泛型参数解析出实际的事件。</p>
<p>如果你的方法需要监听好几个事件或根本没有参数定义它，事件类型也可以用注解本身指明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(&#123;ContextStartedEvent.class, ContextRefreshedEvent.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleContextStart</span><span class="params">()</span> &#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>对特殊的时间调用方法，根据定义的SpEL表达式来匹配实际情况，通过条件属性注解，<br>也可以通过condition注解来添加额外的运行过滤，它对一个特殊事件的方法实际调用是根据它是否匹配condition注解所定义的SpEL表达式。</p>
<p>例如，只要事件的测试属性等于foo，notifier可以被重写为只被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(condition = &quot;#blEvent.test == &#x27;foo&#x27;&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlackListEvent</span><span class="params">(BlackListEvent blEvent)</span> &#123; </span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>每个SpEL表达式在此评估专用的上下文。下表列出的条目存在上下文中可用，所以可以调用他们处理conditional事件：</p>
<p><strong>表3.8. 存在元数据中的Event SpEL 表达式</strong></p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">位置</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事件</td>
<td align="left">根路径</td>
<td align="left">实际的ApplicationEvent</td>
<td align="left">#root.event</td>
</tr>
<tr>
<td align="left">参数数组</td>
<td align="left">根路径</td>
<td align="left">参数(数组) 目标调用</td>
<td align="left">#root.args[0]</td>
</tr>
<tr>
<td align="left">参数名字</td>
<td align="left">上下文</td>
<td align="left">任何的方法参数名称。如果由于某些名称的原因而不可用(例如：没有调试信息)，参数名称也会存在#a&lt;#arg&gt;， #arg代表参数索引开始的地方(从0开始)</td>
<td align="left">#blEvent 或 #a0(也可以使用#p0 or #p&lt;#arg&gt; 作为别名)</td>
</tr>
</tbody></table>
<p>注意，#root.event允许你访问底层的时间，即使你的方法签名实际上是指已发布的任意对象。</p>
<p>如果您需要发布一个事件作为处理另一个事件的结果，只需更改方法签名来返回应该被发布的事件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span> </span><br><span class="line"><span class="keyword">public</span> ListUpdateEvent <span class="title function_">handleBlackListEvent</span><span class="params">(BlackListEvent event)</span> &#123; </span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress and </span></span><br><span class="line">    <span class="comment">// then publish a ListUpdateEvent... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>异步监听器不支持这个特性</p>
</blockquote>
<p>这个新方法将对上述方法处理的每个BlackListEvent都会发布一个新的ListUpdateEvent。如果需要发布多个时间，只需要返回事件集合即可。</p>
<p><strong>异步监听器</strong></p>
<p>如果你希望一个特定的监听器去异步处理事件，只需要重新使用常规的<a target="_blank" rel="noopener" href="https://github.com/Async">@Async</a>支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span> </span><br><span class="line"><span class="meta">@Async</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> &#123; </span><br><span class="line">    <span class="comment">// BlackListEvent is processed in a separate thread </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当使用异步事件的时候有下面两个限制：</p>
<p><strong>1、</strong> 如果事件监听器抛出异常，则不会将其传播给调用者，查看AsyncUncaughtExceptionHandler获取详细信息；<br><strong>2、</strong> 此类事件监听器无法发送回复如果你需要将处理结果发送给另一个时间，注入ApplicationEventPublisher里面手动发送事件；</p>
<p><strong>顺序的监听器</strong></p>
<p>如果你需要一个监听器在另一个监听器调用前被调用，只需要在方法声明上添加<a target="_blank" rel="noopener" href="https://github.com/Order">@Order</a>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span> </span><br><span class="line"><span class="meta">@Order(42)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlackListEvent</span><span class="params">(BlackListEvent event)</span> &#123; </span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>泛型事件</strong></p>
<p>你可以使用泛型来进一步的定义事件的结构。考虑EntityCreatedEvent，T的类型就是你要创建的真实类型。你可以创建下面的监听器定义，它只接受Person类型的EntityCreatedEvent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPersonCreated</span><span class="params">(EntityCreatedEvent&lt;Person&gt; event)</span> &#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>触发了事件解析泛型参数，<br>由于类型擦除，只有在触发了事件解析事件监听过器滤的泛型参数(类似于PersonCreatedEvent继承了EntityCreatedEvent { … })，此操作才会起作用。</p>
<p>在某些情况下，如果所有的时间都遵循相同的结果(上述事件应该是这样)，这可能有点冗余。在这种情况下，你可以实现ResolvableTypeProvider来引导超出框架运行是环境提供的范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntityCreatedEvent</span>&lt;T&gt; </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">implements</span> <span class="title class_">ResolvableTypeProvider</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EntityCreatedEvent</span><span class="params">(T entity)</span> &#123; </span><br><span class="line">        <span class="built_in">super</span>(entity); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> ResolvableType <span class="title function_">getResolvableType</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> ResolvableType.forClassWithGenerics(getClass(), </span><br><span class="line">                ResolvableType.forInstance(getSource())); </span><br><span class="line">    &#125; </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不仅适用于ApplicationEvent，还可以作为时间发送的任意对象。</p>
</blockquote>
<h3 id="关于beanFactory"><a href="#关于beanFactory" class="headerlink" title="关于beanFactory"></a>关于beanFactory</h3><p>BeanFactory为Spring的IoC功能提供了底层的基础，但是它仅仅被用于和第三方框架的集成，现在对于大部分的Spring用户来说都是历史了。BeanFactory及其相关的接口，例如：BeanFactoryAware，InitializingBean，DisposableBean，在Spring中仍然有所保留，目的就是为了让大量的第三方框架和Spring集成时保持向后兼容。</p>
<p><strong>BeanFactory or ApplicationContext？</strong></p>
<p>尽量使用ApplicationContext除非你有更好的理由不用它。<br>因为ApplicationContext包括了BeanFactory的所有功能，通常也优于BeanFactory,除非一些少数的场景，例如：在受资源约束的嵌入式设备上运行一个嵌入式应用，它的内存消耗可能至关重要，并且可能会产生字节。然而，对于大多数典型的企业级应用和系统来说，ApplicationContext才是你想使用的。Spring大量使用了BeanPostProcessor扩展点（以便使用代理等）。如果你仅仅只使用简单的BeanFactory，很多的支持功能将不会有效，例如：事务和AOP，但至少不会有额外的步骤。</p>
<p><strong>特性矩阵</strong></p>
<table>
<thead>
<tr>
<th align="left">Feature</th>
<th align="left">BeanFactory</th>
<th align="left">ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bean实例化&#x2F;装配</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">BeanPostProcessor自动注册</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">BeanFactoryPostProcessor自动注册</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">MessageSource便捷访问（针对i18n）</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">ApplicationEvent 发布</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
</tbody></table>
<h2 id="spring-的资源管理-Resource"><a href="#spring-的资源管理-Resource" class="headerlink" title="spring 的资源管理(Resource)"></a>spring 的资源管理(Resource)</h2><p>Resource抽象在Spring本身被广泛使用，作为需要资源的许多方法签名中的参数类型。 某些Spring API中的其他方法（例如各种ApplicationContext实现的构造函数）采用一个String，它以未安装或简单的形式用于创建适用于该上下文实现的资源，或者通过String路径上的特殊前缀，允许调用者 以指定必须创建和使用特定的资源实现。</p>
<h4 id="Resource-接口"><a href="#Resource-接口" class="headerlink" title="Resource 接口"></a>Resource 接口</h4><p>Resource 接口（实现）不仅可以被 spring 大量的应用，其也非常适合作为你编程中访问资源的辅助工具类。当你仅需要使用到 Resource 接口实现时，可以直接忽略 spring 的其余部分。单独使用 Rsourece 实现，会造成代码与 spring 的部分耦合，可也仅耦合了其中一小部分辅助类，而且你可以将 Reource 实现作为 URL 的一种访问底层更为有效的替代，与你引入其他库来达到这种目的是一样的。</p>
<p>需要注意的是 Resource 实现并没有去重新发明轮子，而是尽可能地采用封装。举个例子，UrlResource 里就封装了一个 URL 对象，在其内的逻辑就是通过封装的 URL 对象来完成的。</p>
<p>spring 直接提供了多种开箱即用的 Resource 实现。</p>
<p><strong>UrlResource</strong></p>
<p>UrlResource 封装了一个 java.net.URL 对象，用来访问 URL 可以正常访问的任意对象，比如文件、an HTTP target, an FTP target, 等等。所有的 URL 都可以用一个标准化的字符串来表示。如通过正确的标准化前缀，可以用来表示当前 URL 的类型，当中就包括用于访问文件系统路径的 file:,通过 http 协议访问资源的 http:,通过 ftp 协议访问资源的 ftp:，还有很多……</p>
<p>可以显式化地使用 UrlResource 构造函数来创建一个 UrlResource，不过通常我们可以在调用一个 api 方法是，使用一个代表路径的 String 参数来隐式创建一个 UrlResource。对于后一种情况，会由一个 javabean PropertyEditor 来决定创建哪一种 Resource。如果路径里包含某一个通用的前缀（如 classpath:),PropertyEditor 会根据这个通用的前缀来创建恰当的 Resource；反之，如果 PropertyEditor 无法识别这个前缀，会把这个路径作为一个标准的 URL 来创建一个 UrlResource。</p>
<p><strong>ClassPathResource</strong></p>
<p>ClassPathResource 可以从类路径上加载资源，其可以使用线程上下文加载器、指定加载器或指定的 class 类型中的任意一个来加载资源。</p>
<p>当类路径上资源存于文件系统中，ClassPathResource 支持以 java.io.File 的形式访问，可当类路径上的资源存于尚未解压(没有 被Servlet 引擎或其他可解压的环境解压）的 jar 包中，ClassPathResource 就不再支持以 java.io.File 的形式访问。鉴于上面所说这个问题，spring 中各式 Resource 实现都支持以 jave.net.URL 的形式访问。</p>
<p>可以显式使用 ClassPathResource 构造函数来创建一个 ClassPathResource ，不过通常我们可以在调用一个 api 方法时，使用一个代表路径的 String 参数来隐式创建一个 ClassPathResource。对于后一种情况，会由一个 javabean PropertyEditor 来识别路径中 classpath: 前缀，从而创建一个 ClassPathResource。</p>
<p><strong>FileSystemResource</strong></p>
<p>这是针对 java.io.File 提供的 Resource 实现。显然，我们可以使用 FileSystemResource 的 getFile() 函数获取 File 对象，使用 getURL() 获取 URL 对象。</p>
<p><strong>ServletContextResource</strong></p>
<p>这是为了获取 web 根路径的 ServletContext 资源而提供的 Resource 实现。</p>
<p>ServletContextResource 完全支持以流和 URL 的方式访问，可只有当 web 项目是已解压的(不是以 war 等压缩包形式存在)且该 ServletContext 资源存于文件系统里，ServletContextResource 才支持以 java.io.File 的方式访问。至于说到，我们的 web 项目是否已解压和相关的 ServletContext 资源是否会存于文件系统里，这个取决于我们所使用的 Servlet 容器。若 Servlet 容器没有解压 web 项目，我们可以直接以 JAR 的形式的访问，或者其他可以想到的方式（如访问数据库）等。</p>
<p><strong>InputStreamResource</strong></p>
<p>这是针对 InputStream 提供的 Resource 实现。建议，在确实没有找到其他合适的 Resource 实现时，才使用 InputSteamResource。如果可以，尽量选择 ByteArrayResource 或其他基于文件的 Resource 实现来代替。</p>
<p>与其他Resource 实现已比较，InputStreamRsource 倒像一个已打开资源的描述符,因此，调用 isOpen() 方法会返回 true。除了在需要获取资源的描述符或需要从输入流多次读取时，都不要使用 InputStreamResource 来读取资源。</p>
<p><strong>ByteArrayResource</strong></p>
<p>这是针对字节数组提供的 Resource 实现。可以通过一个字节数组来创建 ByteArrayResource。</p>
<p>当需要从字节数组加载内容时，ByteArrayResource 是一个不错的选择，使用 ByteArrayResource 可以不用求助于 InputStreamResource。</p>
<h4 id="ResourceLoader-接口"><a href="#ResourceLoader-接口" class="headerlink" title="ResourceLoader 接口"></a>ResourceLoader 接口</h4><p>ResourceLoader 接口是用来加载 Resource 对象的，换句话说，就是当一个对象需要获取 Resource 实例时，可以选择实现 ResourceLoader 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123; </span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>spring 里所有的应用上下文都是实现了 ResourceLoader 接口，因此，所有应用上下文都可以通过 getResource() 方法获取 Resource 实例。</p>
<p>当你在指定应用上下文调用 getResource() 方法时，而指定的位置路径又没有包含特定的前缀，spring 会根据当前应用上下文来决定返回哪一种类型 Resource。举个例子，假设下面的代码片段是通过 ClassPathXmlApplicationContext 实例来调用的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>那spring 会返回一个 ClassPathResource 对象；</p>
<p>类似的，如果是通过实例 FileSystemXmlApplicationContext 实例调用的，返回的是一个 FileSystemResource 对象；如果是通过 WebApplicationContext 实例的，返回的是一个 ServletContextResource 对象…… 如上所说，你就可以在指定的应用上下中使用 Resource 实例来加载当前应用上下文的资源。</p>
<p>还有另外一种场景里，如在其他应用上下文里，你可能会强制需要获取一个 ClassPathResource 对象，这个时候，你可以通过加上指定的前缀来实现这一需求，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;classpath:some/resource/path/myTemplate.txt&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>类似的，你可以通过其他任意的 url 前缀来强制获取 UrlResource 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;file:///some/resource/path/myTemplate.txt&quot;</span>); </span><br><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;http://myhost.com/resource/path/myTemplate.txt&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>下面，给出一个表格来总结一下 spring 根据各种位置路径加载资源的策略：</p>
<p>Table 4.1. Resource strings</p>
<table>
<thead>
<tr>
<th align="left">前缀</th>
<th align="left">例子</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">classpath:</td>
<td align="left">classpath:com&#x2F;myapp&#x2F;config.xml</td>
<td align="left">从类路径加载</td>
</tr>
<tr>
<td align="left">file:</td>
<td align="left"><a target="_blank" rel="noopener" href="http://data/config.xml">file:&#x2F;&#x2F;&#x2F;data&#x2F;config.xml</a></td>
<td align="left">以URL形式从文件系统加载</td>
</tr>
<tr>
<td align="left">http:</td>
<td align="left"><a target="_blank" rel="noopener" href="http://myserver/logo.png">http://myserver/logo.png</a></td>
<td align="left">以URL形式加载</td>
</tr>
<tr>
<td align="left">(none)</td>
<td align="left">&#x2F;data&#x2F;config.xml</td>
<td align="left">由底层的ApplicationContext实现决定</td>
</tr>
</tbody></table>
<h2 id="spring表达式语言（SpEL）"><a href="#spring表达式语言（SpEL）" class="headerlink" title="spring表达式语言（SpEL）"></a>spring表达式语言（SpEL）</h2><p>Spring Expression Language（简称SpEL）是一种功能强大的表达式语言、用于在运行时查询和操作对象图；语法上类似于Unified EL，但提供了更多的特性，特别是方法调用和基本字符串模板函数。</p>
<p>SpEL支持以下的一些特性：</p>
<ul>
<li>字符表达式</li>
<li>布尔和关系操作符</li>
<li>正则表达式</li>
<li>类表达式</li>
<li>访问properties，arrays，lists，maps等集合</li>
<li>方法调用</li>
<li>关系操作符</li>
<li>赋值</li>
<li>调用构造器</li>
<li>Bean对象引用</li>
<li>创建数组</li>
<li>内联lists</li>
<li>内联maps</li>
<li>三元操作符</li>
<li>变量</li>
<li>用户自定义函数</li>
<li>集合投影</li>
<li>集合选择</li>
<li>模板表达式</li>
</ul>
<h2 id="spring框架下的Test"><a href="#spring框架下的Test" class="headerlink" title="spring框架下的Test"></a>spring框架下的Test</h2><p><strong>单元测试以及</strong>spring提供的注解</p>
<h3 id="Spring测试注解"><a href="#Spring测试注解" class="headerlink" title="Spring测试注解"></a><strong>Spring测试注解</strong></h3><p>Spring框架提供以下Spring特定的注解集合，你可以在单元和集成测试中协同TestContext框架使用它们。请参考相应的JAVA帮助文档作进一步了解，包括默认的属性，属性别名等等。、</p>
<h4 id="BootstrapWith"><a href="#BootstrapWith" class="headerlink" title="@BootstrapWith"></a><a target="_blank" rel="noopener" href="https://github.com/BootstrapWith">@BootstrapWith</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/BootstrapWith">@BootstrapWith</a>是一个用于配置Spring TestContext框架如何引导的类级别的注解。具体地说，<a target="_blank" rel="noopener" href="https://github.com/BootstrapWith">@BootstrapWith</a>用于指定一个自定义的TestContextBootstrapper。请查看<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#testcontext-bootstrapping">引导TestContext框架</a>作进一步了解。</p>
<h4 id="ContextConfiguration"><a href="#ContextConfiguration" class="headerlink" title="@ContextConfiguration"></a><a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>定义了类级别的元数据来决定如何为集成测试来加载和配置应用程序上下文。具体地说，<a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>声明了用于加载上下文的应用程序上下文资源路径和注解类。</p>
<p>资源路径通常是类路径中的XML配置文件或者Groovy脚本；而注解类通常是使用<a target="_blank" rel="noopener" href="https://github.com/Configuration">@Configuration</a>注解的类。但是，资源路径也可以指向文件系统中的文件和脚本，解决类也可能是组件类等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(&quot;/test-config.xml&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlApplicationContextTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@ContextConfiguration(classes = TestConfig.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClassApplicationContextTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>作为声明资源路径或注解类的替代方案或补充，<a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>可以用于声明ApplicationContextInitializer类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(initializers = CustomContextIntializer.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextInitializerTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>偶尔也被用作声明ContextLoader策略。但注意，通常你不需要显示的配置加载器，因为默认的加载器已经支持资源路径或者注解类以及初始化器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;/test-context.xml&quot;, loader = CustomContextLoader.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomLoaderXmlApplicationContextTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>默认对继承父类定义的资源路径或者配置类以及上下文初始化器提供支持。</p>
</blockquote>
<p>参阅[Section 11.5.4, 上下文管理](<a target="_blank" rel="noopener" href="http://section/">http://section</a> 11.5.xn–4%2C context management-278prb&#x2F;)和<a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>帮助文档作进一步了解。</p>
<h4 id="WebAppConfiguration"><a href="#WebAppConfiguration" class="headerlink" title="@WebAppConfiguration"></a><a target="_blank" rel="noopener" href="https://github.com/WebAppConfiguration">@WebAppConfiguration</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/WebAppConfiguration">@WebAppConfiguration</a>是一个用于声明集成测试所加载的ApplicationContext须是WebApplicationContext的类级别的注解。测试类的<a target="_blank" rel="noopener" href="https://github.com/WebAppConfiguration">@WebAppConfiguration</a>注解只是为了保证用于测试的WebApplicationContext会被加载，它使用”file:src&#x2F;main&#x2F;webapp”路径默认值作为web应用的根路径（即，资源基路径）。资源基路径用于幕后创建一个MockServletContext作为测试的WebApplicationContext的ServletContext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebAppTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>注意<a target="_blank" rel="noopener" href="https://github.com/WebAppConfiguration">@WebAppConfiguration</a>必须和<a target="_blank" rel="noopener" href="https://github.com/ContextConfiguration">@ContextConfiguration</a>一起使用，或者在同一个测试类，或者在测试类层次结构中。请参阅<a target="_blank" rel="noopener" href="https://github.com/WebAppConfiguration">@WebAppConfiguration</a>帮助文档作进一步了解。</p>
<h4 id="ContextHierarchy"><a href="#ContextHierarchy" class="headerlink" title="@ContextHierarchy"></a><a target="_blank" rel="noopener" href="https://github.com/ContextHierarchy">@ContextHierarchy</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/ContextHierarchy">@ContextHierarchy</a>是一个用于为集成测试定义ApplicationContext层次结构的类级别的注解。@ContextHierarchy应该声明一个或多个@ContextConfiguration实例列表，其中每一个定义上下文层次结构的一个层次。下面的例子展示了在同一个测试类中@ContextHierarchy的使用方法。但是，@ContextHierarchy一样可以用于测试类的层次结构中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextHierarchy(&#123; </span></span><br><span class="line"><span class="meta"> @ContextConfiguration(&quot;/parent-config.xml&quot;), </span></span><br><span class="line"><span class="meta"> @ContextConfiguration(&quot;/child-config.xml&quot;) </span></span><br><span class="line"><span class="meta">&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextHierarchyTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@WebAppConfiguration</span> </span><br><span class="line"><span class="meta">@ContextHierarchy(&#123; </span></span><br><span class="line"><span class="meta"> @ContextConfiguration(classes = AppConfig.class), </span></span><br><span class="line"><span class="meta"> @ContextConfiguration(classes = WebConfig.class) </span></span><br><span class="line"><span class="meta">&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebIntegrationTests</span> &#123; </span><br><span class="line"> <span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果你想合并或者覆盖一个测试类的层次结构中的应用程序上下文中指定层次的配置，你就必须在类层次中的每一个相应的层次通过为@ContextConfiguration的name属性提供与该层次相同的值的方式来显示地指定这个层次。请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#testcontext-ctx-management-ctx-hierarchies">上下文层次关系</a>和@ContextHierarchy帮助文档来获得更多的示例。</p>
<h4 id="ActiveProfiles"><a href="#ActiveProfiles" class="headerlink" title="@ActiveProfiles"></a><a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>是一个用于当集成测试加载ApplicationContext的时候声明哪一个<em>bean definition profiles</em>被激活的类级别的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeveloperTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@ActiveProfiles(&#123;&quot;dev&quot;, &quot;integration&quot;&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeveloperIntegrationTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>默认为继承激活的在超类声明的 bean definition profiles提供支持。通过实现一个自定义的 ActiveProfilesResolver并通过<a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>的resolver属性来注册它的编程的方式来解决激活bean definition profiles问题也是可行的。</p>
<p>参阅使用环境profiles来配置上下文和<a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>帮助文档作进一步了解。</p>
</blockquote>
<p>参阅使用环境profiles来配置上下文和<a target="_blank" rel="noopener" href="https://github.com/ActiveProfiles">@ActiveProfiles</a>帮助文档作进一步了解。</p>
<h4 id="TestPropertySource"><a href="#TestPropertySource" class="headerlink" title="@TestPropertySource"></a><a target="_blank" rel="noopener" href="https://github.com/TestPropertySource">@TestPropertySource</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/TestPropertySource">@TestPropertySource</a>是一个用于为集成测试加载ApplicationContext时配置属性文件的位置和增加到Environment中的PropertySources集中的内联属性的类级别的注解。</p>
<p>测试属性源比那些从系统环境或者Java系统属性以及通过<a target="_blank" rel="noopener" href="https://github.com/PropertySource">@PropertySource</a>或者编程方式声明方式增加的属性源具有更高的优先级。而且，内联属性比从资源路径加载的属性具有更高的优先级。</p>
<p>下面的例子展示了如何从类路径中声明属性文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@TestPropertySource(&quot;/test.properties&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntegrationTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>面的例子展示了如何声明内联属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123; “timezone = GMT”, “port: 4242” &#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyIntegrationTests</span> &#123; </span><br><span class="line"><span class="comment">// class body… </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="DirtiesContext"><a href="#DirtiesContext" class="headerlink" title="@DirtiesContext"></a><a target="_blank" rel="noopener" href="https://github.com/DirtiesContext">@DirtiesContext</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/DirtiesContext">@DirtiesContext</a>指明测试执行期间该Spring应用程序上下文已经被弄脏（也就是说通过某种方式被更改或者破坏——比如，更改单例bean的状态）。当应用程序上下文被标为”脏”，它将从测试框架缓存中被移除并关闭。因此，Spring容器将为随后需要同样配置元数据的测试而被重建。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/DirtiesContext">@DirtiesContext</a>可以在同一个类或者类层次结构中的类级别和方法级别中使用。在这个场景下，应用程序上下文将在任意此注解的方法之前或之后以及当前测试类之前或之后被标为“脏”，这取决于配置的methodMode和classMode。</p>
<p>下面的例子解释了在多种配置场景下什么时候上下文会被标为“脏”。</p>
<ul>
<li>当在一个类中声明并将类模式设为BEFORE_CLASS，则在当前测试类之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = BEFORE_CLASS)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreshContextTests</span> &#123; </span><br><span class="line"><span class="comment">// some tests that require a new Spring container </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当在一个类中声明并将类模式设为AFTER_CLASS（也就是，默认的类模式），则在当前测试类之后。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextDirtyingTests</span> &#123; </span><br><span class="line"><span class="comment">// some tests that result in the Spring container being dirtied </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当在一个类中声明并将类模式设为BEFORE_EACH_TEST_METHOD，则在当前测试类的每个方法之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreshContextTests</span> &#123; </span><br><span class="line"><span class="comment">// some tests that require a new Spring container </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当在一个类中声明并将类模式设为AFTER_EACH_TEST_METHOD，则在当前测试类的每个方法之后。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextDirtyingTests</span> &#123; </span><br><span class="line"><span class="comment">// some tests that result in the Spring container being dirtied </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当在一个方法中声明并将方法模式设为BEFORE_METHOD，则在当前方法之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(methodMode = BEFORE_METHOD)</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessWhichRequiresFreshAppCtx</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// some logic that requires a new Spring container </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>当在一个方法中声明并将方法模式设为AFTER_METHOD(也就是说，默认的方法模式），则在当前方法之后。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessWhichDirtiesAppCtx</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// some logic that results in the Spring container being dirtied </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果<a target="_blank" rel="noopener" href="https://github.com/DirtiesContext">@DirtiesContext</a>被用于上下文被配置为通过<a target="_blank" rel="noopener" href="https://github.com/ContextHierarchy">@ContextHierarchy</a>定义的上下文层次中的一部分的测试中，则hierarchyMode标志可用于控制如何声明上下文缓存。默认将使用一个穷举算法用于清除包括不仅当前层次而且与当前测试拥有共同祖先的其它上下文层次的缓存。所有在拥有共同祖先上下文的子层次的应用程序上下文都会从上下文中被移除并关闭。如果穷举算法对于特定的使用场景显得有点威力过猛，那么你可以指定一个更简单的当前层算法来代替，如下所。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextHierarchy(&#123; </span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/parent-config.xml&quot;), </span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/child-config.xml&quot;) </span></span><br><span class="line"><span class="meta">&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedTests</span> <span class="keyword">extends</span> <span class="title class_">BaseTests</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@DirtiesContext(hierarchyMode = CURRENT_LEVEL)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// some logic that results in the child context being dirtied </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>参阅DirtiesContext.HierarchyMode帮助文档以获得穷举和当前层算法更详细的了解。</p>
<h4 id="TestExecutionListeners"><a href="#TestExecutionListeners" class="headerlink" title="@TestExecutionListeners"></a><a target="_blank" rel="noopener" href="https://github.com/TestExecutionListeners">@TestExecutionListeners</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/TestExecutionListeners">@TestExecutionListeners</a>定义了一个类级别的元数据，用于配置需要用TestContextManager进行注册的TestExecutionListener实现。通常，@TestExecutionListeners与@ContextConfiguration一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> </span><br><span class="line"><span class="meta">@TestExecutionListeners(&#123;CustomTestExecutionListener.class, AnotherTestExecutionListener.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomTestExecutionListenerTests</span> &#123; </span><br><span class="line"><span class="comment">// class body... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/TestExecutionListeners">@TestExecutionListeners</a>默认支持继承监听器。参阅帮助文档获得示例和更详细的了解。</p>
<h4 id="Commit"><a href="#Commit" class="headerlink" title="@Commit"></a><a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a>指定事务性的测试方法在测试方法执行完成后对事务进行提交。<a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a>可以用作<a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a>(false)的直接替代，以更好的传达代码的意图。和<a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a>一样，<a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a>可以在类层次或者方法层级声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Commit</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessWithoutRollback</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Rollback"><a href="#Rollback" class="headerlink" title="@Rollback"></a><a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a>指明当测试方法执行完毕的时候是否对事务性方法中的事务进行回滚。如果为true,则进行回滚；否则，则提交（请参加<a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a>）。在Spring TestContext框架中，集成测试默认的Rollback语义为true，即使你不显示的指定它。</p>
<p>当被声明为方法级别的注解，则<a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a>为特定的方法指定回滚语义，并覆盖类级别的<a target="_blank" rel="noopener" href="https://github.com/Rollback">@Rollback</a>和<a target="_blank" rel="noopener" href="https://github.com/Commit">@Commit</a>语义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rollback(false)</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcessWithoutRollback</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// … </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="BeforeTransaction"><a href="#BeforeTransaction" class="headerlink" title="@BeforeTransaction"></a><a target="_blank" rel="noopener" href="https://github.com/BeforeTransaction">@BeforeTransaction</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/BeforeTransaction">@BeforeTransaction</a>指明通过Spring的<a target="_blank" rel="noopener" href="https://github.com/Transactional">@Transactional</a>注解配置为需要在事务中执行的测试方法在事务开始之前先执行注解的void方法。从Spring框架4.3版本起，<a target="_blank" rel="noopener" href="https://github.com/BeforeTransaction">@BeforeTransaction</a>方法不再需要为public并可能被声明为基于Java8的接口的默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeTransaction</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">beforeTransaction</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// logic to be executed before a transaction is started </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="AfterTransaction"><a href="#AfterTransaction" class="headerlink" title="@AfterTransaction"></a><a target="_blank" rel="noopener" href="https://github.com/AfterTransaction">@AfterTransaction</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/AfterTransaction">@AfterTransaction</a>指明通过Spring的<a target="_blank" rel="noopener" href="https://github.com/Transactional">@Transactional</a>注解配置为需要在事务中执行的测试方法在事务结束之后执行注解的void方法。从Spring框架4.3版本起，<a target="_blank" rel="noopener" href="https://github.com/AfterTransaction">@AfterTransaction</a>方法不再需要为public并可能被声明为基于Java8的接口的默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterTransaction</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterTransaction</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="comment">// logic to be executed after a transaction has ended </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Sql"><a href="#Sql" class="headerlink" title="@Sql"></a><a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a>用于注解测试类或者测试方法，以让在集成测试过程中配置的SQL脚本能够在给定的的数据库中得到执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@Sql(&#123;&quot;/test-schema.sql&quot;, &quot;/test-user-data.sql&quot;&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123; </span><br><span class="line"><span class="comment">// execute code that relies on the test schema and test data </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>请参阅<a target="_blank" rel="noopener" href="http://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#testcontext-executing-sql-declaratively">通过@sql声明执行的SQL脚本</a>作进一步了解。</p>
<h4 id="SqlConfig"><a href="#SqlConfig" class="headerlink" title="@SqlConfig"></a><a target="_blank" rel="noopener" href="https://github.com/SqlConfig">@SqlConfig</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/SqlConfig">@SqlConfig</a>定义了用于决定如何解析和执行通过<a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a>注解配置的SQL脚本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@Sql( </span></span><br><span class="line"><span class="meta">scripts = &quot;/test-user-data.sql&quot;, </span></span><br><span class="line"><span class="meta">config = @SqlConfig(commentPrefix = &quot;&quot;, separator = &quot;@@&quot;) </span></span><br><span class="line"><span class="meta">)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123; </span><br><span class="line"><span class="comment">// execute code that relies on the test data </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="SqlGroup"><a href="#SqlGroup" class="headerlink" title="@SqlGroup"></a><a target="_blank" rel="noopener" href="https://github.com/SqlGroup">@SqlGroup</a></h4><p><a target="_blank" rel="noopener" href="https://github.com/SqlGroup">@SqlGroup</a>是一个用于聚合几个<a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a>注解的容器注解。<a target="_blank" rel="noopener" href="https://github.com/SqlGroup">@SqlGroup</a>可以直接使用，通过声明几个嵌套的<a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a>注解，也可以与Java8的可重复注解支持协同使用，即简单地在同一个类或方法上声明几个<a target="_blank" rel="noopener" href="https://github.com/Sql">@Sql</a>注解，隐式地产生这个容器注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@SqlGroup(&#123; </span></span><br><span class="line"><span class="meta"> @Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;&quot;)), </span></span><br><span class="line"><span class="meta"> @Sql(&quot;/test-user-data.sql&quot;) </span></span><br><span class="line"><span class="meta">)</span>&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123; </span><br><span class="line"> <span class="comment">// execute code that uses the test schema and test data </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="11-4-2-标准注解支持"><a href="#11-4-2-标准注解支持" class="headerlink" title="11.4.2 标准注解支持"></a>11.4.2 标准注解支持</h3><p>以下注解为Spring TestContext 框架所有的配置提供标准语义支持。注意这些注解不仅限于测试，可以用在Spring框架的任意地方。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Autowired">@Autowired</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Qualifier">@Qualifier</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Resource">@Resource</a>(javax.annotation)如果<em>JSR-250</em>存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/ManagedBean">@ManagedBean</a>(javax.annotation)如果<em>JSR-250</em>存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Inject">@Inject</a>(javax.inject)如果<em>JSR-330</em>存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Named">@Named</a>(javax.inject)如果<em>JSR-330</em>存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/PersistenceContext">@PersistenceContext</a>(javax.persistence)如果JPA存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/PersistenceUnit">@PersistenceUnit</a>(javax.persistence)如果JPA存在</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Required">@Required</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Transactional">@Transactional</a></li>
</ul>
<blockquote>
<p>在Spring TestContext 框架中，<a target="_blank" rel="noopener" href="https://github.com/PostConstruct">@PostConstruct</a> 和 <a target="_blank" rel="noopener" href="https://github.com/PreDestroy">@PreDestroy</a> 可以通过标准语义在配置于应用程序上下文的任意应用程序组件中使用; 但是, 这些生命周期注解在实际测试类中只有很有限的作用。如果一个测试类的方法被注解为<a target="_blank" rel="noopener" href="https://github.com/PostConstruct">@PostConstruct</a>，这个方法将在test框架中的任何before方法（也就是被JUnit中的<a target="_blank" rel="noopener" href="https://github.com/Before">@Before</a>注解方法）调用之前被执行, 这个规则将被应用于测试类的每个方法。另一方面，如果一个测试类的方法被注解为 <a target="_blank" rel="noopener" href="https://github.com/PreDestroy">@PreDestroy</a>，这个方法将永远不会被执行。因为建议在测试类中使用test 框架的测试生命周期回调来代替使用<a target="_blank" rel="noopener" href="https://github.com/PostConstruct">@PostConstruct</a> and <a target="_blank" rel="noopener" href="https://github.com/PreDestroy">@PreDestroy</a>。</p>
</blockquote>
<h2 id="spring-对于数据的访问"><a href="#spring-对于数据的访问" class="headerlink" title="spring 对于数据的访问"></a>spring 对于数据的访问</h2><h3 id="DAO支持"><a href="#DAO支持" class="headerlink" title="DAO支持"></a>DAO支持</h3><p>在Spring中数据访问对象(DAO)旨在使JDBC,Hibernate，JPA或JDO等数据访问技术有一致的处理方法，并且方法尽可能简单。<br>这样就可以很容易地切换上述持久化技术，并且切换过程无需担心每种技术的特有异常。</p>
<p>使用<a target="_blank" rel="noopener" href="https://github.com/Repository">@Repository</a>注解是数据访问对象（DAOs）或库能提供异常转换的最好方式，这个注解还允许组件扫描，查找并配置你的 DAOs 和库，并且不需要为它们提供 XML 配置文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123; </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>任何DAO或库实现都需要访问持久的源，依赖于持久化技术的使用；例如：一个基于JDBC的库需要访问一个JDBC DataSource，一个基于JPA的库需要访问一个 EntityManager，最简单的方式就是使用 <a target="_blank" rel="noopener" href="https://github.com/Autowired">@Autowired</a>, <a target="_blank" rel="noopener" href="https://github.com/Inject">@Inject</a>, <a target="_blank" rel="noopener" href="https://github.com/Resource">@Resource</a> 或<a target="_blank" rel="noopener" href="https://github.com/PersistenceContext">@PersistenceContext</a> 这些注解中的一个完成资源的依赖注入，这是一个JPA库的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@PersistenceContext</span> </span><br><span class="line"><span class="keyword">private</span> EntityManager entityManager; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果你使用传统的Hibernate API，你可以注入SessionFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HibernateMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SessionFactory sessionFactory; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSessionFactory</span><span class="params">(SessionFactory sessionFactory)</span> &#123; </span><br><span class="line"><span class="built_in">this</span>.sessionFactory = sessionFactory; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>最后一个例子我们将在这里展示典型的JDBC支持，你将会在初始化方法中注入 DataSource ，在初始化方法中，你将使用这个DataSource创建一个JdbcTemplate 和其他与SimpleJdbcCall相似的数据访问支持类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line"><span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="对JDBC的支持"><a href="#对JDBC的支持" class="headerlink" title="对JDBC的支持"></a>对JDBC的支持</h3><p>表格很清楚的列举了Spring框架针对JDBC操作做的一些抽象和封装。里面区分了哪些操作Spring已经帮你做好了、哪些操作是应用开发者需要自己负责的.</p>
<p>Spring JDBC – 框架和应用开发者各自分工</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">Spring</th>
<th align="left">开发者</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义连接参数</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">打开连接</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">指定SQL语句</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">声明参数和提供参数值</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">准备和执行语句</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">返回结果的迭代（如果有）</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">具体操作每个迭代</td>
<td align="left"></td>
<td align="left">X</td>
</tr>
<tr>
<td align="left">异常处理</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">事务处理</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">关闭连接、语句和结果集</td>
<td align="left">X</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>一句话、Spring帮你屏蔽了很多JDBC底层繁琐的API操作、让你更方便的开发</p>
<p>JdbcTemplate 是经典的Spring JDBC访问方式，也是最常用的。这是“最基础”的方式、其他所有方式都是在 JdbcTemplate的基础之上封装的。</p>
<p><strong>JdbcTemplate 使用示例</strong></p>
<p>这一节提供了JdbcTemplate类的一些使用例子。这些例子没有囊括JdbcTemplate可提供的所有功能；全部功能和用法请详见相关的javadocs.</p>
<p><strong>查询 (SELECT)</strong></p>
<p>下面是一个简单的例子、用于获取关系表里面的行数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rowCount</span> <span class="operator">=</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject(<span class="string">&quot;select count(*) from t_actor&quot;</span>, Integer.class); </span><br></pre></td></tr></table></figure>

<p>使用绑定变量的简单查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">countOfActorsNamedJoe</span> <span class="operator">=</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject( </span><br><span class="line">        <span class="string">&quot;select count(*) from t_actor where first_name = ?&quot;</span>, Integer.class, <span class="string">&quot;Joe&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>String查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lastName</span> <span class="operator">=</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject( </span><br><span class="line">        <span class="string">&quot;select last_name from t_actor where id = ?&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1212L</span>&#125;, String.class); </span><br></pre></td></tr></table></figure>

<p>查询和填充领域模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="built_in">this</span>.jdbcTemplate.queryForObject( </span><br><span class="line">        <span class="string">&quot;select first_name, last_name from t_actor where id = ?&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1212L</span>&#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Actor&gt;() &#123; </span><br><span class="line">            <span class="keyword">public</span> Actor <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123; </span><br><span class="line">                <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>(); </span><br><span class="line">                actor.setFirstName(rs.getString(<span class="string">&quot;first_name&quot;</span>)); </span><br><span class="line">                actor.setLastName(rs.getString(<span class="string">&quot;last_name&quot;</span>)); </span><br><span class="line">                <span class="keyword">return</span> actor; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br></pre></td></tr></table></figure>

<p>查询和填充多个领域对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Actor&gt; actors = <span class="built_in">this</span>.jdbcTemplate.query( </span><br><span class="line">        <span class="string">&quot;select first_name, last_name from t_actor&quot;</span>, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;Actor&gt;() &#123; </span><br><span class="line">            <span class="keyword">public</span> Actor <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123; </span><br><span class="line">                <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>(); </span><br><span class="line">                actor.setFirstName(rs.getString(<span class="string">&quot;first_name&quot;</span>)); </span><br><span class="line">                actor.setLastName(rs.getString(<span class="string">&quot;last_name&quot;</span>)); </span><br><span class="line">                <span class="keyword">return</span> actor; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;); </span><br></pre></td></tr></table></figure>

<p>如果上面的两段代码实际存在于相同的应用中，建议把RowMapper匿名类中重复的代码抽取到单独的类中（通常是一个静态类），方便被DAO方法引用。例如，上面的代码例子更好的写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Actor&gt; <span class="title function_">findAllActors</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.jdbcTemplate.query( <span class="string">&quot;select first_name, last_name from t_actor&quot;</span>, <span class="keyword">new</span> <span class="title class_">ActorMapper</span>()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ActorMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Actor&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Actor <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException &#123; </span><br><span class="line">        <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Actor</span>(); </span><br><span class="line">        actor.setFirstName(rs.getString(<span class="string">&quot;first_name&quot;</span>)); </span><br><span class="line">        actor.setLastName(rs.getString(<span class="string">&quot;last_name&quot;</span>)); </span><br><span class="line">        <span class="keyword">return</span> actor; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>使用jdbcTemplate实现增删改</strong></p>
<p>你可以使用update(..)方法实现插入，更新和删除操作。参数值可以通过可变参数或者封装在对象内传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.jdbcTemplate.update( </span><br><span class="line">        <span class="string">&quot;insert into t_actor (first_name, last_name) values (?, ?)&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Leonor&quot;</span>, <span class="string">&quot;Watling&quot;</span>); </span><br><span class="line"><span class="built_in">this</span>.jdbcTemplate.update( </span><br><span class="line">        <span class="string">&quot;update t_actor set last_name = ? where id = ?&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Banjo&quot;</span>, <span class="number">5276L</span>); </span><br><span class="line"><span class="built_in">this</span>.jdbcTemplate.update( </span><br><span class="line">        <span class="string">&quot;delete from actor where id = ?&quot;</span>, </span><br><span class="line">        Long.valueOf(actorId)); </span><br></pre></td></tr></table></figure>

<p><strong>其他jdbcTemplate操作</strong></p>
<p>你可以使用execute(..)方法执行任何SQL，甚至是DDL语句。这个方法可以传入回调接口、绑定可变参数数组等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.jdbcTemplate.execute(<span class="string">&quot;create table mytable (id integer, name varchar(100))&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>下面的例子调用一段简单的存储过程。更复杂的存储过程支持文档后面会有描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.jdbcTemplate.update( </span><br><span class="line">        <span class="string">&quot;call SUPPORT.REFRESH_ACTORS_SUMMARY(?)&quot;</span>, </span><br><span class="line">        Long.valueOf(unionId)); </span><br></pre></td></tr></table></figure>

<p><strong>JdbcTemplate 最佳实践</strong><br>JdbcTemplate实例一旦配置之后是线程安全的。这点很重要因为这样你就能够配置JdbcTemplate的单例，然后安全的将其注入到多个DAO中（或者repositories）。JdbcTemplate是有状态的，内部存在对DataSource的引用，但是这种状态不是会话状态。</p>
<p>使用JdbcTemplate类的常用做法是在你的Spring配置文件里配置好一个DataSource，然后将其依赖注入进你的DAO类中（NamedParameterJdbcTemplate也是如此）。JdbcTemplate在DataSource的Setter方法中被创建。就像如下DAO类的写法一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcCorporateEventDao</span> <span class="keyword">implements</span> <span class="title class_">CorporateEventDao</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// JDBC-backed implementations of the methods on the CorporateEventDao follow... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>相关的配置是这样的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;corporateEventDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.JdbcCorporateEventDao&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>另一种替代显式配置的方式是使用component-scanning和注解注入。在这个场景下需要添加<a target="_blank" rel="noopener" href="https://github.com/Repository">@Repository</a>注解（添加这个注解可以被component-scanning扫描到），同时在DataSource的Setter方法上添加<a target="_blank" rel="noopener" href="https://github.com/Autowired">@Autowired</a>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcCorporateEventDao</span> <span class="keyword">implements</span> <span class="title class_">CorporateEventDao</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// JDBC-backed implementations of the methods on the CorporateEventDao follow... </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>相关的XML配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Scans within the base package of the application for @Component classes to configure as beans --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.springframework.docs.test&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>如果你使用Spring的JdbcDaoSupport类，许多JDBC相关的DAO类都从该类继承过来，这个时候相关子类需要继承JdbcDaoSupport类的setDataSource方法。当然你也可以选择不从这个类继承，JdbcDaoSupport本身只是提供一些便利性。</p>
<p>无论你选择上面提到的哪种初始方式，当你在执行SQL语句时一般都不需要重新创建JdbcTemplate 实例。JdbcTemplate一旦被配置后其实例都是线程安全的。当你的应用需要访问多个数据库时你可能也需要多个JdbcTemplate实例，相应的也需要多个DataSources，同时对应多个JdbcTemplates配置。</p>
<h3 id="DataSouce"><a href="#DataSouce" class="headerlink" title="DataSouce"></a>DataSouce</h3><p>Spring用DataSource来保持与数据库的连接。DataSource是JDBC规范的一部分同时是一种通用的连接工厂。它使得框架或者容器对应用代码屏蔽连接池或者事务管理等底层逻辑。作为开发者，你无需知道连接数据库的底层逻辑；这只是创建datasource的管理员该负责的模块。在开发测试过程中你可能需要同时扮演双重角色，但最终上线时你不需要知道生产数据源是如何配置的。</p>
<p>当使用Spring JDBC时，你可以通过JNDI获取数据库数据源、也可以利用第三方依赖包的连接池实现来配置。比较受欢迎的三方库有Apache Jakarta Commons DBCP 和 C3P0。在Spring产品内，有自己的数据源连接实现，但仅仅用于测试目的，同时并没有使用到连接池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DriverManagerDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(); </span><br><span class="line">dataSource.setDriverClassName(<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span>); </span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc:hsqldb:hsql://localhost:&quot;</span>); </span><br><span class="line">dataSource.setUsername(<span class="string">&quot;sa&quot;</span>); </span><br><span class="line">dataSource.setPassword(<span class="string">&quot;&quot;</span>); </span><br></pre></td></tr></table></figure>

<p>接下来是相关的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>

<p>下面的例子展示的是DBCP和C3P0的基础连接配置。如果需要连接更多的连接池选项、请查看各自连接池实现的具体产品文档</p>
<p>DBCP配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>

<p>C3P0配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>



<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>大多数JDBC驱动在针对同一SQL语句做批处理时能够获得更好的性能。批量更新操作可以节省数据库的来回传输次数。</p>
<p><strong>使用JdbcTemplate来进行基础的批量操作</strong></p>
<p>通过JdbcTemplate 实现批处理需要实现特定接口的两个方法，BatchPreparedStatementSetter，并且将其作为第二个参数传入到batchUpdate方法调用中。使用getBatchSize提供当前批量操作的大小。使用setValues方法设置语句的Value参数。这个方法会按getBatchSize设置中指定的调用次数。下面的例子中通过传入列表来批量更新actor表。在这个例子中整个列表使用了批量操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcActorDao</span> <span class="keyword">implements</span> <span class="title class_">ActorDao</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] batchUpdate(<span class="keyword">final</span> List&lt;Actor&gt; actors) &#123; </span><br><span class="line">        <span class="type">int</span>[] updateCounts = jdbcTemplate.batchUpdate(<span class="string">&quot;update t_actor set first_name = ?, &quot;</span> + </span><br><span class="line">                <span class="string">&quot;last_name = ? where id = ?&quot;</span>, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BatchPreparedStatementSetter</span>() &#123; </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValues</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123; </span><br><span class="line">                        ps.setString(<span class="number">1</span>, actors.get(i).getFirstName()); </span><br><span class="line">                        ps.setString(<span class="number">2</span>, actors.get(i).getLastName()); </span><br><span class="line">                        ps.setLong(<span class="number">3</span>, actors.get(i).getId().longValue()); </span><br><span class="line">                    &#125; </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBatchSize</span><span class="params">()</span> &#123; </span><br><span class="line">                        <span class="keyword">return</span> actors.size(); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;); </span><br><span class="line">        <span class="keyword">return</span> updateCounts; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional methods </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果你需要处理批量更新或者从文件中批量读取，你可能需要确定一个合适的批处理大小，但是最后一次批处理可能达不到这个大小。在这种场景下你可以使用InterruptibleBatchPreparedStatementSetter接口，允许在输入流耗尽之后终止批处理，isBatchExhausted方法使得你可以指定批处理结束时间。</p>
<p> <strong>对象列表的批量处理</strong></p>
<p>JdbcTemplate和NamedParameterJdbcTemplate都提供了批量更新的替代方案。这个时候不是实现一个特定的批量接口，而是在调用时传入所有的值列表。框架会循环访问这些值并且使用内部的SQL语句setter方法。你是否已声明参数对应API是不一样的。针对已声明参数你需要传入qlParameterSource数组，每项对应单次的批量操作。你可以使用SqlParameterSource.createBatch方法来创建这个数组，传入JavaBean数组或是包含参数值的Map数组。</p>
<p>下面是一个使用已声明参数的批量更新例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcActorDao</span> <span class="keyword">implements</span> <span class="title class_">ActorDao</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> NamedParameterTemplate namedParameterJdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.namedParameterJdbcTemplate = <span class="keyword">new</span> <span class="title class_">NamedParameterJdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] batchUpdate(<span class="keyword">final</span> List&lt;Actor&gt; actors) &#123; </span><br><span class="line">        SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray()); </span><br><span class="line">        <span class="type">int</span>[] updateCounts = namedParameterJdbcTemplate.batchUpdate( </span><br><span class="line">                <span class="string">&quot;update t_actor set first_name = :firstName, last_name = :lastName where id = :id&quot;</span>, </span><br><span class="line">                batch); </span><br><span class="line">        <span class="keyword">return</span> updateCounts; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional methods </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>对于使用“？”占位符的SQL语句，你需要传入带有更新值的对象数组。对象数组每一项对应SQL语句中的一个占位符，并且传入顺序需要和SQL语句中定义的顺序保持一致。</p>
<p>下面是使用经典JDBC“？”占位符的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcActorDao</span> <span class="keyword">implements</span> <span class="title class_">ActorDao</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] batchUpdate(<span class="keyword">final</span> List&lt;Actor&gt; actors) &#123; </span><br><span class="line">        List&lt;Object[]&gt; batch = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object[]&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (Actor actor : actors) &#123; </span><br><span class="line">            Object[] values = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; </span><br><span class="line">                    actor.getFirstName(), </span><br><span class="line">                    actor.getLastName(), </span><br><span class="line">                    actor.getId()&#125;; </span><br><span class="line">            batch.add(values); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span>[] updateCounts = jdbcTemplate.batchUpdate( </span><br><span class="line">                <span class="string">&quot;update t_actor set first_name = ?, last_name = ? where id = ?&quot;</span>, </span><br><span class="line">                batch); </span><br><span class="line">        <span class="keyword">return</span> updateCounts; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional methods </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面所有的批量更新方法都返回一个数组，包含具体成功的行数。这个计数是由JDBC驱动返回的。如果拿不到计数。JDBC驱动会返回-2。</p>
<p><strong>多个批处理操作</strong><br>上面最后一个例子更新的批处理数量太大，最好能再分割成更小的块。最简单的方式就是你多次调用batchUpdate来实现，但是可以有更优的方法。要使用这个方法除了SQL语句，还需要传入参数集合对象，每次Batch的更新数和一个ParameterizedPreparedStatementSetter去设置预编译SQL语句的参数值。框架会循环调用提供的值并且将更新操作切割成指定数量的小批次。</p>
<p>下面的例子设置了更新批次数量为100的批量更新操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcActorDao</span> <span class="keyword">implements</span> <span class="title class_">ActorDao</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataSource</span><span class="params">(DataSource dataSource)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] batchUpdate(<span class="keyword">final</span> Collection&lt;Actor&gt; actors) &#123; </span><br><span class="line">        <span class="type">int</span>[][] updateCounts = jdbcTemplate.batchUpdate( </span><br><span class="line">                <span class="string">&quot;update t_actor set first_name = ?, last_name = ? where id = ?&quot;</span>, </span><br><span class="line">                actors, </span><br><span class="line">                <span class="number">100</span>, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ParameterizedPreparedStatementSetter</span>&lt;Actor&gt;() &#123; </span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValues</span><span class="params">(PreparedStatement ps, Actor argument)</span> <span class="keyword">throws</span> SQLException &#123; </span><br><span class="line">                        ps.setString(<span class="number">1</span>, argument.getFirstName()); </span><br><span class="line">                        ps.setString(<span class="number">2</span>, argument.getLastName()); </span><br><span class="line">                        ps.setLong(<span class="number">3</span>, argument.getId().longValue()); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;); </span><br><span class="line">        <span class="keyword">return</span> updateCounts; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional methods </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这个调用的批量更新方法返回一个包含int数组的二维数组，包含每次更新生效的行数。第一层数组长度代表批处理执行的数量，第二层数组长度代表每个批处理生效的更新数。每个批处理的更新数必须和所有批处理的大小匹配，除非是最后一次批处理可能小于这个数，具体依赖于更新对象的总数。每次更新语句生效的更新数由JDBC驱动提供。如果更新数量不存在，JDBC驱动会返回-2</p>
<h3 id="spring-集成ORM"><a href="#spring-集成ORM" class="headerlink" title="spring 集成ORM"></a>spring 集成ORM</h3><p>Spring框架在实现资源管理、数据访问对象（DAO）层，和事务策略等方面，支持对Java持久化API（JPA）以及原生Hibernate的集成。以Hibernate举例来说，Spring有非常赞的IoC功能，可以解决许多典型的Hibernate配置和集成问题。开发者可以通过依赖注入来配置O-R（对象关系）映射组件支持的特性。Hibernate的这些特性可以参与Spring的资源和事务管理，并且符合Spring的通用事务和DAO层的异常体系。因此，Spring团队推荐开发者使用Spring集成的方式来开发DAO层，而不是使用原生的Hibernate或者JPA的API。</p>
<h3 id="spring-集成-OXM"><a href="#spring-集成-OXM" class="headerlink" title="spring 集成 OXM"></a>spring 集成 OXM</h3><p>Spring对于 对象&#x2F;XML 映射的支持。对象&#x2F;XML 映射，或 O&#x2F;X 映射，是指将 XML 文档与 XML 文档对象进行互相转换的操作。这一转换操作也被称作 XML 编组，或 XML 序列化。在本章中，这几个概念都指的是同一个东西。<br>在O&#x2F;X 映射中，将一组对象序列化为 XML 的操作是由一个编组器负责的。与之相对，一个反编组器则被用于将 XML 反序列化为一组对象。而这些操作中的 XML 文件来源可能是一份 DOM 文档，一个输入&#x2F;输出流，或一个 SAX 管理器。</p>
<p>Spring 的 O&#x2F;X 映射通过两个全局的接口来执行操作：Marshaller 和 Unmarshaller。这一结构让用户可以在几乎不需要修改编组操作类的前提下，轻易地在不同的 O&#x2F;X 映射框架之间进行切换。这一结构的另一优势是可以以一种非侵入的方式在代码中混合多种 XML 编组方法（比如有一些编组实现使用 JAXB，而另一些则使用 Castor），从而将各种技术的优势在应用中加以综合利用。</p>
<h2 id="web-集成"><a href="#web-集成" class="headerlink" title="web 集成"></a>web 集成</h2><p>过去的web框架正在被淘汰，struts2也销声匿迹</p>
<p>相对较流行的 spring自己的 springweb（SpringMVC） 也正在被 spring-boot 和大前端技术（全栈技术）所追赶，后端项目越来越倾向于提供数据接口服务。 spring-cloud、 spring-boot 如火如荼。</p>
<h2 id="Cache-在spring中的使用"><a href="#Cache-在spring中的使用" class="headerlink" title="Cache 在spring中的使用"></a>Cache 在spring中的使用</h2><p><a target="_blank" rel="noopener" href="http://ddkk.com/zhuanlan/j2ee/spring/1/119.html">文档1</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xeons.cn">Calico</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xeons.cn/2023/03/03/spring-guide/">http://xeons.cn/2023/03/03/spring-guide/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xeons.cn" target="_blank">Calico's Space</a>！</span></div></div><script>function setClipboardText(event){
    let clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) { return; }
    event.preventDefault();
    let text = window.getSelection().toString();
    if (text) {
        event.preventDefault();
        var copyright = "\n\n---\n著作权归 Calico 所有 \n原文链接: http://xeons.cn/2023/03/03/spring-guide/";
        clipboardData.setData('text/plain', text + copyright);
    }
};
var contents = document.getElementsByClassName("post");
contents[0].addEventListener('copy',function(e){
    setClipboardText(e);
});</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"><div class="social-share" data-image="/2023/03/03/spring-guide/spring.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wxpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wxpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/03/spring-mvc-guide/" title="springMVC 文档手册"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/03/03/spring-mvc-guide/spring.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">springMVC 文档手册</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/03/data-structure-and-algorithm/" title="常见数据结构和算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见数据结构和算法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/03/spring-mvc-guide/" title="springMVC 文档手册"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/03/03/spring-mvc-guide/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-03</div><div class="title">springMVC 文档手册</div></div></a></div><div><a href="/2023/03/04/spring-web-source-analyse/" title="springMVC 源码分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/03/04/spring-web-source-analyse/spring.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">springMVC 源码分析</div></div></a></div><div><a href="/2023/01/03/data-structure-and-algorithm/" title="常见数据结构和算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-03</div><div class="title">常见数据结构和算法</div></div></a></div><div><a href="/2023/05/05/es-basic/" title="ElasticSearch 介绍"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/05/es-basic/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-05</div><div class="title">ElasticSearch 介绍</div></div></a></div><div><a href="/2023/06/03/hashmap-sourcecode-analyes/" title="HashMap 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-03</div><div class="title">HashMap 源码解析</div></div></a></div><div><a href="/2023/06/03/java-basic/" title="Java 基础试题1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/05/13/8KXvfwkxihBbtGM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-03</div><div class="title">Java 基础试题1</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTczMi8zNjE5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Calico</div><div class="author-info__description">It's my blog，Record everything！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xeonsuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xeonsuo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://weibo.com/xeons" target="_blank" title="微博"><i class="fab fa-weibo" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xeon511@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">python、aiAgent 进化中...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">spring 框架介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-IoC%E5%92%8Cbeans%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">Spring IoC和beans的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">容器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEbean%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.</span> <span class="toc-text">配置bean的元数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">容器实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">使用@Bean注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#profiles-%E5%AE%9A%E4%B9%89%EF%BC%88%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">profiles 定义（不同环境）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%BA%90%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.6.</span> <span class="toc-text">属性源抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-ApplicationContext-%E7%9A%84%E9%A2%9D%E5%A4%96%E5%8A%9F%E8%83%BD"><span class="toc-number">2.7.</span> <span class="toc-text">容器(ApplicationContext)的额外功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.7.1.</span> <span class="toc-text">标准和自定义事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EbeanFactory"><span class="toc-number">2.8.</span> <span class="toc-text">关于beanFactory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E7%9A%84%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-Resource"><span class="toc-number">3.</span> <span class="toc-text">spring 的资源管理(Resource)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.0.1.</span> <span class="toc-text">Resource 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ResourceLoader-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.0.2.</span> <span class="toc-text">ResourceLoader 接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80%EF%BC%88SpEL%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">spring表达式语言（SpEL）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E6%A1%86%E6%9E%B6%E4%B8%8B%E7%9A%84Test"><span class="toc-number">5.</span> <span class="toc-text">spring框架下的Test</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">Spring测试注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BootstrapWith"><span class="toc-number">5.1.1.</span> <span class="toc-text">@BootstrapWith</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ContextConfiguration"><span class="toc-number">5.1.2.</span> <span class="toc-text">@ContextConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebAppConfiguration"><span class="toc-number">5.1.3.</span> <span class="toc-text">@WebAppConfiguration</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ContextHierarchy"><span class="toc-number">5.1.4.</span> <span class="toc-text">@ContextHierarchy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveProfiles"><span class="toc-number">5.1.5.</span> <span class="toc-text">@ActiveProfiles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TestPropertySource"><span class="toc-number">5.1.6.</span> <span class="toc-text">@TestPropertySource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DirtiesContext"><span class="toc-number">5.1.7.</span> <span class="toc-text">@DirtiesContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TestExecutionListeners"><span class="toc-number">5.1.8.</span> <span class="toc-text">@TestExecutionListeners</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Commit"><span class="toc-number">5.1.9.</span> <span class="toc-text">@Commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rollback"><span class="toc-number">5.1.10.</span> <span class="toc-text">@Rollback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeforeTransaction"><span class="toc-number">5.1.11.</span> <span class="toc-text">@BeforeTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AfterTransaction"><span class="toc-number">5.1.12.</span> <span class="toc-text">@AfterTransaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sql"><span class="toc-number">5.1.13.</span> <span class="toc-text">@Sql</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SqlConfig"><span class="toc-number">5.1.14.</span> <span class="toc-text">@SqlConfig</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SqlGroup"><span class="toc-number">5.1.15.</span> <span class="toc-text">@SqlGroup</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-2-%E6%A0%87%E5%87%86%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81"><span class="toc-number">5.2.</span> <span class="toc-text">11.4.2 标准注解支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E5%AF%B9%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">6.</span> <span class="toc-text">spring 对于数据的访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%E6%94%AF%E6%8C%81"><span class="toc-number">6.1.</span> <span class="toc-text">DAO支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9JDBC%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">6.2.</span> <span class="toc-text">对JDBC的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataSouce"><span class="toc-number">6.3.</span> <span class="toc-text">DataSouce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">批量处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E9%9B%86%E6%88%90ORM"><span class="toc-number">6.5.</span> <span class="toc-text">spring 集成ORM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E9%9B%86%E6%88%90-OXM"><span class="toc-number">6.6.</span> <span class="toc-text">spring 集成 OXM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web-%E9%9B%86%E6%88%90"><span class="toc-number">7.</span> <span class="toc-text">web 集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-%E5%9C%A8spring%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">Cache 在spring中的使用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/vue3-quick/" title="vue3快速上手（尚硅谷b站）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/15/vue3-quick/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue3快速上手（尚硅谷b站）"/></a><div class="content"><a class="title" href="/2023/08/15/vue3-quick/" title="vue3快速上手（尚硅谷b站）">vue3快速上手（尚硅谷b站）</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/06/redis-basic/" title="redis 基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/06/redis-basic/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis 基础"/></a><div class="content"><a class="title" href="/2023/08/06/redis-basic/" title="redis 基础">redis 基础</a><time datetime="2023-08-05T16:00:00.000Z" title="发表于 2023-08-06 00:00:00">2023-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/transactions-mysql/" title="mysql事务原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql事务原理"/></a><div class="content"><a class="title" href="/2023/08/05/transactions-mysql/" title="mysql事务原理">mysql事务原理</a><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/transactions-basic/" title="事务详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-basic/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="事务详解"/></a><div class="content"><a class="title" href="/2023/08/05/transactions-basic/" title="事务详解">事务详解</a><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/java-memory-optimize/" title="JVM内存调优"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/06/23/java-memory-optimize/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存调优"/></a><div class="content"><a class="title" href="/2023/06/23/java-memory-optimize/" title="JVM内存调优">JVM内存调优</a><time datetime="2023-06-22T16:00:00.000Z" title="发表于 2023-06-23 00:00:00">2023-06-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: none"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Calico</div><div class="footer_custom_text"><a href="icp"><span>Create By hexo,butterfly</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>