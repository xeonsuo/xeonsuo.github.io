<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mysql事务原理 | Calico's Space</title><meta name="author" content="Calico"><meta name="copyright" content="Calico"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Redo LogMySQL 中事务的原子性和持久性是由 Redo Log 实现的，它确保 MySQL 事务提交后，事务所涉及的所有操作要么全部执行成功，要么全部执行失败 1.Redo Log 基本概念Redo Log 也被称作重做日志，它是在 InnoDB 存储引擎中产生的，用来保证事务的原子性和持久性。Redo Log 主要记录的是物理日志，也就是对磁盘上的数据进行的修改操作。Redo Lo">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql事务原理">
<meta property="og:url" content="http://xeons.cn/2023/08/05/transactions-mysql/index.html">
<meta property="og:site_name" content="Calico&#39;s Space">
<meta property="og:description" content="一、Redo LogMySQL 中事务的原子性和持久性是由 Redo Log 实现的，它确保 MySQL 事务提交后，事务所涉及的所有操作要么全部执行成功，要么全部执行失败 1.Redo Log 基本概念Redo Log 也被称作重做日志，它是在 InnoDB 存储引擎中产生的，用来保证事务的原子性和持久性。Redo Log 主要记录的是物理日志，也就是对磁盘上的数据进行的修改操作。Redo Lo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xeons.cn/2023/08/05/transactions-mysql/logo.jpg">
<meta property="article:published_time" content="2023-08-04T16:00:00.000Z">
<meta property="article:author" content="Calico">
<meta property="article:tag" content="java">
<meta property="article:tag" content="分布式事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xeons.cn/2023/08/05/transactions-mysql/logo.jpg"><link rel="shortcut icon" href="/images/calico-ss.png"><link rel="canonical" href="http://xeons.cn/2023/08/05/transactions-mysql/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f97e3791752fae830e3db5ba194c6cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql事务原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-12 21:47:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Calico's Space" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/loading_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Calico's Space"><span class="site-name">Calico's Space</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">mysql事务原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/java/transactions/">transactions</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql事务原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="一、Redo-Log"><a href="#一、Redo-Log" class="headerlink" title="一、Redo Log"></a>一、Redo Log</h2><p>MySQL 中事务的原子性和持久性是由 Redo Log 实现的，它确保 MySQL 事务提交后，事务所涉及的所有操作要么全部执行成功，要么全部执行失败</p>
<h3 id="1-Redo-Log-基本概念"><a href="#1-Redo-Log-基本概念" class="headerlink" title="1.Redo Log 基本概念"></a>1.Redo Log 基本概念</h3><p>Redo Log 也被称作重做日志，它是在 InnoDB 存储引擎中产生的，用来保证事务的原子性和持久性。Redo Log 主要记录的是物理日志，也就是对磁盘上的数据进行的修改操作。Redo Log 往往用来恢复提交后的物理数据页，不过只能恢复到最后一次提交的位置</p>
<p>Redo Log 通常包含两部分：一部分是内存中的日志缓冲，称作 Redo Log Buffer，这部分日志比较容易丢失，另一部分是存放在磁盘上的重做日志文件，称作 Redo Log File，这部分日志是持久化到磁盘上的，不容易丢失</p>
<h3 id="2-Redo-Log-基本原理"><a href="#2-Redo-Log-基本原理" class="headerlink" title="2.Redo Log 基本原理"></a>2.Redo Log 基本原理</h3><p>Redo Log 能够保证事务的原子性和持久性，在 MySQL 发生故障时，尽力避免内存中的脏页数据写入数据表的 IBD 文件。在重启 MySQL 服务时，可以根据 Redo Log 恢复事务已经提交但是还未写入 IBD 文件中的数据，从而对事务提交的数据进行持久化操作</p>
<p>例如，在商城系统的下单业务中，用户提交订单时，系统会创建一条新的订单记录并保存到订单数据表中。在 MySQL 内部，Redo Log 的基本原理可以用下图表示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347132439.png" class="">

<p>从上图可以看出，用户下单后系统创建订单记录，MySQL 在提交事务时，会将数据写入 Redo Log Buffer，而 Redo Log Buffer 中的数据会根据一定的规则写入 Redo Log 文件</p>
<p>当MySQL 发生故障重启时，会通过 Redo Log 中的数据对订单表中的数据进行恢复，也就是 Redo Log 文件中的数据恢复到 order.ibd 文件中</p>
<p>系统可以根据需要，查询并加载订单表中的数据（也就是加载 order.ibd 文件中的数据），也可以向订单表写入数据（也就是持久化数据到 order.ibd 文件中）</p>
<h3 id="3-Redo-Log-刷盘规则"><a href="#3-Redo-Log-刷盘规则" class="headerlink" title="3.Redo Log 刷盘规则"></a>3.Redo Log 刷盘规则</h3><p>在MySQL 的 InnoDB 存储引擎中，通过提交事务时强制执行写日志操作机制实现事务的持久化。InnoDB 存储引擎为了保证在事务提交时，将日志提交到事务日志文件中，默认每次将 Redo Log Buffer 中的日志写入日志文件时，都调用以此操作系统的 fsync() 操作。因为 MySQL 进程和其占用的内存空间都工作在操作系统的用户空间中，所以 MySQL 的 Log Buffer 也工作在操作系统的用户空间中。默认情况下，如果想要将 Log Buffer 中的数据持久化到磁盘的日志文件中， 还需要经过操作系统的内核空间缓冲区，也就是 OS Buffer。从 Redo Log Buffer 中将数据持久化到磁盘的日志文件中的大致流程如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347133382.png" class="">

<p>从上图可以看出，Redo Log 从用户空间的 Log Buffer 写入磁盘的 Redo Log 文件时需要经过内核空间的 OS Buffer。这是因为在打开日志文件时，没有使用 O_DIRECT 标志位，而 O_DIRECT 标志位可以不经过操作系统内核空间的 OS Buffer，直接向磁盘写数据</p>
<p>在InnoDB 存储引擎中，Redo Log 具有以下几种刷盘规则：</p>
<p><strong>1、</strong> 开启事务，发出提交事务指令后是否刷新日志由变量innodb_flush_log_at_trx_commit决定；<br><strong>2、</strong> 每秒刷新一次，刷新日志的频率由变量innodb_flush_log_at_timeout的值决定，默认是1s需要注意的是，刷新日志的频率和是否执行了commit操作无关；<br><strong>3、</strong> 当LogBuffer中已经使用的内存超过一半时，也会触发刷盘操作；<br><strong>4、</strong> 当事务中存在checkpoint（检查点）时，在一定程度上代表了刷写到磁盘时日志所处的LSN的位置其中，LSN（LogSequenceNumber）表示日志的逻辑序列号；</p>
<p>接下来，对第 1 条规则进行简单介绍</p>
<p>当事务提交时，需要先将事务日志写入 Log Buffer，这些写入 Log Buffer 的日志并不是随着事务的提交立刻写入磁盘的，而是根据一定的规则将 Log Buffer 中的数据刷写到磁盘，从而保证了 Redo Log 文件中数据的持久性。这种刷盘规则可以通过 innodb_flush_log_at_trx_commit 变量控制，innodb_flush_log_at_trx_commit 变量可取的值有 0、1 和 2，默认为 1.每个取值代表的刷盘规则下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347135366.png" class="">

<ul>
<li>如果该变量设置为 0，则每次提交事务时，不会将 Log Buffer 中的日志写入 OS Buffer，而是通过一个单独的线程，每秒写入 OS Buffer 并调用 fsync() 函数写入磁盘的 Redo Log 文件。这种方式不是实时写磁盘的，而是每隔 1s 写一次日志，如果系统崩溃，可能会丢失 1s 的数据</li>
<li>如果该变量设置为 1，则每次提交事务都会将 Log Buffer 中的日志写入 OS Buffer，并且会调用 fsync() 函数将日志数据写入磁盘的 Redo Log 文件中。这种方式虽然在系统崩溃时不会丢失数据，但是性能比较差。如果没有设置 innodb_flush_log_at_trx_commit 变量的值，则默认为 1</li>
<li>如果该变量设置为 2，则每次提交事务时，都只是将数据写入 OS Buffer，之后再每隔 1s，通过 fsync() 函数将 OS Buffer 中的日志数据同步写入磁盘的 Redo Log 文件中</li>
</ul>
<p>需要注意的是，在 MySQL 中，有一个变量 innodb_flush_log_at_timeout 的值为 1，这个变量表示刷新日志的频率。另外，在 InnoDB 存储引擎中，刷新数据页到磁盘和刷新 Undo Log 页到磁盘就只有一种检查点规则</p>
<h3 id="4-Redo-Log-写入机制"><a href="#4-Redo-Log-写入机制" class="headerlink" title="4.Redo Log 写入机制"></a>4.Redo Log 写入机制</h3><p>Redo Log 主要记录的是物理日志，其文件内容是以顺序循环的方式写入的，一个文件写满时会写入另一个文件，最后一个文件写满时，会向第一个文件写数据，并且是覆盖写，如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347137859.png" class="">

<p>由上图可以看出：</p>
<p><strong>1、</strong> WritePos是数据表中当前记录所在的位置，随着不断地向数据表中写数据，这个位置会向后移动，当移动到最后一个文件的最后一个位置时，又会回到第一个文件的开始位置进行写操作；<br><strong>2、</strong> CheckPoint是当前要擦除的位置，这个位置也是向后移动的，移动到最后一个文件的最后一个位置时，也会回到第一个文件的最开始位置进行擦除只不过在擦除记录之前，需要把记录更新到数据文件中；<br><strong>3、</strong> WritePos和CheckPoint之间存在间隔时，中间的间隔表示还可以记录新的操作如果WritePos移动的速度较快，追上了CheckPoint，则表示数据已经写满，不能再向RedoLog文件中写数据了此时，需要停止写入数据，擦除一些记录；</p>
<h3 id="5-Redo-Log-的-LSN-机制"><a href="#5-Redo-Log-的-LSN-机制" class="headerlink" title="5.Redo Log 的 LSN 机制"></a>5.Redo Log 的 LSN 机制</h3><p>LSN（Log Sequence Number）表示日志的逻辑序列号。在 InnoDB 存储引擎中，LSN 占用 8 字节的存储空间，并且 LSN 的值是单调递增的。一般可以从 LSN 中获取如下信息：</p>
<p><strong>1、</strong> RedoLog写入数据的总量；<br><strong>2、</strong> 检查点位置；<br><strong>3、</strong> 数据页版本相关的信息；</p>
<p>LSN除了存在于 Redo Log 中外，还存在于数据页中。在每个数据页的头部，有一个 fil_page_lsn 参数记录着当前页最终的 LSN 值。将数据页中的 LSN 值和 Redo Log 中的 LSN 值进行比较，如果数据页中的 LSN 值小于 Redo Log 中的 LSN 值，则表示丢失了一部分数据，此时，可以通过 Redo Log 的记录来恢复数据，否则不需要恢复数据</p>
<p>在MySQL 的命令行通过如下命令可以查看 LSN 值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status \G</span><br><span class="line">#########省略部分日志#############</span><br><span class="line">Log sequence number          <span class="number">3072213599</span></span><br><span class="line">Log buffer assigned up to    <span class="number">3072213599</span></span><br><span class="line">Log buffer completed up to   <span class="number">3072213599</span></span><br><span class="line">Log written up to            <span class="number">3072213599</span></span><br><span class="line">Log flushed up to            <span class="number">3072213599</span></span><br><span class="line">Added dirty pages up to      <span class="number">3072213599</span></span><br><span class="line">Pages flushed up to          <span class="number">3072213599</span></span><br><span class="line">Last checkpoint at           <span class="number">3072213599</span></span><br><span class="line"><span class="number">1620</span> log i/o<span class="string">&#x27;s done, 0.00 log i/o&#x27;</span>s/second</span><br><span class="line">#########省略部分日志#############</span><br></pre></td></tr></table></figure>

<p>重要的参数说明如下所示：</p>
<p><strong>1、</strong> Logsequencenumber：表示当前内存缓冲区中的RedoLog的LSN；<br><strong>2、</strong> Logflushedupto：表示刷新到磁盘上的RedoLog文件中的LSN；<br><strong>3、</strong> Pagesflushedupto：表示已经刷新到磁盘数据页上的LSN；<br><strong>4、</strong> Lastcheckpointat：表示上一次检查点所在位置的LSN；</p>
<h3 id="6-Redo-Log-相关参数"><a href="#6-Redo-Log-相关参数" class="headerlink" title="6.Redo Log 相关参数"></a>6.Redo Log 相关参数</h3><p>在MySQL 中，输入如下命令可以查看与 Redo Log 相关的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%innodb_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以查询到与 Redo Log 有关的几个重要参数如下所示：</p>
<p><strong>1、</strong> innodb_log_buffer_size：表示logbuffer的大小，默认为8MB；<br><strong>2、</strong> innodb_log_file_size：表示事务日志的大小，默认为5MB；<br><strong>3、</strong> innodb_log_files_group&#x3D;2：表示事务日志组中的事务日志文件个数，默认为2个；<br><strong>4、</strong> innodb_log_group_home_dir&#x3D;.&#x2F;：表示事务日志组所在的目录，当前目录表示MySQL数据所在的目录；</p>
<h2 id="二、Undo-Log"><a href="#二、Undo-Log" class="headerlink" title="二、Undo Log"></a>二、Undo Log</h2><p>Undo Log 在 MySQL 事务的实现中也起着至关重要的作用，MySQL 中事务的一致性是由 Undo Log 实现的</p>
<h3 id="1-Undo-Log-基本概念"><a href="#1-Undo-Log-基本概念" class="headerlink" title="1.Undo Log 基本概念"></a>1.Undo Log 基本概念</h3><p>Undo Log 在 MySQL 事务的实现中主要起到两方面的作用：回滚事务和多版本并发事务，也就是常说的 MVCC 机制</p>
<p>在MySQL 启动事务之前， 会将要修改的数据记录存储到 Undo Log 中。如果数据库的事务回滚或者 MySQL 数据库崩溃，可以利用 Undo Log 对数据库中未提交的事务进行回滚操作，从而保证数据库中数据的一致性</p>
<p>Undo Log 会在事务开始前产生， 当事务提交时，不并不会立刻删除相应的 Undo Log。此时，InnoDB 存储引擎会将当前事务对应的 Undo Log 放入待删除的列表，接下来，通过一个后台线程 purge thread 进行删除处理</p>
<p>Undo Log 与 Redo Log 不同，Undo Log 记录的是逻辑日志，可以这样理解：当数据库执行一条 insert 语句时，Undo Log 会记录一条对应的 delete 语句；当数据库执行一条 delete 语句时，Undo Log 会记录一条对应的 insert 语句；当数据库执行一条 update 语句时，Undo Log 会记录一条相反的 update 语句</p>
<p>当数据崩溃重启或者执行回滚事务时，可以从 Undo Log 中读取相应的数据记录进行回滚操作</p>
<p>MySQL 中的多版本并发控制也是通过 Undo Log 实现的，当 select 语句查询的数据被其他事务锁定时，可以从 Undo Log 中分析出当前数据之前的版本，从而向客户端返回之前版本的数据</p>
<p>需要注意的是，因为 MySQL 事务执行过程中产生的 Undo Log 也需要进行持久化操作，所以 Undo Log 也会产生 Redo Log。由于 Undo Log 的完整性和可靠性需要 Redo Log 来保证，因此数据库崩溃时需要先做 Redo Log 数据恢复，然后做 Undo Log 回滚</p>
<h3 id="2-Undo-Log-存储方式"><a href="#2-Undo-Log-存储方式" class="headerlink" title="2.Undo Log 存储方式"></a>2.Undo Log 存储方式</h3><p>在MySQL 中，InnoDB 存储引擎对于 Undo Log 的存储采用段的方式进行管理，在 InnoDB 存储引擎的数据文件中存在一种叫做 rollback segment 的回滚段，这个回滚段内部有 1024 个 undo log segment 段</p>
<p>Undo Log 默认存放在共享数据表空间中，默认为 ibdata1 文件中。如果开启了 innodb_file_per_table 参数，就会将 Undo Log 存放在每张数据表的 .idb 文件中</p>
<p>默认情况下，InnoDB 存储引擎会将回滚段全部写在同一个文件中，也可以通过 innodb_undo_tablespaces 变量将回滚段平均分配到多个文件中。innod_undo_tablespaces 变量的默认值为 0，表示将 rollback segment 回滚段全部写到同一个文件中</p>
<p>需要注意的是，innodb_undo_tablespaces 变量只能在停止 MySQL 服务的情况下修改，重启 MySQL 服务后生效，但是不建议修改这个变量的值</p>
<h3 id="3-Undo-Log-基本原理"><a href="#3-Undo-Log-基本原理" class="headerlink" title="3.Undo Log 基本原理"></a>3.Undo Log 基本原理</h3><p>Undo Log 写入磁盘时和 Redo Log 一样，默认情况下都需要经过内核空间的 OS Buffer，如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347138465.png" class="">

<p>同样，如果在打开日志文件时设置了 O_DIRECT 标志位，就可以不经过操作系统内核空间的 OS Buffer，直接向磁盘写入数据，这点和 Redo Log 也是一样</p>
<p>这里依然以商城系统的下单业务为例来简单说明 Undo Log 的基本原理，如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347140461.png" class="">

<p>从上图中可以看出，MySQL 数据库事务提交之前，InnoDB 存储引擎会将数据表中修改前的数据保存到 Undo Log Buffer。Undo Log Buffer 中的数据会持久化到磁盘的 Undo Log 文件中。当数据库发生故障重启或者事务回滚时，InnoDB 存储引擎会读取 Undo Log 中的数据，将事务还未提交的数据回滚到最初的状态。同时，系统可以根据需要查询并加载订单表中的数据，也就是加载 order.ibd 文件中的数据，也可以向订单表写入数据，也就是持久化数据到 order.ibd 文件中</p>
<h3 id="4-Undo-Log-实现-MVCC-机制"><a href="#4-Undo-Log-实现-MVCC-机制" class="headerlink" title="4.Undo Log 实现 MVCC 机制"></a>4.Undo Log 实现 MVCC 机制</h3><p>在MySQL 中，Undo Log 除了实现事务的回滚操作外，另一个重要的作用就是实现多版本并发控制，也就是 MVCC 机制。在事务提交之前，向 Undo Log 保存事务当前的数据，这些保存到 Undo Log 中的旧版本数据可以作为快照供其他并发事务进行快照读</p>
<p>Undo Log 的回滚段中，undo logs 分为 insert undo log 和 update undo log</p>
<ul>
<li>insert undo log：事务对插入新记录产生的 Undo Log，只是在事务回滚时需要，在事务提交后可以立即丢弃</li>
<li>update undo log：事务对记录进行删除和更新操作时产生的 Undo Log，不仅在事务回滚时需要，在一致性读时也需要，因此不能随便删除，只有当数据库所使用的快照不涉及该日志记录时，对应的回滚日志才会被 purge 线程删除</li>
</ul>
<p>关于InnoDB 实现 MVCC 机制，简单点理解就是 InnoDB 存储引擎在数据表的每行记录后面保存了两个隐藏列，一个隐藏列保存行的创建版本，另一个隐藏列保存行的删除版本。每开始一个新的事务，这些版本号就会递增</p>
<p>在可重复读隔离级别下，MVCC 机制在增删改查操作下分别按照如下方式实现：</p>
<p><strong>1、</strong> 当前操作是select操作时，InnoDB存储引擎只会查找版本号小于或者等于当前事务版本号的数据行，这样可以保证事务读取的数据行要么之前就已经存在，要么是当前事务自身插入或者修改的记录另外，行的删除版本号要么未定义，要么大于当前事务的版本号，这样可以保证事务读取的行在事务开始之前没有被删除；<br><strong>2、</strong> 当前操作是insert操作时，将当前事务的版本号保存为当前行的创建版本号；<br><strong>3、</strong> 当前操作是delete操作时，将当前事务的版本号保存为删除的数据行的删除版本号，作为行删除标识；<br><strong>4、</strong> 当前操作是update操作时，InnoDB存储引擎会将待修改的行复制为新的行，将当前事务的版本号保存为新数据行的创建版本号，同时保存当前事务的版本号为原来数据行的删除版本号；</p>
<p>需要注意的是，将当前事务的版本号保存为行删除版本号时，相应的数据行并不会被真正删除，当事务提交时，会将这些记录放入一个待删除列表，因此需要根据一定的策略对这些标识为删除的行进行清理。为此，InnoDB 存储引擎会开启一个后台线程进行清理工作，是否可以清理需要后台线程来判断</p>
<p>为便于读者理解 Undo Log 实现 MVCC 机制的原理，上面介绍的实现过程经过了简化。从本质上说，为实现 MVCC 机制，InnoDB 存储引擎在数据库每行数据的后面添加了 3 个字段：6 字节的事务 id（DB_TRX_ID）字段、7 字节的回滚指针（DB_ROLL_PTR）字段、6 字节的 DB_ROW_ID 字段。每个字段的作用如下所示：</p>
<ul>
<li>6 字节的事务 id（DB_TRX_ID）字段：用来标识最近一次对本行记录做修改（insert、update）的事务标识符，即最后一次修改本行记录的事务 id。如果是 delete 操作，在 InnoDB 存储引擎内部也属于一次 update 操作，即更新行中的一个特殊位，将行标识为已删除，并非真正删除</li>
<li>7 字节的回滚指针（DB_ROLL_PTR）字段：主要指向上一个版本的行记录，能够从最新版本的行记录逐级向上，找到要查找的行版本记录</li>
<li>6 字节的 DB_ROW_ID 字段：这个字段包含一个随着新数据行的插入操作而单调递增的行 id，当由 InnoDB 存储引擎自动产生聚集索引时，聚集索引会包含这个行 id，否则这个行 id 不会出现在任何索引中</li>
</ul>
<h3 id="5-Undo-Log-相关参数"><a href="#5-Undo-Log-相关参数" class="headerlink" title="5.Undo Log 相关参数"></a>5.Undo Log 相关参数</h3><p>在MySQL 命令行输入如下命令可以查看 Undo Log 香瓜的呢参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&quot;%undo%&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其中几个重要的参数说明如下所示：</p>
<p><strong>1、</strong> innodb_max_undo_log_size：表示UndoLog空间的最大值，当超过这个阈值（默认是1GB），会触发truncate回收（收缩）操作，回收操作后，UndoLog空间缩小到10MB；<br><strong>2、</strong> innodb_undo_directory：表示UndoLog的存储目录；<br><strong>3、</strong> innodb_undo_log_encrypt：MySQL8中新增的参数，表示UndoLog是否加密，OFF表示不加密，ON表示加密，默认为OFF；<br><strong>4、</strong> innodb_undo_log_truncate：表示是否开启在线回收UndoLog文件操作，支持动态设置，ON表示开启，OFF表示关闭，默认为OFF；<br><strong>5、</strong> innodb_undo_tablespaces：此参数必须大于或等于2，即回收一个UndoLog时，要保证另一个UndoLog是可用的；<br><strong>6、</strong> innodb_undo_logs：表示UndoLog的回滚段数量，此参数的值至少大于或等于35，默认为128；<br><strong>7、</strong> innodb_purge_rseg_truncate_frequency：用于控制回收UndoLog的频率UndoLog空间在回滚段释放之前是不会回收的，要想增加释放回滚区间的频率，就要降低innodb_purge_rseg_truncate_frequency参数的值；</p>
<h2 id="三、BinLog"><a href="#三、BinLog" class="headerlink" title="三、BinLog"></a>三、BinLog</h2><p>Redo Log 是 InnoDB 存储引擎特有的日志，MySQL 也有其自身的日志，这个日志就是 BinLog，即二进制日志</p>
<h3 id="1-BinLog-基本概念"><a href="#1-BinLog-基本概念" class="headerlink" title="1.BinLog 基本概念"></a>1.BinLog 基本概念</h3><p>BinLog 是一种记录所有 MySQL 数据库表结构变更以及表数据变更的二进制日志。BinLog 中不会记录诸如 select 和 show 这类查询操作的日志，同时，BinLog 是以事件形式记录相关变更操作的，并且包含语句执行所消耗的时间。BinLog 有以下两个最重要的使用场景：</p>
<p><strong>1、</strong> 主从复制：在主数据库上开启BinLog，主数据库把BinLog发送至从数据库，从数据库获取BinLog后通过I&#x2F;O线程将日志写到中继日志，也就是RelayLog中然后，通过SQL线程将RelayLog中的数据同步至从数据库，从而达到主从数据库数据的一致性；<br><strong>2、</strong> 数据恢复：当MySQL数据库发生故障或者崩溃时，可以通过BinLog进行数据恢复例如，可以使用mysqlbinlog等工具进行数据恢复；</p>
<h3 id="2-BinLog-记录模式"><a href="#2-BinLog-记录模式" class="headerlink" title="2.BinLog 记录模式"></a>2.BinLog 记录模式</h3><p>BinLog 文件中主要有 3 种记录模式，分别为 Row、Statement 和 Mixed</p>
<p><strong>Row 模式</strong><br>Row模式下的 BinLog 文件会记录每一行数据被修改的情况，然后在 MySQL 从数据库中对相同的数据进行修改</p>
<p>Row模式的优点是能够非常清楚地记录每一行数据的修改情况，完全实现主从数据库的同步和数据的恢复</p>
<p>Row模式的缺点是如果主数据库中发生批量操作，尤其是大批量的操作，会产生大量的二进制日志。比如，使用 alter table 操作修改拥有大量数据的数据表结构时，会使二进制日志的内容暴涨，产生大量的二进制日志，从而大大影响主从数据库的同步性能</p>
<p><strong>Statement 模式</strong><br>Statement 模式下的 BinLog 文件会记录每一条修改数据的 SQL 语句，MySQL 从数据库在复制 SQL 语句的时候，会通过 SQL 进程将 BinLog 中的 SQL 语句解析成和 MySQL 主数据库上执行过的 SQL 语句相同的 SQL 语句，然后在从数据库上执行 SQL 进程解析出来的 SQL 语句</p>
<p>Statement 模式的优点是由于不记录数据的修改细节，只是记录数据表结构和数据变更的 SQL 语句，因此产生的二进制日志数据量比较小，这样能够减少磁盘的 I&#x2F;O 操作，提升数据存储和恢复的效率</p>
<p>Statement 模式的缺点是在某些情况下，可能会导致主从数据库中的数据不一致。例如，在 MySQL 主数据库中使用了 last_insert_id() 和 now() 等函数，会导致 MySQL 主从数据库中的数据不一致</p>
<p><strong>Mixed 模式</strong><br>Mixed 模式下的 BinLog 是 Row 模式和 Statement 模式的混用。在这种模式下，一般会使用 Statement 模式保存 BinLog，如果存在 Statement 无法复制的操作，例如在 MySQL 主数据库中使用 last_insert_id() 和 now() 等函数，MySQL 会使用 Row 模式保存 BinLog。也就是说，如果将 BinLog 的记录模式设置为 Mixed，MySQL 会根据执行的 SQL 语句选择写入的记录模式</p>
<h3 id="3-BinLog-文件结构"><a href="#3-BinLog-文件结构" class="headerlink" title="3.BinLog 文件结构"></a>3.BinLog 文件结构</h3><p>MySQL 的 BinLog 文件中保存的是对数据库、数据表和数据表中的数据的各种更新操作。用来表示修改操作的数据结构叫做日志事件（Log Event），不同的修改操作对应着不同的日志集合。在 MySQL 中，比较常用的日志事件包括 Query Event、Row Event、Xid Event 等。从某种程度上说，BinLog 文件的内容就是各种日志事件的集合</p>
<h3 id="4-BinLog-写入机制"><a href="#4-BinLog-写入机制" class="headerlink" title="4.BinLog 写入机制"></a>4.BinLog 写入机制</h3><p>MySQL 事务在提交的时候，会记录事务日志和二进制日志，也就是 Redo Log 和 BinLog。这里就存在一个问题：对于事务日志和二进制日志，MySQL 会先记录哪种呢？</p>
<p>我们已经知道，Redo Log 是 InnoDB 存储引擎特有的日志，BinLog 是 MySQL 本身就有的上层日志，并且会先于 InnoDB 的事务日志被写入，因此在 MySQL 中，二进制日志会先于事务日志被写入</p>
<p>简单点理解就是 MySQL 在写 BinLog 文件时，会按照如下规则进行写操作：</p>
<p><strong>1、</strong> 根据记录的模式（Row、Statement和Mixed）和操作（create、drop、alter、insert、update等）触发事件生成日志事件（事件出发执行机制）；<br><strong>2、</strong> 将事务执行过过程中产生的日志事件写入相应的缓冲区注意，这里是每个事务线程都有一个缓冲区日志事件保存在数据结构binlog_cache_mngr中，这个数据结构中有两个缓冲区：一个是stmt_cache，用于存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的信息；<br><strong>3、</strong> 事务在Commit阶段会将产生的日志事件写入磁盘的BinLog文件中因为不同的事务会以串行的方式将日志事件写入BinLog文件中，所以一个事务中包含的日志事件信息在BinLog文件中是连续的，中间不会插入其他事务的日志事件；</p>
<p>综上，一个事务的 BinLog 是完整的，并且中间不会插入其他事务的 BinLog</p>
<h3 id="5-BinLog-组提交机制"><a href="#5-BinLog-组提交机制" class="headerlink" title="5.BinLog 组提交机制"></a>5.BinLog 组提交机制</h3><p>为了提高 MySQL 中日志刷盘的效率，MySQL 数据库提供了组提交（group commit）功能。通过组提交功能，调用一次 fsync() 函数能够将多个事务的日志刷新到磁盘的日志文件中，而不用将每个事务的日志单独刷新到磁盘的日志文件中，从而大大提升了日志刷盘的效率</p>
<p>在InnoDB 存储引擎中，提交事务时，一般会进行两个阶段的操作：</p>
<p><strong>1、</strong> 修改内存中事务对应的信息，并将日志写入相应的RedoLogBuffer；<br><strong>2、</strong> 调用fsync()函数将RedoLogBuffer中的日志信息刷新到磁盘的RedoLog文件中；</p>
<p>其中，步骤 2 因为存在写磁盘的操作，所以比较耗时。事务提交后，先将日志信息写入内存中的 Redo Log Buffer，然后调用 fsync() 函数将多个事务的日志信息从内存中的 Redo Log Buffer 刷新到磁盘的 Redo Log 文件中，这样能够大大提升事务日志的写入效率，尤其对于写入和更新操作比较频繁的业务，性能提升更加明显</p>
<p>在MySQL 5.6 之前的版本中，如果开启了 BinLog，则 InnoDB 存储引擎的组提交功能就会失效，导致事务性能下降。这是因为在 MySQL 中需要保证 BinLog 和事务日志的一致性，为了保证二者的一致性，使用了两阶段事务。两阶段事务的步骤如下所示：</p>
<p><strong>1、</strong> 当事务提交时，InnoDB存储引擎需要进行prepare操作；<br><strong>2、</strong> MySQL上层会将数据库、数据表和数据表中的数据的更新操作写入BinLog文件；<br><strong>3、</strong> InnoDB存储引擎将事务日志写入RedoLog文件中；</p>
<p>为了保证 BinLog 和事务日志的一致性，在步骤 1 的 prepare 阶段会启用一个 prepare_commit_mutex 锁，这样会导致开启二进制日志后组提交功能失效</p>
<p>这个问题在 MySQL 5.6 中得到了解决。在 MySQL 5.6 中，提交事务时会在 InnoDB 存储引擎的上层将事务按照一定的顺序放入一个队列，队列中的第一个事务称为 leader，其他事务称为 follower。在执行顺序上，虽然还是会先写 BinLog，再写事务日志，但是写日志的机制发生了变化：移除了 prepare_commit_mutex 锁。开启 BinLog 后，组提交功能不会失效。BinLog 的写入和 InnoDB 的事务日志写入都是通过组提交功能进行的</p>
<p>MySQ 5.6 中，这种实现方式称为二进制日志组提交（Binary Log Group Commit，BLGC）。BLGC 的实现主要分为 Flush、Sync 和 Commit 三个阶段：</p>
<p><strong>1、</strong> Flush阶段：将每个事务的BinLog写入对应的内存缓冲区；<br><strong>2、</strong> Sync阶段：将内存缓冲区中的BinLog写入磁盘的BinLog文件，如果队列中存在多个事务，则此时只执行一次刷盘操作就可以将多个事务的BinLog刷新到磁盘的BinLog文件中，这就是BLGC操作；<br><strong>3、</strong> Commit阶段：leader事务根据队列中事务的顺序调用存储引擎层事务的提交操作，由于InnoDB存储引擎本身就支持组提交功能，因此解决了prepare_commit_mutex锁导致的组提交功能失效的问题；</p>
<p>在Flush 阶段，将 BinLog 写入内存缓冲区时，不是写完就立刻进入 Sync 阶段，而是等待一定时间，多积累几个事务的 BinLog 再一起进入 Sync 阶段。这个等待时间由变量 binlog_max_flush_queue_time 决定，binlog_max_flush_queue_time 变量的默认值为 0。除非有大量的事务不断地进行写入和更新操作，否则不建议修改这个变量的值，这是因为修改后可能会导致事务的响应时间变长</p>
<p>进入Sync 阶段后，会将内存缓冲区中多个事务的 BinLog 刷新到磁盘的 BinLog 文件中，和刷新一个事务的 BinLog 一样，也是由 sync_binlog 变量进行控制的</p>
<p>一组事务正在执行 Commit 阶段的操作时，其他新产生的事务可以执行 Flush 阶段的操作，Commit 阶段的事务和 Flush 阶段的事务不会互相阻塞。这样，组提交功能就会持续生效。此时，组提交功能的性能和队列中的事务数量有关，如果队列中只存在一个事务，组提交功能和单独提交一个事务的效果差不多，有时甚至会更差。提交的事务越多，组提交功能的性能提升就越明显</p>
<h3 id="6-BinLog-与-Redo-Log-的区别"><a href="#6-BinLog-与-Redo-Log-的区别" class="headerlink" title="6.BinLog 与 Redo Log 的区别"></a>6.BinLog 与 Redo Log 的区别</h3><p>BinLog 和 Redo Log 在一定程度上都能恢复数据，但是二者有着本质的区别，具体内容如下：</p>
<p><strong>1、</strong> BinLog是MySQL本身就拥有的，不管使用何种存储引擎，BinLog都存在，而RedoLog是InnoDB存储引擎特有的，只有InnoDB存储引擎才会输出RedoLog；<br><strong>2、</strong> BinLog是一种逻辑日志，记录的是对数据库的所有修改操作，而RedoLog是一种物理日志，记录的是每个数据页的修改；<br><strong>3、</strong> RedoLog具有幂等性，多次操作的前后状态是一致的，而BinLog不具有幂等性，记录的是所有影响数据库的操作例如插入一条数据后再将其删除，RedoLog前后的状态不会发生变化，而BinLog就会记录插入操作和删除操作；<br><strong>4、</strong> BinLog开启事务时，会将每次提交的事务一次性写入内存缓冲区，如果未开启事务，则每次成功执行插入、更新和删除语句时，就会将对应的事务信息写入内存缓冲区，而RedoLog是在数据准备修改之前将数据写入缓冲区的RedoLog中，然后在缓冲区中修改数据而且在提交事务时，先将RedoLog写入缓冲区，写入完成后再提交事务；<br><strong>5、</strong> BinLog只会在事务提交时，一次性写入BinLog，其日志的记录方式与事务的提交顺序有关，并且一个事务的BinLog中间不会插入其他事务的BinLog而RedoLog记录的是物理页的修改，最后一个提交的事务记录会覆盖之前所有未提交的事务记录，并且一个事务的RedoLog中间会插入其他事务的RedoLog；<br><strong>6、</strong> BinLog是追加写入，写完一个日志在写下一个日志文件，不会覆盖使用，而RedoLog是循环写入，日志空间的大小是固定的，会覆盖使用；<br><strong>7、</strong> BinLog一般用于主从复制和数据恢复，并且不具备崩溃自动恢复的能力，而RedoLog是在服务器发生故障后重启MySQL，用于恢复事务已提交但未写入数据表的数据；</p>
<h3 id="7-BinLog-相关参数"><a href="#7-BinLog-相关参数" class="headerlink" title="7.BinLog 相关参数"></a>7.BinLog 相关参数</h3><p>在MySQL 中，输入如下命令可以查看与 BinLog 相关的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line">show variables like <span class="string">&#x27;%binlog%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>其中，几个重要的参数如下所示：</p>
<p><strong>1、</strong> log_bin：表示开启二进制日志，未指定BinLog的目录时，会在MySQL的数据目录下生成BinLog，指定BinLog的目录时，会在指定的目录下生成BinLog；<br><strong>2、</strong> log_bin_index：设置此参数可以指定二进制索引文件的路径与名称；<br><strong>3、</strong> binlog_do_db：表示只记录指定数据库的二进制日志；<br><strong>4、</strong> binlog_ignore_db：表示不记录指定数据库的二进制日志；<br><strong>5、</strong> max_binlog_size：表示BinLog的最大值，默认值为1GB；<br><strong>6、</strong> sync_binlog：这个参数会影响MySQL的性能和数据的完整性取值为0时，事务提交后，MySQL将binlog_cache中的数据写入BInLog文件的同时，不会执行fsync()函数刷盘当取值为大于0的数字N时，在进行N此事务提交操作后，MySQL将执行一次fsync()函数，将多个事务的BinLog刷新到磁盘中；<br><strong>7、</strong> max_binlog_cache_size：表示BinLog占用的最大内存；<br><strong>8、</strong> binlog_cache_size：表示BinLog使用的内存大小；<br><strong>9、</strong> binlog_cache_use：表示使用BinLog缓存的事务数量；<br><strong>10、</strong> binlog_cache_disk_use：表示使用BinLog缓存但超过binlog_cache_size的值，并且使用临时文件夹来保存SQL语句中的事务数量；</p>
<p>需要注意的是，MySQL 中默认不会开启 BinLog。如果需要开启 BinLog，要修改 my.cnf 或 my.ini 配置文件，在 mysqlId 下面增加 log_bin &#x3D; mysql_bin_log 命令，重启 MySQL 服务，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binlog-format=ROW</span><br><span class="line">log-bin=mysqlbinlog</span><br></pre></td></tr></table></figure>

<h2 id="四、MySQL-事务流程"><a href="#四、MySQL-事务流程" class="headerlink" title="四、MySQL 事务流程"></a>四、MySQL 事务流程</h2><p>MySQL 的事务流程分为 MySQL 事务执行流程和 MySQL 事务恢复流程，本节对 MySQL 的事务流程进行简单的介绍</p>
<h3 id="1-MySQL-事务执行流程"><a href="#1-MySQL-事务执行流程" class="headerlink" title="1.MySQL 事务执行流程"></a>1.MySQL 事务执行流程</h3><p>MySQL 事务执行流程如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347141389.png" class="">

<p>MySQL 在事务执行的过程中，主要是通过 Redo Log 和 Undo Log 实现的</p>
<p>从上图可以看出，MySQL 在事务执行的过程中，会记录相应 SQL 语句的 Undo Log 和 Redo Log，然后在内存中更新数据并形成数据脏页。接下来 Redo Log 会根据一定的规则触发刷盘操作，Undo Log 和数据脏页则通过检查点机制刷盘。事务提交时，会将当前事务相关的所有 Redo Log 刷盘，只有当前事务相关的所有 Redo Log 刷盘成功，事务才算提交成功</p>
<h3 id="2-MySQL-事务恢复流程"><a href="#2-MySQL-事务恢复流程" class="headerlink" title="2.MySQL 事务恢复流程"></a>2.MySQL 事务恢复流程</h3><p>如果一切正常，则 MySQL 事务会按照上图中的顺序执行。实际上，MySQL 事务的执行不会总是那么顺利。如果 MySQL 由于某种原因崩溃或者宕机，则需要进行数据的恢复或者回滚操作</p>
<p>按照上图所示，如果事务在执行第 8 步，即事务提交之前，MySQL 崩溃或者宕机，此时会先使用 Redo Log 恢复数据，然后使用 Undo Log 回滚数据。如果在执行第 8 步之后 MySQL 崩溃或者宕机，此时会使用 Redo Log 恢复数据，大体流程如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347145162.png" class="">

<p>如上图所示，MySQL 发生崩溃或者宕机时，需要重启 MySQL。MySQL 重启之后，会获取日志检查点信息，随后根据日志检查点信息使用 Redo Log 恢复数据。如果在 MySQL 崩溃或者宕机时，事务未提交，则接下来使用 Undo Log 回滚数据。如果在 MySQL 崩溃或者宕机时，事务已经提交，则用 Redo Log 恢复数据即可</p>
<h2 id="五、MySQL-中的-XA-事务"><a href="#五、MySQL-中的-XA-事务" class="headerlink" title="五、MySQL 中的 XA 事务"></a>五、MySQL 中的 XA 事务</h2><h3 id="1-XA-事务的基本原理"><a href="#1-XA-事务的基本原理" class="headerlink" title="1.XA 事务的基本原理"></a>1.XA 事务的基本原理</h3><p>XA事务支持不同数据库之间实现分布式事务。这里的不同数据库，可以是不同的 MySQL 示例，也可以是不同的数据库类型，比如 MySQL 数据库和 Oracle 数据库</p>
<p>XA事务本质上是一种基于两阶段提交的分布式事务，分布式事务可以简单理解为多个数据库事务共同完成一个原子性的事务操作。参与操作的多个事务要么全部提交成功，要么全部提交失败。在使用 XA 分布式事务时，InnoDB 存储引擎的事务隔离级别需要设置为串行化</p>
<p>XA事务由一个事务管理器（Transaction Manager）、一个或者多个资源管理器（Resource Manager）和一个应用程序（Application Progranm）组成，组成模型如下图所示：</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/1699347146955.png" class="">

<ul>
<li>事务管理器：主要对参与全局事务的各个分支事务进行协调，并与资源管理器进行通信</li>
<li>资源管理器：主要提供对事务资源的访问能力。实际上，一个数据库就可以看作一个资源管理器</li>
<li>应用程序：主要用来明确全局事务和各个分支事务，指定全局事务中的各个操作</li>
</ul>
<p>因为XA 事务是基于两阶段提交的分布式事务，所以 XA 事务也被拆分为 Prepare 阶段和 Commit 阶段</p>
<p>在Prepare 阶段，事务管理器接收所有资源管理器返回的结果信息，如果某一个或多个资源管理器向事务管理器返回的结果信息为不可以提交，或者超时，则事务管理器向所有的资源管理器发送回滚指令。如果事务管理器收到的所有资源管理器返回的结果信息为可以提交，则事务管理器向所有的资源管理器发送提交事务的指令</p>
<p>在某种程度上，MySQL XA 事务可分为内部 XA 事务和外部 XA 事务。外部 XA 事务属于分布式事务的一种实现方式，而内部 XA 事务则表示 MySQL 使用了 InnoDB 作为存储引擎，并且开启了 BinLog，为了保证 BinLog 与 Redo Log 的一致性，MySQL 内部使用了 XA 事务</p>
<p>MySQL Connector&#x2F;J 5.0.0 版本开始支持 XA 事务，也就是说，从 Connector&#x2F; J5.0.0 版本开始提供了 Java 版本 XA 接口的实现。基于此，可以直接通过 Java 代码来执行 MySQL 的 XA 事务。但是直接使用 JDBC 操作 MySQL 的 XA 事务还是比较繁琐的，在实际工作中，很少使用 JDBC 直接操作 MySQL 的 XA 事务，大部分时间会使用第三方框架或者容器来操作 XA 事务，能够大大提高开发的效率</p>
<h3 id="2-MySQL-XA-事务语法"><a href="#2-MySQL-XA-事务语法" class="headerlink" title="2.MySQL XA 事务语法"></a>2.MySQL XA 事务语法</h3><p>在MySQL 命令行输入如下命令可以查看存储引擎是否支持 XA 事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show engines \G</span><br></pre></td></tr></table></figure>

<p>只有InnoDB 存储引擎支持事务、XA 事务和事务保存点</p>
<p>MySQL XA 事务的基本语法如下所示：</p>
<p>1）开启 XA 事务，如果使用的是 XA START 命令而不是 XA BEGIN 命令，则不支持 [JOIN | RESUME]，xid 是一个唯一值，表示事务分支标识符，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA &#123;START|BEGIN&#125; xid [JOIN|RESUME]</span><br></pre></td></tr></table></figure>

<p>2）结束一个 XA 事务，不支持 [SUSPEND [FOR MIGRATE]]，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA END xid [SUSPEND [FOR MIGRATE]]</span><br></pre></td></tr></table></figure>

<p>3）准备提交 XA 事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA PREPARE xid</span><br></pre></td></tr></table></figure>

<p>4）提交 XA 事务，如果使用了 ONE PHASE 命令，表示使用一阶段提交。在两阶段提交协议中，如果只有一个资源管理参与操作，则可以优化为一阶段提交：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA COMMIT xid [ONE PHASE]</span><br></pre></td></tr></table></figure>

<p>5）回滚 XA 事务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA ROLLBACK xid</span><br></pre></td></tr></table></figure>

<p>6）列出所有处于准备阶段的 XA 事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XA RECOVER [CONVERT XID]</span><br></pre></td></tr></table></figure>

<p>下面是MySQL 官方文档中对于 XA 事务的一个简单示例，演示了 MySQL 作为全局事务中的一个事务分支，将一行记录插入一个表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; XA START <span class="string">&#x27;xatest&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO <span class="title function_">mytable</span> <span class="params">(i)</span> VALUES(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row <span class="title function_">affected</span> <span class="params">(<span class="number">0.04</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; XA END <span class="string">&#x27;xatest&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; XA PREPARE <span class="string">&#x27;xatest&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br><span class="line"></span><br><span class="line">mysql&gt; XA COMMIT <span class="string">&#x27;xatest&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span><br></pre></td></tr></table></figure>

<p>MySQL XA 事务使用 XID 标识分布式事务，xid 主要由以下几部分组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xid: gtrid[, bqual [, formatID]]</span><br></pre></td></tr></table></figure>

<ul>
<li>gtrid：必须，为字符串，表示全局事务标识符</li>
<li>bqual：可选，为字符串，默认是空串，表示分支限定符</li>
<li>formatID：可选，默认值为 1，用于标识 gtrid 和 bqual 值使用的格式</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xeons.cn">Calico</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xeons.cn/2023/08/05/transactions-mysql/">http://xeons.cn/2023/08/05/transactions-mysql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xeons.cn" target="_blank">Calico's Space</a>！</span></div></div><script>function setClipboardText(event){
    let clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) { return; }
    event.preventDefault();
    let text = window.getSelection().toString();
    if (text) {
        event.preventDefault();
        var copyright = "\n\n---\n著作权归 Calico 所有 \n原文链接: http://xeons.cn/2023/08/05/transactions-mysql/";
        clipboardData.setData('text/plain', text + copyright);
    }
};
var contents = document.getElementsByClassName("post");
contents[0].addEventListener('copy',function(e){
    setClipboardText(e);
});</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a></div><div class="post_share"><div class="social-share" data-image="/2023/08/05/transactions-mysql/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wxpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wxpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/06/redis-basic/" title="redis 基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/06/redis-basic/logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">redis 基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/05/transactions-basic/" title="事务详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-basic/logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">事务详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/05/transactions-basic/" title="事务详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-basic/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-05</div><div class="title">事务详解</div></div></a></div><div><a href="/2023/01/03/data-structure-and-algorithm/" title="常见数据结构和算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-03</div><div class="title">常见数据结构和算法</div></div></a></div><div><a href="/2023/06/03/hashmap-sourcecode-analyes/" title="HashMap 源码解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-03</div><div class="title">HashMap 源码解析</div></div></a></div><div><a href="/2023/06/03/java-basic/" title="Java 基础试题1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/05/13/8KXvfwkxihBbtGM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-03</div><div class="title">Java 基础试题1</div></div></a></div><div><a href="/2023/06/23/java-memory-optimize/" title="JVM内存调优"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/06/23/java-memory-optimize/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">JVM内存调优</div></div></a></div><div><a href="/2023/06/04/java-concurrent-basic/" title="Java“并发”常见问题概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/05/13/8KXvfwkxihBbtGM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-04</div><div class="title">Java“并发”常见问题概述</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTczMi8zNjE5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Calico</div><div class="author-info__description">It's my blog，Record everything！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xeonsuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xeonsuo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://weibo.com/xeons" target="_blank" title="微博"><i class="fab fa-weibo" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xeon511@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">python、aiAgent 进化中...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Redo-Log"><span class="toc-number">1.</span> <span class="toc-text">一、Redo Log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redo-Log-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.Redo Log 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Redo-Log-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">2.Redo Log 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redo-Log-%E5%88%B7%E7%9B%98%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">3.Redo Log 刷盘规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Redo-Log-%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.Redo Log 写入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Redo-Log-%E7%9A%84-LSN-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">5.Redo Log 的 LSN 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Redo-Log-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">6.Redo Log 相关参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Undo-Log"><span class="toc-number">2.</span> <span class="toc-text">二、Undo Log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Undo-Log-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">1.Undo Log 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Undo-Log-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2.Undo Log 存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Undo-Log-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">3.Undo Log 基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Undo-Log-%E5%AE%9E%E7%8E%B0-MVCC-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4.Undo Log 实现 MVCC 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Undo-Log-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">5.Undo Log 相关参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81BinLog"><span class="toc-number">3.</span> <span class="toc-text">三、BinLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BinLog-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">1.BinLog 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BinLog-%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2.BinLog 记录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-BinLog-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.BinLog 文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BinLog-%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">4.BinLog 写入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BinLog-%E7%BB%84%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">5.BinLog 组提交机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-BinLog-%E4%B8%8E-Redo-Log-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">6.BinLog 与 Redo Log 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-BinLog-%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">7.BinLog 相关参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MySQL-%E4%BA%8B%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">四、MySQL 事务流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">1.MySQL 事务执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">2.MySQL 事务恢复流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81MySQL-%E4%B8%AD%E7%9A%84-XA-%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">五、MySQL 中的 XA 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-XA-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">1.XA 事务的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MySQL-XA-%E4%BA%8B%E5%8A%A1%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">2.MySQL XA 事务语法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/vue3-quick/" title="vue3快速上手（尚硅谷b站）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/15/vue3-quick/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue3快速上手（尚硅谷b站）"/></a><div class="content"><a class="title" href="/2023/08/15/vue3-quick/" title="vue3快速上手（尚硅谷b站）">vue3快速上手（尚硅谷b站）</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/06/redis-basic/" title="redis 基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/06/redis-basic/logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis 基础"/></a><div class="content"><a class="title" href="/2023/08/06/redis-basic/" title="redis 基础">redis 基础</a><time datetime="2023-08-05T16:00:00.000Z" title="发表于 2023-08-06 00:00:00">2023-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/transactions-mysql/" title="mysql事务原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-mysql/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql事务原理"/></a><div class="content"><a class="title" href="/2023/08/05/transactions-mysql/" title="mysql事务原理">mysql事务原理</a><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/05/transactions-basic/" title="事务详解"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/08/05/transactions-basic/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="事务详解"/></a><div class="content"><a class="title" href="/2023/08/05/transactions-basic/" title="事务详解">事务详解</a><time datetime="2023-08-04T16:00:00.000Z" title="发表于 2023-08-05 00:00:00">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/java-memory-optimize/" title="JVM内存调优"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/06/23/java-memory-optimize/logo.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM内存调优"/></a><div class="content"><a class="title" href="/2023/06/23/java-memory-optimize/" title="JVM内存调优">JVM内存调优</a><time datetime="2023-06-22T16:00:00.000Z" title="发表于 2023-06-23 00:00:00">2023-06-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: none"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Calico</div><div class="footer_custom_text"><a href="icp"><span>Create By hexo,butterfly</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>