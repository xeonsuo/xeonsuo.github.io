<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常见数据结构和算法 | Calico's Space</title><meta name="author" content="Calico"><meta name="copyright" content="Calico"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构的定义1、 Data_Structure，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。2、 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。3、 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。 数据结构在Java的语言体系中按逻辑结构可以分为两大类：线性数据结构和非线性数据结构。 线性数据结构 一维数">
<meta property="og:type" content="article">
<meta property="og:title" content="常见数据结构和算法">
<meta property="og:url" content="http://xeons.cn/2023/01/03/data-structure-and-algorithm/index.html">
<meta property="og:site_name" content="Calico&#39;s Space">
<meta property="og:description" content="数据结构的定义1、 Data_Structure，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。2、 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。3、 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。 数据结构在Java的语言体系中按逻辑结构可以分为两大类：线性数据结构和非线性数据结构。 线性数据结构 一维数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xeons.cn/2023/01/03/data-structure-and-algorithm/logo.png">
<meta property="article:published_time" content="2023-01-02T16:00:00.000Z">
<meta property="article:author" content="Calico">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xeons.cn/2023/01/03/data-structure-and-algorithm/logo.png"><link rel="shortcut icon" href="/images/calico-ss.png"><link rel="canonical" href="http://xeons.cn/2023/01/03/data-structure-and-algorithm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f97e3791752fae830e3db5ba194c6cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常见数据结构和算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-07 22:15:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Calico's Space" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/loading_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Calico's Space"><span class="site-name">Calico's Space</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">常见数据结构和算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-01-02T16:00:00.000Z" title="发表于 2023-01-03 00:00:00">2023-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/">dev</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>93分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="常见数据结构和算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h3><p><strong>1、</strong> Data_Structure，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br><strong>2、</strong> 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。<br><strong>3、</strong> 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</p>
<p>数据结构在Java的语言体系中按逻辑结构可以分为两大类：<strong>线性数据结构</strong>和<strong>非线性数据结构</strong>。</p>
<h3 id="线性数据结构"><a href="#线性数据结构" class="headerlink" title="线性数据结构"></a>线性数据结构</h3><blockquote>
<p>一维数组、线性表、栈、队列、串；</p>
</blockquote>
<h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h4><p>   <strong>插入效率比较低,更新，删除效率也比较低，而按索引查询效率非常高,查询效率时间复杂度是1</strong>。</p>
<h4 id="2-线性表-链表"><a href="#2-线性表-链表" class="headerlink" title="2. 线性表(链表)"></a>2. 线性表(链表)</h4><p>  线性表是有序的储存结构、链式的储存结构。链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</p>
<p>操作方法：<strong>插入效率比较高，插入的时候只需要改变节点的前后节点的连接即可。而查询效率就比较低了</strong>，如果实现的不好，需要整个链路找下去才能找到应该找的元素。所以常见的方法有：add(index,element),addFirst(element),addLast(element)。getFirst(),getLast(),get(element)等。</p>
<p>常见的Uitil有：LinkedList，LinkedMap等，而这两个JDK底层也做了N多优化，可以有效避免查询效率低的问题。当自己实现的时候需要注意。其实树形结构可以说是非线性的链式储存结构。</p>
<p><strong>1、链表Linked List）</strong></p>
<p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种<strong>线性表</strong>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个&#x2F;或下一个节点的位置的链接（”links”）</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是<strong>链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</strong></p>
<p><strong>2、单向链表（Single-Linked List）</strong></p>
<p><strong>单链表</strong>是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。</p>
<p>单向链表只可向一个方向遍历：</p>
<ul>
<li><strong>查询</strong>一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。</li>
<li><strong>插入</strong>一个节点，对于单向链表，我们需要将插入位置的前节点的指针指向自己，而自己的指针指向下一个节点。</li>
<li><strong>删除</strong>一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点即可。</li>
</ul>
<p>单向链表的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//链表节点的个数</span></span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SingleLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表的每个节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;<span class="comment">//每个节点的数据</span></span><br><span class="line">        <span class="keyword">private</span> Node next;<span class="comment">//每个节点指向下一个节点的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表头添加元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">addHead</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表头删除元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">deleteHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找指定元素，找到了返回节点Node，找不到返回null</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="keyword">while</span>(tempSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj.equals(current.data))&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tempSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定的元素，删除成功返回true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">previous</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(current.data != value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果删除的节点是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(current == head)&#123;</span><br><span class="line">            head = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//删除的节点不是第一个节点</span></span><br><span class="line">            previous.next = current.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                System.out.println(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">            System.out.println(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong> 用单向链表实现栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackSingleLink</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SingleLinkedList link;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackSingleLink</span><span class="params">()</span>&#123;</span><br><span class="line">        link = <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        link.addHead(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> link.deleteHead();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> link.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印栈内元素信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        link.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、双端链表</strong></p>
<p>对于单项链表，我们如果想在尾部添加一个节点，那么必须从头部一直遍历到尾部，找到尾节点，然后在尾节点后面插入一个节点。这样操作很麻烦，如果我们在设计链表的时候多个对尾节点的引用，那么会简单很多。</p>
<p>双端链表的具体实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublePointLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//节点的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublePointLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表头新增节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表尾新增节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//如果链表为空，那么头节点和尾节点都是该新增节点</span></span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除头部节点，成功返回true，失败返回false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;<span class="comment">//当前链表节点数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;<span class="comment">//当前链表节点数为1</span></span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                System.out.println(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">            System.out.println(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用双端链表实现队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DoublePointLinkedList dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueueLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">DoublePointLinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        dp.addTail(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>&#123;</span><br><span class="line">        dp.deleteHead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        dp.display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有序链表</strong></p>
<p>前面的链表实现插入数据都是无序的，在有些应用中需要链表中的数据有序，这称为有序链表。</p>
<p>在有序链表中，数据是按照关键值有序排列的。一般在大多数需要使用有序数组的场合也可以使用有序链表。有序链表优于有序数组的地方是插入的速度（因为元素不需要移动），另外链表可以扩展到全部有效的使用内存，而数组只能局限于一个固定的大小中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入节点，并按照从小打到的顺序排列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span> &amp;&amp; value &gt; current.data)&#123;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = node;</span><br><span class="line">            head.next = current;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = node;</span><br><span class="line">            node.next = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteHead</span><span class="params">()</span>&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(current.data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双向链表</strong></p>
<p>我们知道单向链表只能从一个方向遍历，那么双向链表它可以从两个方向遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;<span class="comment">//表示链表头</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;<span class="comment">//表示链表尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;<span class="comment">//表示链表的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="keyword">private</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="literal">null</span>;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表头增加节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head.prev = newNode;</span><br><span class="line">            newNode.next = head;</span><br><span class="line">            head = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表尾增加节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(Object value)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newNode.prev = tail;</span><br><span class="line">            tail.next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除链表头</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">deleteHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.prev = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除链表尾</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">deleteTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span>(size != <span class="number">0</span>)&#123;</span><br><span class="line">            tail = tail.prev;</span><br><span class="line">            tail.next = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得链表的节点个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (size == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示节点信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempSize</span> <span class="operator">=</span> size;</span><br><span class="line">            <span class="keyword">if</span>(tempSize == <span class="number">1</span>)&#123;<span class="comment">//当前链表只有一个节点</span></span><br><span class="line">                System.out.println(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tempSize&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.equals(head))&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;[&quot;</span>+node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.print(node.data+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">                tempSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果链表一个节点都没有，直接打印[]</span></span><br><span class="line">            System.out.println(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>上面我们讲了各种链表，每个链表都包括一个LinikedList对象和许多Node对象，LinkedList对象通常包含头和尾节点的引用，分别指向链表的第一个节点和最后一个节点。而每个节点对象通常包含数据部分data，以及对上一个节点的引用prev和下一个节点的引用next，只有下一个节点的引用称为单向链表，两个都有的称为双向链表。next值为null则说明是链表的结尾，如果想找到某个节点，我们必须从第一个节点开始遍历，不断通过next找到下一个节点，直到找到所需要的。栈和队列可以用数组来实现，也可以用链表实现。</p>
<h4 id="3-栈-（stack）"><a href="#3-栈-（stack）" class="headerlink" title="3. 栈 （stack）"></a>3. 栈 （stack）</h4><p>先进后出，后进先出！，实现一些场景对逻辑顺序的要求。所以常用的方法有push(element)压栈，pop()出栈。<br>java.util.Stack。就实现了这用逻辑。而Java的Jvm里面也用的到了此种数据结构，就是线程栈，来保证当前线程的执行顺序。</p>
<h4 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h4><p>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</p>
<p>队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为<strong>先进先出（FIFO—first in first out）</strong> 线性表。</p>
<p>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</p>
<p>队列在Java语言环境中是使用频率相当高的数据结构，所有其实现的类也很多来满足不同场景。</p>
<blockquote>
<p>线程池，连接池、消息队列等应用广泛。</p>
</blockquote>
<p><strong>队列的实现</strong></p>
<p><strong>一、基于数组的Queue实现</strong></p>
<p>一般情况下，对于Queue而言，最核心的操作是：<strong>插入队列(<code>enqueue</code>)、移出队列(<code>dequeue</code>)<strong>。因为在队列中，插入操作是插入到队列的最后，而移出操作是移出队列的头部元素。因此我们通常会使用两个变量</strong><code>front</code>（队头指针）</strong> 和**<code>rear</code>（队尾指针）** 记录当前元素的位置。</p>
<p>假设我们有一个容量有限队列，用于存放字母，如下图所示：</p>
<p>当我们要插入一个元素时，因为总是插入到队列的最尾部，所以插入的位置是rear+1的位置。</p>
<p>当我们要移出一个元素时，是从队头指针front的位置开始移除(因为Queue头部的元素是最先加入进来的，根据FIFO原则，应该最先移除)。当移除一个元素之后，front应该加1，因为移出一个元素之后，下一个元素就变成了第一个元素。例如现在我们移出了5个元素：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551011835.png" class="">

<p>当移出5个元素之后，队头指针就移动到了字母F的位置，前五个位置空下来了。队尾指针rear不变。<br>现在问题来了：队列头部移出的几个元素，位置空下来了。当我们添加元素的时候，从队尾开始加，当添加到最后一个位置时，怎么办？不让添加时不合理的，毕竟前几个位置已经空下来了。我们的期望是，当一个位置上的元素被移出之后，这个位置是可以被重复使用的。而我们这里讨论的是有限容量的数据，如果我们还继续添加元素，那么就要往队列头部来添加。<br>这实际上就涉及到了<strong>循环队列</strong>的概念。也就是当队尾指针到了数组的最后一个下标时，下一个位置应该就是数组的首部。<br><strong>因此，当队尾指针指向数组顶端的时候，我们要将队尾指针(rear)重置为-1，此时再加1，就是0，也就是数组顶端例。</strong>如我们又添加了5个字母，那么结果应该如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551012152.png" class="">

<p><strong>java 基于数组实现Queue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] queArray;</span><br><span class="line">    <span class="comment">//队列总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="comment">//前端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">//后端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">//队列中元素的实际数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> nItems;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">(<span class="type">int</span> s)</span>&#123;</span><br><span class="line">        maxSize = s;</span><br><span class="line">        queArray = <span class="keyword">new</span> <span class="title class_">Object</span>[maxSize];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">        nItems = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//队列中新增数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满！！！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果队列尾部指向顶了，那么循环回来，执行队列的第一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(rear == maxSize -<span class="number">1</span>)&#123;</span><br><span class="line">                rear = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//队尾指针加1，然后在队尾指针处插入新的数据</span></span><br><span class="line">            queArray[++rear] = value;</span><br><span class="line">            nItems++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//移除数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">remove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">removeValue</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="keyword">if</span>(!isEmpty())&#123;</span><br><span class="line">            removeValue = queArray[front];</span><br><span class="line">            queArray[front] = <span class="literal">null</span>;</span><br><span class="line">            front++;</span><br><span class="line">            <span class="keyword">if</span>(front == maxSize)&#123;</span><br><span class="line">                front = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nItems--;</span><br><span class="line">            <span class="keyword">return</span> removeValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> removeValue;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//查看对头数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">peekFront</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queArray[front];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//判断队列是否满了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (nItems == maxSize);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (nItems ==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//返回队列的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nItems;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>java中的队列Queue</strong></p>
<p>ConcurrentLinkedQueue：</p>
<ul>
<li>ConcurrentLinkedQueue是由链表结构组成的线程安全的先进先出无界队列。</li>
<li>当多线程要共享访问集合时，ConcurrentLinkedQueue是一个比较好的选择。</li>
<li>不允许插入null元素</li>
<li>支持非阻塞地访问并发安全的队列，不会抛出ConcurrentModifiationException异常。</li>
</ul>
<p><strong>阻塞队列(BlockingQueue)</strong></p>
<p><strong>阻塞队列特点:</strong><br>阻塞队列的特点就在于阻塞，它可以阻塞线程，让生产者消费者得以平衡，阻塞队列中有两个关键方法 <strong>Put</strong> 和 <strong>Take</strong> 方法</p>
<p><strong>Take :</strong> 方法的功能是获取并移除队列的头结点，通常在队列里有数据的时候是可以正常移除的。可是一旦执行 take 方法的时候，队列里无数据，则阻塞，直到队列里有数据。一旦队列里有数据了，就会立刻解除阻塞状态，并且取到数据。</p>
<p>**Put:**方法插入元素时，如果队列没有满，那就和普通的插入一样是正常的插入，但是如果队列已满，那么就无法继续插入，则阻塞，直到队列里有了空闲空间。如果后续队列有了空闲空间，比如消费者消费了一个元素，那么此时队列就会解除阻塞状态，并把需要添加的数据添加到队列中。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/2d11e13b300a2520ddb44e77951452de_1698551014582.png" class="">

<p><strong>常见的阻塞队列成员:</strong></p>
<p><strong>1、ArrayBlockingQueue:</strong> 数组结构的有界阻塞队列，此队列按照<strong>先进先出</strong>(FIFO)原则对元素进行排序，同时支持公平锁和非公平锁。它的线程安全性由 <code>ReentrantLock</code> 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayBlockingQueue</span><span class="params">(<span class="type">int</span> capacity, <span class="type">boolean</span> fair)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上所示，<strong>ArrayBlockingQueue</strong> 提供的构造函数中，我们需要指定队列的长度，同时我们也可以设置队列是都是公平的，当我们设置了容量后就不能再修改了，符合数组的特性，此队列按照先进先出（FIFO）的原则对元素进行排序。</li>
<li>和 ReentrantLock 一样，如果 ArrayBlockingQueue 被设置为非公平的，那么就存在插队的可能；如果设置为公平的，那么等待了最长时间的线程会被优先处理，其他线程不允许插队，不过这样的公平策略同时会带来一定的性能损耗，因为非公平的吞吐量通常会高于公平的情况。</li>
</ul>
<p><strong>2、LinkedBlockingQueue:</strong> 链表结构的有界阻塞队列，队列的默认大小为 Integer.MAX_VALUE，这个值是非常大的，几乎无法达到，对此我们可以认为这个队列基本属于一个无界队列（也又认为是有界 队列）也是按照<strong>先进先出</strong>原则对元素进行排序的。它的线程安全性由 <code>ReentrantLock</code> 来实现的。</p>
<p><strong>3、PriorityBlockingQueue:</strong> 支持线程优先级排序的无界阻塞队列。默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</p>
<p><strong>4、DelayQueue:</strong> 实现PriorityBlockingQueue优先级排序的延迟阻塞队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</p>
<p><strong>5、SynchronousQueue:</strong> 不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。</p>
<p><strong>6、LinkedBlockingDeque：</strong> 一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，可以将锁的竞争最多降到一半。</p>
<p>这些阻塞队列的实现类是都是实现了BlockingQueue接口</p>
<h4 id="5-串"><a href="#5-串" class="headerlink" title="5. 串"></a>5. 串</h4><p>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String, 而String里面是由chat[]来进行储存。</p>
<blockquote>
<p>KMP算法： 这个算法一定要牢记，Java数据结构这本书里面针对字符串的查找匹配算法也只介绍了一种。关键点就是：在字符串比对的时候，主串的比较位置不需要回退的问题。</p>
</blockquote>
<h3 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h3><h4 id="1、多维数组"><a href="#1、多维数组" class="headerlink" title="1、多维数组"></a><strong>1、多维数组</strong></h4><p>一维数组前面咱也提到了，多维数组无非就是String [][],int[][]等。Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</p>
<h4 id="2、集合"><a href="#2、集合" class="headerlink" title="2、集合"></a><strong>2、集合</strong></h4><p>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</p>
<h4 id="3、树"><a href="#3、树" class="headerlink" title="3、树"></a><strong>3、树</strong></h4><p>前面介绍<strong>数组</strong>的数据结构，我们知道对于<strong>有序数组，查找很快</strong>，并介绍可以通过二分法查找，但是想要在有序数组中插入一个数据项，就必须先找到插入数据项的位置，然后将所有插入位置后面的数据项全部向后移动一位，来给新数据腾出空间，平均来讲要移动N&#x2F;2次，这是很费时的。同理，删除数据也是。（<strong>数组插入、删除慢</strong>），</p>
<p>也介绍了另外一种数据结构——<strong>链表</strong>，链表的<strong>插入和删除很快</strong>，我们只需要改变一些引用值就行了，但是<strong>查找数据却很慢</strong>了，因为不管我们查找什么数据，都需要从链表的第一个数据项开始，遍历到找到所需数据项为止，这个查找也是平均需要比较N&#x2F;2次。</p>
<p>那么我们就希望一种数据结构能<strong>同时具备数组查找快的优点以及链表插入和删除快</strong>的优点，于是 <strong>树</strong> 诞生了。</p>
<p>特点：</p>
<ul>
<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>
<li>除了根节点，其他结点有且只有一个直接父节点</li>
<li>每个结点可以有任意多个直接子节点。</li>
</ul>
<p>根据树的特点又将树分为以下几种：</p>
<p><strong>1) 自由树&#x2F;普通树：对子节点没有任何约束。</strong></p>
<h5 id="2-二叉树：每个节点最多含有两个子节点的树称为二叉树。"><a href="#2-二叉树：每个节点最多含有两个子节点的树称为二叉树。" class="headerlink" title="2) 二叉树：每个节点最多含有两个子节点的树称为二叉树。"></a><strong>2) 二叉树：每个节点最多含有两个子节点的树称为二叉树。</strong></h5><p>2.1) 一般二叉树：每个子节点的父亲节点不一定有两个子节点的二叉树成为一般二叉树。</p>
<p>2.2) 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p>
<blockquote>
<p><strong>1、</strong> 满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树；</p>
</blockquote>
<blockquote>
<p><strong>2、</strong> 在完全二叉树中，若某个节点没有左子树，则一定没有右子树；</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/cad697e4267b8c5fe122b5194bb50aae_1698551017040.png" alt="cad697e4267b8c5fe122b5194bb50aae_1698551017040"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/cad697e4267b8c5fe122b5194bb50aae_1698551017040.png" class=""></p>
<p>2.3) 满二叉树：所有的节点都是二叉的二叉树成为满二叉树。</p>
<p><strong>3) 二叉搜索树&#x2F;BST</strong>：binary search tree,又称二叉排序树、二叉查找树。是有序的。要点：如果不为空，那么其左子树节点的值都小于根节点的值；右子树节点的值都大于根节点的值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/0990e5d1096098de3f62939cf6dd826a_1698551017718.png" alt="0990e5d1096098de3f62939cf6dd826a_1698551017718"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/0990e5d1096098de3f62939cf6dd826a_1698551017718.png" class=""></p>
<p>二叉搜索树作为一种数据结构，那么它是如何工作的呢？ 它查找一个节点，插入一个新节点，以及删除一个节点，遍历树等工作效率如何，下面我们来一一介绍。</p>
<p><strong>二叉树节点类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;    <span class="comment">//节点数据</span></span><br><span class="line">    <span class="keyword">private</span> Node leftChild; <span class="comment">//左子节点的引用</span></span><br><span class="line">    <span class="keyword">private</span> Node rightChild; <span class="comment">//右子节点的引用</span></span><br><span class="line">    <span class="comment">//打印节点内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树的具体方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="comment">//查找节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(Object key)</span>;</span><br><span class="line">    <span class="comment">//插入新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(Object key)</span>;</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Object key)</span>;</span><br><span class="line">    <span class="comment">//Other Method......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找节点</strong></p>
<p>查找某个节点，我们必须从根节点开始遍历。</p>
<p><strong>1、</strong> 查找值比当前节点值大，则搜索右子树；</p>
<p><strong>2、</strong> 查找值等于当前节点值，停止搜索（终止条件）；</p>
<p><strong>3、</strong> 查找值小于当前节点值，则搜索左子树；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找节点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current.data &gt; key)&#123;<span class="comment">//当前值比查找值大，搜索左子树</span></span><br><span class="line">            current = current.leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.data &lt; key)&#123;<span class="comment">//当前值比查找值小，搜索右子树</span></span><br><span class="line">            current = current.rightChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//遍历完整个树没找到，返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入节点</strong></p>
<p>要插入节点，必须先找到插入的位置。与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置，在比较的过程中要注意保存父节点的信息 及 待插入的位置是父节点的左子树还是右子树，才能插入到正确的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;<span class="comment">//当前树为空树，没有任何节点</span></span><br><span class="line">        root = newNode;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            parentNode = current;</span><br><span class="line">            <span class="keyword">if</span>(current.data &gt; data)&#123;<span class="comment">//当前值比插入值大，搜索左子节点</span></span><br><span class="line">                current = current.leftChild;</span><br><span class="line">                <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;<span class="comment">//左子节点为空，直接将新值插入到该节点</span></span><br><span class="line">                    parentNode.leftChild = newNode;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                current = current.rightChild;</span><br><span class="line">                <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;<span class="comment">//右子节点为空，直接将新值插入到该节点</span></span><br><span class="line">                    parentNode.rightChild = newNode;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>查找最大值和最小值</p>
<p>这没什么好说的，要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到最大值</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">findMax</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">maxNode</span> <span class="operator">=</span> current;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">        maxNode = current;</span><br><span class="line">        current = current.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到最小值</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">findMin</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> current;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">        minNode = current;</span><br><span class="line">        current = current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点</p>
<p>删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p>
<p>1、该节点是叶节点（没有子节点）</p>
<p>2、该节点有一个子节点</p>
<p>3、该节点有两个子节点</p>
<p>下面我们分别对这三种情况进行讲解。</p>
<p><strong>1、</strong> 删除没有子节点的节点</p>
<p>要删除叶节点，只需要改变该节点的父节点引用该节点的值，即将其引用改为 null 即可。要删除的节点依然存在，但是它已经不是树的一部分了，由于Java语言的垃圾回收机制，我们不需要非得把节点本身删掉，一旦Java意识到程序不在与该节点有关联，就会自动把它清理出存储器。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551020655.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551020655.png" class=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLeftChild</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//查找删除值，找不到直接返回false</span></span><br><span class="line">    <span class="keyword">while</span>(current.data != key)&#123;</span><br><span class="line">        parent = current;</span><br><span class="line">        <span class="keyword">if</span>(current.data &gt; key)&#123;</span><br><span class="line">            isLeftChild = <span class="literal">true</span>;</span><br><span class="line">            current = current.leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            isLeftChild = <span class="literal">false</span>;</span><br><span class="line">            current = current.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前节点没有子节点</span></span><br><span class="line">    <span class="keyword">if</span>(current.leftChild == <span class="literal">null</span> &amp;&amp; current.rightChild == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">            parent.leftChild = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.rightChild = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除节点，我们要先找到该节点，并记录该节点的父节点。在检查该节点是否有子节点。如果没有子节点，接着检查其是否是根节点，如果是根节点，只需要将其设置为null即可。如果不是根节点，是叶节点，那么断开父节点和其的关系即可。</p>
<p><strong>2、</strong> 删除有一个子节点的节点</p>
<p>删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551021146.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551021146.png" class=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前节点有一个子节点</span></span><br><span class="line"><span class="keyword">if</span>(current.leftChild == <span class="literal">null</span> &amp;&amp; current.rightChild != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">        root = current.rightChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">        parent.leftChild = current.rightChild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parent.rightChild = current.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//current.leftChild != null &amp;&amp; current.rightChild == null</span></span><br><span class="line">    <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">        root = current.leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">        parent.leftChild = current.leftChild;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        parent.rightChild = current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、</strong> 删除有两个子节点的节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551021534.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551021534.png" class=""></p>
<p>当删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。既然处理不了，我们就想到一种办法，用另一个节点来代替被删除的节点，那么用哪一个节点来代替呢？</p>
<p>我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历后继节点。用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。（这里用后继节点代替，如果该后继节点自己也有子节点，我们后面讨论。）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551021915.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551021915.png" class=""></p>
<p>那么如何找到删除节点的中序后继节点呢？其实我们稍微分析，这实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。</p>
<p>后继节点也就是：比删除节点大的最小节点。</p>
<p>算法：程序找到删除节点的右节点，(注意这里前提是删除节点存在左右两个子节点，如果不存在则是删除情况的前面两种)，然后转到该右节点的左子节点，依次顺着左子节点找下去，最后一个左子节点即是后继节点；如果该右节点没有左子节点，那么该右节点便是后继节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551022348.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551022348.png" class=""></p>
<p>需要确定后继节点没有子节点，如果后继节点存在子节点，那么又要分情况讨论了。</p>
<p><strong><em>*1、*</em> 后继节点是删除节点的右子节点</strong></p>
<p>这种情况简单，只需要将后继节点表示的子树移到被删除节点的位置即可！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551023192.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551023192.png" class=""></p>
<p><strong><em>*2、*</em> 后继节点是删除节点的右子节点的左子节点</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551024073.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551024073.png" class=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">getSuccessor</span><span class="params">(Node delNode)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">successorParent</span> <span class="operator">=</span> delNode;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">successor</span> <span class="operator">=</span> delNode;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> delNode.rightChild;</span><br><span class="line">    <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">        successorParent = successor;</span><br><span class="line">        successor = current;</span><br><span class="line">        current = current.leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将后继节点替换删除节点</span></span><br><span class="line">    <span class="keyword">if</span>(successor != delNode.rightChild)&#123;</span><br><span class="line">        successorParent.leftChild = successor.rightChild;</span><br><span class="line">        successor.rightChild = delNode.rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> successor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、</strong> 删除有必要吗？</p>
<p>通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们可以不用真正的删除该节点，只需要在Node类中增加一个标识字段isDelete，当该字段为true时，表示该节点已经删除，反正没有删除。那么我们在做比如find()等操作的时候，要先判断isDelete字段是否为true。这样删除的节点并不会改变树的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//节点数据</span></span><br><span class="line">    Node leftChild; <span class="comment">//左子节点的引用</span></span><br><span class="line">    Node rightChild; <span class="comment">//右子节点的引用</span></span><br><span class="line">    <span class="type">boolean</span> isDelete;<span class="comment">//表示节点是否被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树的效率</p>
<p>从前面的大部分对树的操作来看，都需要从根节点到下一层一层的查找。</p>
<p>一颗满树，每层节点数大概为2n-1，那么最底层的节点个数比树的其它节点数多1，因此，查找、插入或删除节点的操作大约有一半都需要找到底层的节点，另外四分之一的节点在倒数第二层，依次类推。</p>
<p>总共N层共有2n-1个节点，那么时间复杂度为O(logn),底数为2。</p>
<p>在有1000000 个数据项的无序数组和链表中，查找数据项平均会比较500000 次，但是在有1000000个节点的二叉树中，只需要20次或更少的比较即可。</p>
<p>有序数组可以很快的找到数据项，但是插入数据项的平均需要移动 500000 次数据项，在 1000000 个节点的二叉树中插入数据项需要20次或更少比较，在加上很短的时间来连接数据项。</p>
<p>同样，从 1000000 个数据项的数组中删除一个数据项平均需要移动 500000 个数据项，而在 1000000 个节点的二叉树中删除节点只需要20次或更少的次数来找到他，然后在花一点时间来找到它的后继节点，一点时间来断开节点以及连接后继节点。</p>
<p>所以，树对所有常用数据结构的操作都有很高的效率。</p>
<p>遍历可能不如其他操作快，但是在大型数据库中，遍历是很少使用的操作，它更常用于程序中的辅助算法来解析算术或其它表达式。</p>
<p>完整的BinaryTree代码</p>
<p><strong>Node.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//节点数据</span></span><br><span class="line">    Node leftChild; <span class="comment">//左子节点的引用</span></span><br><span class="line">    Node rightChild; <span class="comment">//右子节点的引用</span></span><br><span class="line">    <span class="type">boolean</span> isDelete;<span class="comment">//表示节点是否被删除</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印节点内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Tree.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="comment">//查找节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span>;</span><br><span class="line">    <span class="comment">//插入新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(Node current)</span>;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node current)</span>;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node current)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//查找最大值</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findMax</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//查找最小值</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findMin</span><span class="params">()</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//Other Method......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BinaryTree.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> <span class="keyword">implements</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="comment">//表示根节点</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//查找节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">find</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.data &gt; key)&#123;<span class="comment">//当前值比查找值大，搜索左子树</span></span><br><span class="line">                current = current.leftChild;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.data &lt; key)&#123;<span class="comment">//当前值比查找值小，搜索右子树</span></span><br><span class="line">                current = current.rightChild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//遍历完整个树没找到，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//插入节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;<span class="comment">//当前树为空树，没有任何节点</span></span><br><span class="line">            root = newNode;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parentNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">                parentNode = current;</span><br><span class="line">                <span class="keyword">if</span>(current.data &gt; data)&#123;<span class="comment">//当前值比插入值大，搜索左子节点</span></span><br><span class="line">                    current = current.leftChild;</span><br><span class="line">                    <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;<span class="comment">//左子节点为空，直接将新值插入到该节点</span></span><br><span class="line">                        parentNode.leftChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    current = current.rightChild;</span><br><span class="line">                    <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;<span class="comment">//右子节点为空，直接将新值插入到该节点</span></span><br><span class="line">                        parentNode.rightChild = newNode;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(Node current)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            infixOrder(current.leftChild);</span><br><span class="line">            System.out.print(current.data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            infixOrder(current.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node current)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(current.data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            infixOrder(current.leftChild);</span><br><span class="line">            infixOrder(current.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node current)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            infixOrder(current.leftChild);</span><br><span class="line">            infixOrder(current.rightChild);</span><br><span class="line">            System.out.print(current.data+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最大值</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findMax</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">maxNode</span> <span class="operator">=</span> current;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            maxNode = current;</span><br><span class="line">            current = current.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到最小值</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findMin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> current;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            minNode = current;</span><br><span class="line">            current = current.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minNode;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeftChild</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//查找删除值，找不到直接返回false</span></span><br><span class="line">        <span class="keyword">while</span>(current.data != key)&#123;</span><br><span class="line">            parent = current;</span><br><span class="line">            <span class="keyword">if</span>(current.data &gt; key)&#123;</span><br><span class="line">                isLeftChild = <span class="literal">true</span>;</span><br><span class="line">                current = current.leftChild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                isLeftChild = <span class="literal">false</span>;</span><br><span class="line">                current = current.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(current == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前节点没有子节点</span></span><br><span class="line">        <span class="keyword">if</span>(current.leftChild == <span class="literal">null</span> &amp;&amp; current.rightChild == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">                parent.leftChild = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.rightChild = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//当前节点有一个子节点，右子节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.leftChild == <span class="literal">null</span> &amp;&amp; current.rightChild != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">                root = current.rightChild;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">                parent.leftChild = current.rightChild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.rightChild = current.rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//当前节点有一个子节点，左子节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(current.leftChild != <span class="literal">null</span> &amp;&amp; current.rightChild == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">                root = current.leftChild;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">                parent.leftChild = current.leftChild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.rightChild = current.leftChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前节点存在两个子节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">successor</span> <span class="operator">=</span> getSuccessor(current);</span><br><span class="line">            <span class="keyword">if</span>(current == root)&#123;</span><br><span class="line">                root= successor;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftChild)&#123;</span><br><span class="line">                parent.leftChild = successor;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.rightChild = successor;</span><br><span class="line">            &#125;</span><br><span class="line">            successor.leftChild = current.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getSuccessor</span><span class="params">(Node delNode)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">successorParent</span> <span class="operator">=</span> delNode;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">successor</span> <span class="operator">=</span> delNode;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> delNode.rightChild;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = current;</span><br><span class="line">            current = current.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后继节点不是删除节点的右子节点，将后继节点替换删除节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor != delNode.rightChild)&#123;</span><br><span class="line">            successorParent.leftChild = successor.rightChild;</span><br><span class="line">            successor.rightChild = delNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        bt.insert(<span class="number">50</span>);</span><br><span class="line">        bt.insert(<span class="number">20</span>);</span><br><span class="line">        bt.insert(<span class="number">80</span>);</span><br><span class="line">        bt.insert(<span class="number">10</span>);</span><br><span class="line">        bt.insert(<span class="number">30</span>);</span><br><span class="line">        bt.insert(<span class="number">60</span>);</span><br><span class="line">        bt.insert(<span class="number">90</span>);</span><br><span class="line">        bt.insert(<span class="number">25</span>);</span><br><span class="line">        bt.insert(<span class="number">85</span>);</span><br><span class="line">        bt.insert(<span class="number">100</span>);</span><br><span class="line">        bt.delete(<span class="number">10</span>);<span class="comment">//删除没有子节点的节点</span></span><br><span class="line">        bt.delete(<span class="number">30</span>);<span class="comment">//删除有一个子节点的节点</span></span><br><span class="line">        bt.delete(<span class="number">80</span>);<span class="comment">//删除有两个子节点的节点</span></span><br><span class="line">        System.out.println(bt.findMax().data);</span><br><span class="line">        System.out.println(bt.findMin().data);</span><br><span class="line">        System.out.println(bt.find(<span class="number">100</span>));</span><br><span class="line">        System.out.println(bt.find(<span class="number">200</span>));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>树是由边和节点构成，根节点是树最顶端的节点，它没有父节点；二叉树中，最多有两个子节点；某个节点的左子树每个节点都比该节点的关键字值小，右子树的每个节点都比该节点的关键字值大，那么这种树称为<strong>二叉搜索树</strong>，其查找、插入、删除的时间复杂度都为logN；可以通过<strong>前序遍历、中序遍历、后序遍历</strong>来遍历树，<strong>前序是根节点-左子树-右子树，中序是左子树-根节点-右子树，后序是左子树-右子树-根节点</strong>；删除一个节点只需要断开指向它的引用即可。</p>
<p><strong>3.1) 二叉平衡树</strong>：二叉搜索树，是有序的排序树，但左右两边包括子节点不一定平衡，而二叉平衡树是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/ea38dc15d5961fe08aef79087d153445_1698551018073.png"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/ea38dc15d5961fe08aef79087d153445_1698551018073.png" class=""></p>
<p>为了实现，二叉平衡树又延伸出来了一些算法，业界常见的有AVL、和红黑算法，所以又有以下两种树：</p>
<p><strong>3.1.1) AVL树</strong>：最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。</p>
<p><strong>3.1.2) 红黑树</strong>：通过制定了一些红黑标记和左右旋转规则来保证二叉树平衡。</p>
<p>二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn),底数为2。但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551024934.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551024934.png" class=""></p>
<p>从大到小就是全部在左边，这和<strong>链表</strong>没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，实际情况下，二叉搜索树的效率应该在O(N)和O(logN)之间，这取决于树的不平衡程度。</p>
<p>那么为了能够以较快的时间O(logN)来搜索一棵树，我们需要保<strong>证树总是平衡的</strong>（或者大部分是平衡的），也就是说每个节点的左子树节点个数和右子树节点个数尽量相等。<strong>红-黑树的就是这样的一棵平衡树</strong>，对一个要插入的数据项（删除也是），插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。</p>
<pre><code>红黑树的5条性质：
**1、** 每个结点要么是红的，要么是黑的。  
**2、** 根结点是黑的。  
**3、** 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
**4、** 如果一个结点是红的，那么它的俩个儿子都是黑的。  
**5、** 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
</code></pre>
<p>红黑树和平衡二叉树的区别</p>
<p><strong>1、</strong> 红黑树放弃了追求完全平衡,追求大致平衡,在与平衡二叉树的时间复杂度相差不大的情况下,保证每次插入最多只需要三次旋转就能达到平衡,实现起来也更为简单；<br><strong>2、</strong> 平衡二叉树追求绝对平衡,条件比较苛刻,实现起来比较麻烦,每次插入新节点之后需要旋转的次数不能预知；</p>
<p><strong>红-黑树的自我修正</strong></p>
<p>红-黑树主要通过三种方式对平衡进行修正，<strong>改变节点颜色、左旋和右旋</strong>。</p>
<p><strong>1、</strong> 改变节点颜色</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551025442.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551025442.png" class=""></p>
<p>新插入的节点为15，一般新插入颜色都为红色，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则4。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。</p>
<p><strong><em>*2、*</em> 右旋</strong></p>
<p>首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551025884.gif" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551025884.gif" class=""></p>
<p><strong><em>*3、*</em> 左旋</strong></p>
<p>左旋的顶端节点必须要有右子节点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551026914.gif" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551026914.gif" class=""></p>
<p><strong>注意</strong>：我们改变颜色也是为了帮助我们判断何时执行什么旋转，而旋转是为了保证树的平衡。光改变节点颜色是不能起到任何作用的，旋转才是关键的操作，在新增节点或者删除节点之后，可能会破坏二叉树的平衡，那么何时执行旋转以及执行什么旋转，这是我们需要重点关注的。</p>
<p>3、左旋和右旋代码</p>
<p><strong><em>*1、*</em> 节点类</strong></p>
<p>节点类和二叉树的节点类差不多，只不过在其基础上增加了一个 boolean 类型的变量来表示节点的颜色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBNode</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> color;<span class="comment">//颜色</span></span><br><span class="line">    T key;<span class="comment">//关键值</span></span><br><span class="line">    RBNode&lt;T&gt; left;<span class="comment">//左子节点</span></span><br><span class="line">    RBNode&lt;T&gt; right;<span class="comment">//右子节点</span></span><br><span class="line">    RBNode&lt;T&gt; parent;<span class="comment">//父节点</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RBNode</span><span class="params">(<span class="type">boolean</span> color,T key,RBNode&lt;T&gt; parent,RBNode&lt;T&gt; left,RBNode&lt;T&gt; right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获得节点的关键值</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印节点的关键值和颜色信息</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+key+(<span class="built_in">this</span>.color == RED ? <span class="string">&quot;R&quot;</span>:<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>*2、*</em> 左旋的具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************对红黑树节点x进行左旋操作 ******************/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 左旋示意图：对节点x进行左旋 </span></span><br><span class="line"><span class="comment"> *     p                       p </span></span><br><span class="line"><span class="comment"> *    /                       / </span></span><br><span class="line"><span class="comment"> *   x                       y </span></span><br><span class="line"><span class="comment"> *  / \                     / \ </span></span><br><span class="line"><span class="comment"> * lx  y      -----&gt;       x  ry </span></span><br><span class="line"><span class="comment"> *    / \                 / \ </span></span><br><span class="line"><span class="comment"> *   ly ry               lx ly </span></span><br><span class="line"><span class="comment"> * 左旋做了三件事： </span></span><br><span class="line"><span class="comment"> * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时) </span></span><br><span class="line"><span class="comment"> * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) </span></span><br><span class="line"><span class="comment"> * 3. 将y的左子节点设为x，将x的父节点设为y </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(RBNode&lt;T&gt; x)</span>&#123;</span><br><span class="line">    <span class="comment">//1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line">    RBNode&lt;T&gt; y = x.right;</span><br><span class="line">    x.right = y.left;</span><br><span class="line">    <span class="keyword">if</span>(y.left != <span class="literal">null</span>)&#123;</span><br><span class="line">        y.left.parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line">    y.parent = x.parent;</span><br><span class="line">    <span class="keyword">if</span>(x.parent == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = y;<span class="comment">//如果x的父节点为空(即x为根节点)，则将y设为根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == x.parent.left)&#123;<span class="comment">//如果x是左子节点</span></span><br><span class="line">            x.parent.left = y;<span class="comment">//则也将y设为左子节点 </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x.parent.right = y;<span class="comment">//否则将y设为右子节点 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//3. 将y的左子节点设为x，将x的父节点设为y</span></span><br><span class="line">    y.left = x;</span><br><span class="line">    x.parent = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>*3、*</em> 右旋的具体实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************对红黑树节点y进行右旋操作 ******************/</span> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 左旋示意图：对节点y进行右旋</span></span><br><span class="line"><span class="comment"> *        p                   p</span></span><br><span class="line"><span class="comment"> *       /                   /</span></span><br><span class="line"><span class="comment"> *      y                   x</span></span><br><span class="line"><span class="comment"> *     / \                 / \</span></span><br><span class="line"><span class="comment"> *    x  ry   -----&gt;      lx  y</span></span><br><span class="line"><span class="comment"> *   / \                     / \</span></span><br><span class="line"><span class="comment"> * lx  rx                   rx ry</span></span><br><span class="line"><span class="comment"> * 右旋做了三件事：</span></span><br><span class="line"><span class="comment"> * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</span></span><br><span class="line"><span class="comment"> * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</span></span><br><span class="line"><span class="comment"> * 3. 将x的右子节点设为y，将y的父节点设为x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(RBNode&lt;T&gt; y)</span>&#123;</span><br><span class="line">    <span class="comment">//1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)</span></span><br><span class="line">    RBNode&lt;T&gt; x = y.left;</span><br><span class="line">    y.left = x.right;</span><br><span class="line">    <span class="keyword">if</span>(x.right != <span class="literal">null</span>)&#123;</span><br><span class="line">        x.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</span></span><br><span class="line">    x.parent = y.parent;</span><br><span class="line">    <span class="keyword">if</span>(y.parent == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = x;<span class="comment">//如果y的父节点为空(即y为根节点)，则旋转后将x设为根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == y.parent.left)&#123;<span class="comment">//如果y是左子节点</span></span><br><span class="line">            y.parent.left = x;<span class="comment">//则将x也设置为左子节点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            y.parent.right = x;<span class="comment">//否则将x设置为右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//3. 将x的左子节点设为y，将y的父节点设为y</span></span><br><span class="line">    x.right = y;</span><br><span class="line">    y.parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、插入操作</strong></p>
<p>和二叉树的插入操作一样，都是得先找到插入的位置，然后再将节点插入。先看看插入的前段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*********************** 向红黑树中插入节点 **********************/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(T key)</span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; node = <span class="keyword">new</span> <span class="title class_">RBNode</span>&lt;T&gt;(RED, key, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">        insert(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(RBNode&lt;T&gt; node)</span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; current = <span class="literal">null</span>;<span class="comment">//表示最后node的父节点</span></span><br><span class="line">    RBNode&lt;T&gt; x = <span class="built_in">this</span>.root;<span class="comment">//用来向下搜索</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//1.找到插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">        current = x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> node.key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = x.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x = x.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.parent = current;<span class="comment">//找到了插入的位置，将当前current作为node的父节点</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2.接下来判断node是左子节点还是右子节点</span></span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> node.key.compareTo(current.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            current.left = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current.right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.root = node;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//3.利用旋转操作将其修正为一颗红黑树</span></span><br><span class="line">    insertFixUp(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与二叉搜索树中实现的思路一样，这里不再赘述，主要看看方法里面最后一步 <strong>insertFixUp(node)</strong> 操作。因为插入后可能会导致树的不平衡，insertFixUp(node) 方法里主要是分情况讨论，分析何时变色，何时左旋，何时右旋。我们先从理论上分析具体的情况，然后再看insertFixUp(node) 的具体实现。</p>
<p>如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况，我们就要开始变色和旋转了：</p>
<p><strong>1、</strong> 插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。</p>
<p><strong>2、</strong> 插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。</p>
<p><strong>3、</strong> 插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子节点。</p>
<p>下面我们挨个分析这三种情况都需要如何操作，然后给出实现代码。</p>
<p>在下面的讨论中，使用N,P,G,U表示关联的节点。N(now)表示当前节点，P(parent)表示N的父节点，U(uncle)表示N的叔叔节点，G(grandfather)表示N的祖父节点，也就是P和U的父节点。</p>
<p>对于情况1：<strong>插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。</strong>此时，肯定存在祖父节点，但是不知道父节点是其左子节点还是右子节点，但是由于对称性，我们只要讨论出一边的情况，另一种情况自然也与之对应。这里考虑父节点是其祖父节点的左子节点的情况，如下左图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551028293.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551028293.png" class=""> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551028697.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551028697.png" class=""></p>
<p>对于这种情况，我们要做的操作有：将当前节点(4) 的父节点(5) 和叔叔节点(8) 涂黑，将祖父节点(7)涂红,变成了上有图所示的情况。再将当前节点指向其祖父节点，再次从新的当前节点开始算法（具体看下面的步骤）。这样上右图就变成情况2了。</p>
<p>对于情况2：<strong>插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点</strong>。我们要做的操作有：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。完成后如左下图所示，这样左下图就变成情况3了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551029104.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551029104.png" class=""> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551029532.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551029532.png" class=""></p>
<p>对于情况3：<strong>插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点</strong>。我们要做的操作有：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如右上图所示。至此，插入操作完成！</p>
<p>我们可以看出，如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色-&gt;左旋-&gt;右旋。</p>
<p>至此，我们完成了全部的插入操作。下面我们看看insertFixUp方法中的具体实现（可以结合上面的分析图，更加利与理解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertFixUp</span><span class="params">(RBNode&lt;T&gt; node)</span>&#123;</span><br><span class="line">    RBNode&lt;T&gt; parent,gparent;<span class="comment">//定义父节点和祖父节点</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//需要修正的条件：父节点存在，且父节点的颜色是红色</span></span><br><span class="line">    <span class="keyword">while</span>(((parent = parentOf(node)) != <span class="literal">null</span>) &amp;&amp; isRed(parent))&#123;</span><br><span class="line">        gparent = parentOf(parent);<span class="comment">//获得祖父节点</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//若父节点是祖父节点的左子节点，下面的else相反</span></span><br><span class="line">        <span class="keyword">if</span>(parent == gparent.left)&#123;</span><br><span class="line">            RBNode&lt;T&gt; uncle = gparent.right;<span class="comment">//获得叔叔节点</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case1:叔叔节点也是红色</span></span><br><span class="line">            <span class="keyword">if</span>(uncle != <span class="literal">null</span> &amp;&amp; isRed(uncle))&#123;</span><br><span class="line">                setBlack(parent);<span class="comment">//把父节点和叔叔节点涂黑</span></span><br><span class="line">                setBlack(gparent);</span><br><span class="line">                setRed(gparent);<span class="comment">//把祖父节点涂红</span></span><br><span class="line">                node = gparent;<span class="comment">//把位置放到祖父节点处</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//继续while循环，重新判断</span></span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case2:叔叔节点是黑色，且当前节点是右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(node == parent.right)&#123;</span><br><span class="line">                leftRotate(parent);<span class="comment">//从父节点出左旋</span></span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;<span class="comment">//然后将父节点和自己调换一下，为下面右旋做准备</span></span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case3:叔叔节点是黑色，且当前节点是左子节点</span></span><br><span class="line">            setBlack(parent);</span><br><span class="line">            setRed(gparent);</span><br><span class="line">            rightRotate(gparent);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//若父节点是祖父节点的右子节点，与上面的情况完全相反，本质是一样的</span></span><br><span class="line">            RBNode&lt;T&gt; uncle = gparent.left;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case1:叔叔节点也是红色的</span></span><br><span class="line">            <span class="keyword">if</span>(uncle != <span class="literal">null</span> &amp;&amp; isRed(uncle))&#123;</span><br><span class="line">                setBlack(parent);</span><br><span class="line">                setBlack(uncle);</span><br><span class="line">                setRed(gparent);</span><br><span class="line">                node = gparent;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case2:叔叔节点是黑色的，且当前节点是左子节点</span></span><br><span class="line">            <span class="keyword">if</span>(node == parent.left)&#123;</span><br><span class="line">                rightRotate(parent);</span><br><span class="line">                RBNode&lt;T&gt; tmp = parent;</span><br><span class="line">                parent = node;</span><br><span class="line">                node = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//case3:叔叔节点是黑色的，且当前节点是右子节点</span></span><br><span class="line">            setBlack(parent);</span><br><span class="line">            setRed(gparent);</span><br><span class="line">            leftRotate(gparent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setBlack(root);<span class="comment">//将根节点设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5、删除操作</strong></p>
<p>上面探讨完了红-黑树的插入操作，接下来讨论删除，红-黑树的删除和二叉查找树的删除是一样的，只不过删除后多了个平衡的修复而已。我们先来回忆一下二叉搜索树的删除：</p>
<p><strong>1、</strong> 如果待删除的节点没有子节点，那么直接删除即可。</p>
<p><strong>2、</strong> 如果待删除的节点只有一个子节点，那么直接删掉，并用其子节点去顶替它。</p>
<p><strong>3、</strong> 如果待删除的节点有两个子节点，这种情况比较复杂：首先找出它的后继节点，然后处理“后继节点”和“被删除节点的父节点”之间的关系，最后处理“后继节点的子节点”和“被删除节点的子节点”之间的关系。每一步中也会有不同的情况。</p>
<p>实际上，删除过程太复杂了，很多情况下会采用在节点类中添加一个删除标记，并不是真正的删除节点。详细的删除我们这里不做讨论。</p>
<p><strong>6、红黑树的效率</strong></p>
<p>红黑树的查找、插入和删除时间复杂度都为O(log2N)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是O(log2N),(时间复杂度的计算要省略常数)，但实际上比普通的二叉树是要慢的。</p>
<p>大多数应用中，查找的次数比插入和删除的次数多，所以应用红黑树取代普通的二叉搜索树总体上不会有太多的时间开销。而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>
<p><strong>4) B-tree</strong>：又称B树、B-树。又叫平衡(balance)多路查找树。树中每个结点最多含有m个孩子（m&gt;&#x3D;2）。它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<p><strong>5) B+tree</strong>：又称B+。是B-树的变体，也是一种多路搜索树。</p>
<blockquote>
<p>树总结：<br>树在Java里面应用的也比较多。非排序树，主要用来做数据储存和展示。而排序树，主要用来做算法和运算，HashMap里面的TreeNode就用到了红黑树算法。而B+树在数据库的索引原理里面有典型的应用。</p>
</blockquote>
<h5 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h5><p>遍历树是根据一种特定的顺序访问树的每一个节点。比较常用的有前序遍历，中序遍历和后序遍历。而二叉搜索树最常用的是中序遍历。</p>
<p><strong><em>*1、*</em> 中序遍历:左子树——》根节点——》右子树</strong></p>
<p><strong><em>*2、*</em> 前序遍历:根节点——》左子树——》右子树</strong></p>
<p><strong>3、</strong> 后序遍历:左子树——》右子树——》根节点**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/d1853249b5c057a8249482818d157423_1698551019054.png"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/d1853249b5c057a8249482818d157423_1698551019054.png" class=""></p>
<h4 id="4、Hash"><a href="#4、Hash" class="headerlink" title="4、Hash"></a><strong>4、Hash</strong></h4><p>Hash概念：</p>
<p><strong>1、</strong> Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。<br><strong>2、</strong> 所谓的Hash算法都是散列算法，把任意长度的输入，变换成固定长度的输出，该输出就是散列值.（如：MD5,SHA1,加解密算法等）<br><strong>3、</strong> 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>Hash表：</p>
<p><strong>1、</strong> Java中数据存储方式最底层的两种结构，一种是数组，另一种就是链表。而Hash表就是综合了这两种数据结构。<br><strong>2、</strong> 如：HashTable,HashMap。这个时候就得提一下HashMap的原理了，默认16个数组储存，通过Hash值取模放到不同的桶里面去。（注意：JDK1.8此处算法又做了改进，数组里面的值会演变成树形结构<br><strong>3、</strong> 哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</p>
<p>一致性Hash：</p>
<p><strong>1、</strong> 我们查看一下HashMap的原理，其实发现Hash很好的解决了单体应用情况下的数据查找和插入的速度问题。但是毕竟单体应用的储存空间是有限的，所有在分布式环境下，应运而生了一致性Hash算法。<br><strong>2、</strong> 用意和hashCode的用意一样，只不过它是取模放在不同的IP机器上而已。具体算法可以找一下相关资料。<br><strong>3、</strong> 而一致性Hash需要注意的就是默认分配的桶比较多些，而当其中一台机器挂了，影响的面比较小一些。<br><strong>4、</strong> 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</p>
<h5 id="1-常见的hash函数"><a href="#1-常见的hash函数" class="headerlink" title="1)  常见的hash函数"></a>1)  常见的hash函数</h5><p><strong>直接定址法</strong></p>
<ul>
<li>取关键字或关键字的某个线性函数值为散列地址。</li>
<li>即 H(key) &#x3D; key 或 H(key) &#x3D; a*key + b，其中a和b为常数。</li>
</ul>
<p><strong>除留余数法</strong></p>
<ul>
<li>取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。</li>
<li>即 H(key) &#x3D; key % p, p &lt; m。</li>
</ul>
<p><strong>数字分析法</strong></p>
<ul>
<li>当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。</li>
<li>仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。</li>
</ul>
<p><strong>平方取中法</strong></p>
<ul>
<li>先计算出关键字值的平方，然后取平方值中间几位作为散列地址。</li>
<li>随机分布的关键字，得到的散列地址也是随机分布的。</li>
</ul>
<p><strong>折叠法（叠加法）</strong></p>
<ul>
<li>将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。</li>
<li>用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。</li>
</ul>
<p><strong>随机数法</strong></p>
<ul>
<li>选择一个随机函数，把关键字的随机函数值作为它的哈希值。</li>
<li>通常当关键字的长度不等时用这种方法。</li>
</ul>
<p>构造哈希函数的方法很多，实际工作中要根据不同的情况选择合适的方法，总的原则是尽可能少的产生冲突。<br>通常考虑的因素有关键字的长度和分布情况、哈希值的范围等。<br>如：当关键字是整数类型时就可以用除留余数法；如果关键字是小数类型，选择随机数法会比较好。</p>
<h5 id="2-哈希冲突的解决"><a href="#2-哈希冲突的解决" class="headerlink" title="2) 哈希冲突的解决"></a>2) 哈希冲突的解决</h5><p>选用哈希函数计算哈希值时，可能不同的 key 会得到相同的结果，一个地址怎么存放多个数据呢？这就是冲突。</p>
<p>常用的主要有两种方法解决冲突：</p>
<p><strong>1.链接法（拉链法）</strong></p>
<p>拉链法解决冲突的做法是：<br>将所有关键字为同义词的结点链接在同一个单链表中。</p>
<p>若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数组 T[0..m-1] 。</p>
<p>凡是散列地址为 i 的结点，均插入到以 T[i] 为头指针的单链表中。<br>T中各分量的初值均应为空指针。</p>
<p>在拉链法中，装填因子 α 可以大于 1，但一般均取 α ≤ 1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698551030426.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698551030426.png" class=""></p>
<p><strong>2.开放定址法</strong></p>
<p>用开放定址法解决冲突的做法是：</p>
<blockquote>
<p>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址（即该地址单元为空）为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探测到开放的地址则表明表中无待查的关键字，即查找失败。</p>
</blockquote>
<p>简单的说：当冲突发生时，使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。</p>
<p>按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。</p>
<p><strong>a.线性探查法</strong></p>
<p>hi&#x3D;(h(key)+i) ％ m ，0 ≤ i ≤ m-1</p>
<p>基本思想是：<br>探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到 有空余地址 或者到 T[d-1]为止。</p>
<p><strong>b.二次探查法</strong></p>
<p>hi&#x3D;(h(key)+i*i) ％ m，0 ≤ i ≤ m-1</p>
<p>基本思想是：<br>探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，T[d+2^2]，T[d+3^2],…，等，直到探查到 有空余地址 或者到 T[d-1]为止。</p>
<p>缺点是无法探查到整个散列空间。</p>
<p><strong>c.双重散列法</strong></p>
<p>hi&#x3D;(h(key)+i*h1(key)) ％ m，0 ≤ i ≤ m-1</p>
<p>基本思想是：<br>探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+h1(d)], T[d + 2*h1(d)]，…，等。</p>
<p>该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。</p>
<p>定义h1(key) 的方法较多，但无论采用什么方法定义，都必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。</p>
<p>该方法是开放定址法中最好的方法之一。</p>
<h4 id="5-各个数据结构的比较"><a href="#5-各个数据结构的比较" class="headerlink" title="5.各个数据结构的比较"></a>5.各个数据结构的比较</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/data-struct1.png" class="">



<h3 id="排序算法的评价标准"><a href="#排序算法的评价标准" class="headerlink" title="排序算法的评价标准"></a>排序算法的评价标准</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote>
<p>时间复杂度是一个函数，定性描述算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度通常用大写 O 符号来表示，不包括这个函数的低阶项和首项系数。</p>
</blockquote>
<p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，使用 T(n) 表示，如果有某个辅助函数 f(n)，使当 n 趋于无穷大时，T(n)&#x2F;f(n) 的极限值为不等于 0 的常数，则称 f(n) 是 T(n) 的同量级函数。记作 T(n) &#x3D; O(f(n))，称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度</p>
<p>时间频度</p>
<blockquote>
<p>一个算法花费的时间与算法中语句的执行次数成正比，执行次数多花费时间就多。<code>一个算法中语句执行次数称为语句频度或者时间频度 T(n)</code></p>
</blockquote>
<p>计算时间复杂度的方法：</p>
<ul>
<li>使用常数 1 代替运行时间中的所有加法常数</li>
<li>修改后的运行次数函数中，只保留最高阶项</li>
<li>去除最高阶项的系数</li>
</ul>
<p>常见的时间复杂度</p>
<p><strong>1、</strong> 常数阶O(1)；</p>
<p>对于一个算法，T(n) 的上界与输入大小无关，则称其具有常数时间，记作 O(1) 时间。 </p>
<p><strong>2、</strong> 对数阶O(㏒2n)；</p>
<p>㏒a n 和 ㏒b n 只有一个常数因子不同，这个因子在在大 O 记法中被丢弃，因此记作 O(㏒n)，不论对数的底是多少，是对数时间算法的标准记法。</p>
<p>常见的对数时间的算法有二叉树的相关操作和二分搜索</p>
<p> <strong>3、</strong> 线性阶O(n)；</p>
<p>对于足够大的输入，运行时间增加的大小与输入成线性关系。 </p>
<p><strong>4、</strong> 线性对数阶O(n㏒2n)；</p>
<p>线性对数比线性时间要快，但是对于任何含有 n，并且 n 的幂指数大于 1 的多项式时间来说，线性对数时间却增长很慢</p>
<p> <strong>5、</strong> 平方阶O(n^2)；<br><strong>6、</strong> 立方阶O(n^3)；<br><strong>7、</strong> k次方阶O(n^k)；<br><strong>8、</strong> 指数阶O(2^n)；</p>
<p>常见时间复杂度由小到大依次为：O(1) &lt; O( ㏒2 n) &lt; O(n) &lt; O(n㏒2 n) &lt; O(n^2) &lt; O(n^3) &lt; O(n^k) &lt; O(2^n)，随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低。</p>
<p>平均时间复杂度和最坏时间复杂度</p>
<p><strong>1、</strong> 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间；<br><strong>2、</strong> 最坏情况下的时间复杂度称为最坏时间复杂度一般说时间复杂度是最坏情况下的时间复杂度；<br><strong>3、</strong> 平均时间复杂度和最坏时间复杂度是否一致和算法有关；</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p><strong>基本介绍</strong></p>
<ul>
<li>算法的空间复杂度（Space Complexity）定义为该算法所耗费的存储空间</li>
<li>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，记作 S(n) &#x3D; O(f(n))</li>
<li>分析算法主要讨论时间复杂度，一些缓存产品（Redis，Memcache）和算法（基数排序）使用空间换时间</li>
</ul>
<p><strong>量度</strong></p>
<p>一个算法的空间复杂度 S(n) 定义为该算法所耗费的存储空间，也是问题规模 n 的函数，渐进空间复杂度也简称为空间复杂度。空间复杂度（SpaceComplexity）是对一个算法在运行过程中临时占用存储空间大小的量度。</p>
<p>一个算法在计算机存储器上占用的存储空间，包括存储算法本身占用的存储空间，算法的输入输出数据锁占用的存储空间和算法在运行过程中临时占用的存储空间三个方面。</p>
<p><strong>分析</strong></p>
<p>一个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小，包括为参数表中形参变量分配的存储空间和为在函数体中定义的局部变量分配的存储空间两个部分。</p>
<p>如果一个算法是递归算法，空间复杂度为递归所使用的堆栈空间的大小，它大于等于一次调用所分配的临时存储空间的大小乘以被调用的次数（递归调用次数加 1，这个 1 表示开始进行的一次非递归调用）</p>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>稳定的算法在排序过程中不会改变元素彼此位置的相对次序，反之不稳定的排序算法经常会改变这个次序。稳定性算法中非常重要的影响选择的因素</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/074f4557c68fdca09bfd85362d956916_0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="074f4557c68fdca09bfd85362d956916_0B319B38-B70E-4118-B897-74EFA7E368F9"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/074f4557c68fdca09bfd85362d956916_0B319B38-B70E-4118-B897-74EFA7E368F9.png" class=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/2d459a95a47f713b48d5bbff117d2e33_1698577931965.png" alt="2d459a95a47f713b48d5bbff117d2e33_1698577931965"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/2d459a95a47f713b48d5bbff117d2e33_1698577931965.png" class=""></p>
<blockquote>
<p>部分文档参考自：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">10大经典排序</a></p>
</blockquote>
<h4 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h4><p>基本思想：</p>
<p><strong>冒泡排序</strong>（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个名词的由来很好理解，一般河水中的冒泡，水底刚冒出来的时候是比较小的，随着慢慢向水面浮起会逐渐增大，这物理规律我不作过多解释，大家只需要了解即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/659cd824749471cb4107d7e65be322d3_1698577909054.gif"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/659cd824749471cb4107d7e65be322d3_1698577909054.gif" class=""></p>
<p><strong>冒泡算法的运作规律如下：</strong></p>
<p><strong>1、</strong> 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p><strong>2、</strong> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数（也就是第一波冒泡完成）。</p>
<p><strong>3、</strong> 针对所有的元素重复以上的步骤，除了最后一个。</p>
<p><strong>4、</strong> 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p><strong>1、冒泡排序普通版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序普通版</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer [] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组中有len个元素，进行len次冒泡</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序改良版：</strong></p>
<p>如果说在一次冒泡中，没有发生相邻元素的交换，那说明待排序序列已经有序了，不管后面还剩下多少次冒泡，我们都不需要再进行冒泡下去了。这样是不是就减少冒泡的次数了呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序改良版</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 数组中的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer [] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 优化标识</span></span><br><span class="line">    <span class="comment">// 如果在某一次的冒泡过程中，没有位置交换说明已经排好序，直接break</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 数组中有len个元素，进行len次冒泡</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">       <span class="comment">// 如果有位置交换就重置标识为false</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次冒泡结束检查是否发生了数据交换</span></span><br><span class="line">        <span class="comment">// 如果没有发生数据交换，说明序列已经有序，不需要再继续冒泡了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第【&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;】次冒泡&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>冒泡排序解释：</strong></p>
<p>冒泡排序是由两个for循环构成，第一个for循环的变量 i 表示总共需要多少轮比较，第二个for循环的变量 j 表示每轮参与比较的元素下标【0,1，……，length-i】，因为每轮比较都会出现一个最大值放在最右边，所以每轮比较后的元素个数都会少一个，这也是为什么 j 的范围是逐渐减小的。相信大家理解之后快速写出一个冒泡排序并不难。</p>
<p><strong>冒泡排序性能分析：</strong></p>
<p>假设参与比较的数组元素个数为 N，则第一轮排序有 N-1 次比较，第二轮有 N-2 次，如此类推，这种序列的求和公式为：</p>
<p>（N-1）+（N-2）+…+1 &#x3D; N*（N-1）&#x2F;2</p>
<p>当N 的值很大时，算法比较次数约为 N2&#x2F;2次比较，忽略减1。</p>
<p>假设数据是随机的，那么每次比较可能要交换位置，可能不会交换，假设概率为50%，那么交换次数为 N2&#x2F;4。不过如果是最坏的情况，初始数据是逆序的，那么每次比较都要交换位置。</p>
<p>交换和比较次数都和N2 成正比。由于常数不算大 O 表示法中，忽略 2 和 4，那么冒泡排序运行都需要 O(N2) 时间级别。</p>
<p>其实无论何时，只要看见一个循环嵌套在另一个循环中，我们都可以怀疑这个算法的运行时间为 O(N2)级，外层循环执行 N 次，内层循环对每一次外层循环都执行N次（或者几分之N次）。这就意味着大约需要执行N2次某个基本操作。</p>
<blockquote>
<p>时间复杂度：最好O(n)；最坏O(n2)；平均O(n2)<br>空间复杂度：O(1)<br>稳定性：稳定</p>
</blockquote>
<h4 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h4><p>选择排序是每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/f0f6c05a6d64acea3965fb2da2ca0134_1698577910697.gif"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/f0f6c05a6d64acea3965fb2da2ca0134_1698577910697.gif" class=""></p>
<p>分为三步：</p>
<p><strong>1、</strong> 从待排序序列中，找到关键字最小的元素</p>
<p><strong>2、</strong> 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换</p>
<p><strong>3、</strong> 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] choiceSort (<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="comment">//总共要经过N-1轮比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="comment">//每轮需要比较的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span> ; j &lt; array.length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&lt;array[min])&#123;</span><br><span class="line">                min = j;<span class="comment">//记录目前能找到的最小值元素的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将找到的最小值和i位置所在的值进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(i != min)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = array[min];</span><br><span class="line">            array[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第 i轮排序的结果为</span></span><br><span class="line">        System.out.print(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮排序后的结果为:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>选择排序性能分析：</strong></p>
<p>选择排序和冒泡排序执行了相同次数的比较：N*（N-1）&#x2F;2，但是至多只进行了N次交换。</p>
<p>当N 值很大时，比较次数是主要的，所以和冒泡排序一样，用大O表示是O(N2) 时间级别。但是由于选择排序交换的次数少，所以选择排序无疑是比冒泡排序快的。当 N 值较小时，如果交换时间比选择时间大的多，那么选择排序是相当快的。</p>
<blockquote>
<p>时间复杂度：O(n2)<br>空间复杂度：O(1)<br>稳定性：不稳定</p>
</blockquote>
<h4 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h4><p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/fddb8006bc9ceb02d9a93d8c661acb14_1698577912850-1717654853755-4.gif"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/fddb8006bc9ceb02d9a93d8c661acb14_1698577912850-1717654853755-4.gif" class=""></p>
<p>插入排序还分为直接插入排序、二分插入排序、链表插入排序、希尔排序等等，这里我们只是以直接插入排序讲解，后面讲高级排序的时候会将其他的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertSort (<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">//从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; array.length ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> array[i];<span class="comment">//记录要插入的数据</span></span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; array[j-<span class="number">1</span>])&#123;<span class="comment">//从已经排序的序列最右边的开始比较，找到比其小的数</span></span><br><span class="line">            array[j] = array[j-<span class="number">1</span>];<span class="comment">//向后挪动</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j] = tmp;<span class="comment">//存在比其小的数，插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>插入排序性能分析：</strong></p>
<p>在第一轮排序中，它最多比较一次，第二轮最多比较两次，一次类推，第N轮，最多比较N-1次。因此有 1+2+3+…+N-1 &#x3D; N*（N-1）&#x2F;2。</p>
<p>假设在每一轮排序发现插入点时，平均只有全体数据项的一半真的进行了比较，我们除以2得到：N*（N-1）&#x2F;4。用大O表示法大致需要需要 O(N2) 时间级别。</p>
<p>复制的次数大致等于比较的次数，但是一次复制与一次交换的时间耗时不同，所以相对于随机数据，插入排序比冒泡快一倍，比选择排序略快。</p>
<p>这里需要注意的是，如果要进行逆序排列，那么每次比较和移动都会进行，这时候并不会比冒泡排序快。</p>
<blockquote>
<p>最好情况O(n)；最坏情况O(n2)；平均时间复杂度为：O(n2)<br>空间复杂度：O(1)<br>稳定性：稳定</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>上面讲的三种排序，<strong>冒泡、选择、插入</strong>用大 O 表示法都需要 O(N2) 时间级别。一般不会选择冒泡排序，虽然冒泡排序书写是最简单的，但是平均性能是没有选择排序和插入排序好的。</p>
<p>选择排序把交换次数降低到最低，但是比较次数还是挺大的。当数据量小，并且交换数据相对于比较数据更加耗时的情况下，可以应用选择排序。</p>
<p>在大多数情况下，假设数据量比较小或基本有序时，插入排序是三种算法中最好的选择。</p>
<blockquote>
<p>下面我们会讲解高级排序，大O表示法的时间级别将比O(N2)小。</p>
</blockquote>
<h4 id="4、希尔排序-shell-Sort"><a href="#4、希尔排序-shell-Sort" class="headerlink" title="4、希尔排序(shell Sort)"></a>4、希尔排序(shell Sort)</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序基本思想：对待排记录序列先作“宏观”调整，再作“微观”调整。即先将整个待排记录序列分割成若干个子序列分别进行<strong>直接插入排序</strong>，待整个序列中的记录“基本有序“时，再对全体记录进行一次直接插入排序，就可以完成整个的排序工作。</p>
<p><strong>算法步骤</strong></p>
<p><strong>1、</strong> 选择一个增量序列t1，t2，……，tk，其中ti&gt;tj,tk&#x3D;1；<br><strong>2、</strong> 按增量序列个数k，对序列进行k趟排序；<br><strong>3、</strong> 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度；</p>
<p>举例：[16，25，12，30，47，11，23，36，9，18，31]，共11个元素</p>
<p>第一趟：增量d&#x3D;5, 我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>，<span class="number">25</span>，<span class="number">12</span>，<span class="number">30</span>，<span class="number">47</span></span><br><span class="line"><span class="number">11</span>，<span class="number">23</span>，<span class="number">36</span>， <span class="number">9</span>，<span class="number">18</span></span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>

<p>然后每列排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>，<span class="number">23</span>，<span class="number">12</span>，<span class="number">9</span>， <span class="number">18</span></span><br><span class="line"><span class="number">16</span>，<span class="number">25</span>，<span class="number">36</span>，<span class="number">30</span>，<span class="number">47</span></span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>

<p>所以得到的序列为 [11，23，12，9， 18，16，25，36，30，47，31]</p>
<p>第二趟：增量d&#x3D;2，同理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>，<span class="number">23</span>，</span><br><span class="line"><span class="number">12</span>， <span class="number">9</span>， </span><br><span class="line"><span class="number">18</span>，<span class="number">16</span>，</span><br><span class="line"><span class="number">25</span>，<span class="number">36</span>，</span><br><span class="line"><span class="number">30</span>，<span class="number">47</span>，</span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>

<p>按列排序并连接起来得：[11, 9, 12, 16, 18, 23, 25, 36, 30, 47, 31]</p>
<p>第三趟：增量d&#x3D;1，即以1步长进行排序(即是简单的插入排序)</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(arr == <span class="literal">null</span> | arr.length ==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> temp;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> arr.length/<span class="number">2</span>; delta&gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;  <span class="comment">//对每个增量进行一次排序</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=delta; i&lt;arr.length; i++)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=i; j&gt;=delta &amp;&amp; arr[j]&lt;arr[j-delta]; j-=delta)&#123;<span class="comment">//注意每个地方增量和差值都是delta</span></span><br><span class="line">                   swap(arr, j-delta, j);</span><br><span class="line">                     <span class="comment">// temp = arr[j-delta];</span></span><br><span class="line">                    <span class="comment">//  arr[j-delta] = arr[j];</span></span><br><span class="line">                    <span class="comment">//  arr[j] = temp;</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>时空复杂度</strong></p>
<p>希尔排序在效率上比直接插入排序有很大的改进，但对希尔排序进行时间性能分析很难，原因是何种步长序列最优难以判定，通常认为其时间复杂度为O(n1.5)。</p>
<p>希尔排序的增量序列可以有多种取法，较优的增量序列的共同特征如下。</p>
<ul>
<li>最后一个增量必须为。</li>
<li>应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。</li>
</ul>
<blockquote>
<p>时间效率： 当增量序列为d(k)&#x3D;2t-k+1-1时，时间复杂度为O(n1.5）。<br>空间效率： O（1）<br>算法的稳定性： 不稳定</p>
</blockquote>
<h4 id="5、归并排序（MergeSort"><a href="#5、归并排序（MergeSort" class="headerlink" title="5、归并排序（MergeSort)"></a>5、归并排序（MergeSort)</h4><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>典型的是二路合并排序，将原始数据集分成两部分(不一定能够均分)，分别对它们进行排序，然后将排序后的子数据集进行合并，这是典型的分治法策略。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/a7e36b6c0faacb0faaff73d871b3102d_1698577916888.gif"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/a7e36b6c0faacb0faaff73d871b3102d_1698577916888.gif" class=""></p>
<p><strong>算法步骤</strong></p>
<p><strong>1、</strong> 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br><strong>2、</strong> 设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br><strong>3、</strong> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br><strong>4、</strong> 重复步骤3直到某一指针达到序列尾；<br><strong>5、</strong> 将另一序列剩下的所有元素直接复制到合并序列尾；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577914596.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577914596.png" class=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577915873.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577915873.png" class=""></p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        mSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;  <span class="comment">//left + ((right - left) &gt;&gt; 1);</span></span><br><span class="line">            mSort(arr, left, middle);  <span class="comment">//左子数组</span></span><br><span class="line">            mSort(arr, middle+<span class="number">1</span>, right);  <span class="comment">//右子数组</span></span><br><span class="line">            merge(arr, left, middle, right);  <span class="comment">//合并两个子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> middle, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> middle+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将记录由小到大地放进temp数组</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                t[k++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=middle)&#123;</span><br><span class="line">            t[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">            t[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">//把数据复制回原数组</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            arr[left+i] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        mergeSort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong></p>
<p>在归并排序中，进行一趟归并需要的关键字比较次数和数据元素移动次数最多为<strong>n</strong>，需要归并的趟数<strong>log2n</strong>，故归并排序的时间复杂度为O(nlog2n)。归并排序需要长度等于序列长度为n的辅助存储单元，故归并排序的空间复杂度为O(n)。归并排序是稳定的排序算法。</p>
<blockquote>
<p>时间复杂度：O(nlog2n)<br>空间复杂度：O(n)<br>稳定性：稳定</p>
</blockquote>
<p>6、快速排序（quickSort）</p>
<p>快速排序是图灵奖得主C.R.A Hoare于1960年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为<a target="_blank" rel="noopener" href="https://www.wikiwand.com/en/Quicksort">分治法（Divide-and-Conquer Method）</a></p>
<blockquote>
<p>分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题组合为原问题的解。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/444790523fedefaf65fecfd6ff24d42e_1698577918540.gif"> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/444790523fedefaf65fecfd6ff24d42e_1698577918540.gif" class=""></p>
<p><strong>算法步骤</strong></p>
<p>利用分治法可将快速排序分为三步：</p>
<p><strong>1、</strong> 从数列中挑出一个元素作为“基准”（pivot）；<br><strong>2、</strong> 分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边这个操作称为“分区操作”，分区操作结束后，基准元素所处的位置就是最终排序后它的位置；<br><strong>3、</strong> 再对“基准”左右两边的子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止；</p>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(arr, l, r);</span><br><span class="line">            quickSort(arr, l, p-<span class="number">1</span>);</span><br><span class="line">            quickSort(arr, p+<span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">//设定基准值(pivot)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[l]; <span class="comment">//选基准值为首位置的元素</span></span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[r]&gt;=pivot) r--;</span><br><span class="line">            arr[l] = arr[r]; <span class="comment">//交换比基准小的记录到左端</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; arr[l]&lt;=pivot) l++;</span><br><span class="line">            arr[r] = arr[l]; <span class="comment">//交换比基准大的记录到右端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//扫描完成，基准到位</span></span><br><span class="line">        arr[l] = pivot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        quickSort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一种优化方式：分区时可能中间边界存在大量相同元素，可取其边界再划分；同时选基准时，随机选取，减小偶然性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//swap(arr, l + (int) (Math.random() * (r - l + 1)), r);  //设为随机快排</span></span><br><span class="line">            <span class="type">int</span>[] p = partition(arr, l, r);</span><br><span class="line">            quickSort(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] partition(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> l - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;  <span class="comment">//相当最右边位置的元素为基准</span></span><br><span class="line">                swap(arr, ++less, l++);  <span class="comment">//l快指针(当前位置指针)，less慢指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;</span><br><span class="line">                swap(arr, --more, l); <span class="comment">//l指向位置不变</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// == 基准</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        quickSort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>时空复杂度</strong></p>
<blockquote>
<p>时间复杂度：最好O(nlog2n)；平均O(nlog2n)，最坏：O(n2)<br>空间复杂度：O(log2n)<br>稳定性：不稳定</p>
</blockquote>
<h4 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<p><strong>1、</strong> 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br><strong>2、</strong> 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<p>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。</p>
<p>如下图，是一个堆和数组的相互关系：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577919978.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577919978.png" class=""></p>
<p>对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标(源点从1开始)：</p>
<ul>
<li>Parent(i) &#x3D; floor(i&#x2F;2)，i 的父节点下标</li>
<li>Left(i) &#x3D; 2i，i 的左子节点下标</li>
<li>Right(i) &#x3D; 2i + 1，i 的右子节点下标</li>
</ul>
<p><strong>算法步骤</strong></p>
<p>堆排序中经常用到的两种基本动作为：建堆和筛选</p>
<p><strong>1、</strong> 创建一个堆H[0……n-1]；<br><strong>2、</strong> 把堆首（最大值）和堆尾互换；<br><strong>3、</strong> 把堆的尺寸缩小1，并调用shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br><strong>4、</strong> 重复步骤2，直到堆的尺寸为1；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577920590.gif" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577920590.gif" class=""></p>
<p><strong>代码实现</strong></p>
<p>大顶堆排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 将待排序的序列构建成一个大顶堆  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            heapAdjust(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapAdjust</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span>*i+<span class="number">1</span>;  <span class="comment">//i节点的左孩子节点</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;n)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; n &amp;&amp; arr[left+<span class="number">1</span>]&gt;arr[left] ? left+<span class="number">1</span> : left; <span class="comment">//如果有右节点，比较左右并找出最大节点的位置 </span></span><br><span class="line">            largest = arr[largest] &gt; arr[i] ? largest : i;  <span class="comment">// 父节点i与最大子节点比较，并返回最大节点的位置</span></span><br><span class="line">            <span class="keyword">if</span>(largest == i) <span class="keyword">break</span>; </span><br><span class="line">            </span><br><span class="line">            swap(arr, largest, i); <span class="comment">//有子节点比父节点大的，则交换</span></span><br><span class="line">            i = largest;  <span class="comment">//下沉</span></span><br><span class="line">            left = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">59</span>,<span class="number">18</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时空复杂度</strong></p>
<p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p>
<blockquote>
<p>时间复杂度：O(nlog2n)<br>假设节点数为n,所以需要进行n - 1次调换，也就是需要n-1次堆调整，每次堆调整的时间复杂度为O(logn) ，那么总的时间复杂度就是(n - 1)O(logn) &#x3D; O(nlogn)</p>
</blockquote>
<h4 id="8、计数排序"><a href="#8、计数排序" class="headerlink" title="8、计数排序"></a>8、计数排序</h4><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为 O(n+k)。</p>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序只适合元素是整数，小规模的排序。</p>
<p> <strong>算法步骤</strong></p>
<p><strong>1、</strong> 花O(n)的时间扫描一下整个待排序列，获取最小值min和最大值max；<br><strong>2、</strong> 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br><strong>3、</strong> 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br><strong>4、</strong> 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577927300.gif" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577927300.gif" class=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;  <span class="comment">//优化方法:长度max-min+1,放入bucket时减min,倒时加回min</span></span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> value: arr)  <span class="comment">//计数</span></span><br><span class="line">            bucket[value]++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//倒回原arr</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;bucketLen; j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(bucket[j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> value : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxValue &lt; value)</span><br><span class="line">                maxValue = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">59</span>,<span class="number">18</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        countingSort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] countSort1(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出数组中的最大最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">        min = Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> help[] = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找出每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mapPos</span> <span class="operator">=</span> arr[i] - min;</span><br><span class="line">        help[mapPos]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(help[i]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr[index++] = i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View Code</p>
<p><strong>时空复杂度</strong></p>
<p>n个0 到 k 之间的整数时，它的运行时间是 O(n + k)</p>
<h4 id="9、桶排序"><a href="#9、桶排序" class="headerlink" title="9、桶排序"></a>9、桶排序</h4><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<p><strong>1、</strong> 在额外空间充足的情况下，尽量增大桶的数量；<br><strong>2、</strong> 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中；</p>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p> <strong>算法步骤</strong></p>
<p><strong>1、</strong> 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶；<br><strong>2、</strong> 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序；<br><strong>3、</strong> 将各个桶中的数据有序的合并起来；</p>
<blockquote>
<p>动画参考 <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles&#x2F;visualization&#x2F;Algorithms.html</a></p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InsertSort</span> <span class="variable">insertSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertSort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时空复杂度</strong></p>
<p>O(n+k)</p>
<p>(1)什么时候最快</p>
<p>当输入的数据可以均匀的分配到每一个桶中。</p>
<p>(2)什么时候最慢</p>
<p>当输入的数据被分配到了同一个桶中。</p>
<h4 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h4><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<ul>
<li>MSD（Most significant digital） 从最左侧高位开始进行排序。</li>
<li>LSD （Least significant digital）从最右侧低位开始进行排序。</li>
</ul>
<p> <strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>基数排序有两种方法：</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p> <strong>算法步骤</strong></p>
<p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<p>步骤：</p>
<p>①.取得数组中的最大数，并取得位数；<br>②.arr为原始数组，从最低位开始取每个位组成radix数组；<br>③.对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<p>通过基数排序对数组{53, 3, 542, 748, 14, 214, 154, 63, 616}，它的示意图如下：</p>
<p>[<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577930068.png" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577930068.png" class="">]<a target="_blank" rel="noopener" href="https://images0.cnblogs.com/i/497634/201403/161837176365265.jpg">nbsp_nbsp 15</a></p>
<p>在上图中，首先将所有待比较树脂统一为统一位数长度，接着从最低位开始，依次进行排序。<br><strong>1、</strong> 按照个位数进行排序；<br><strong>2、</strong> 按照十位数进行排序；<br><strong>3、</strong> 按照百位数进行排序；<br>排序后，数列就变成了一个有序序列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./data-structure-and-algorithm/1698577930743.gif" alt=" "> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/01/03/data-structure-and-algorithm/1698577930743.gif" class=""></p>
<p> <strong>代码实现</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>时空复杂度</strong></p>
<p>d为位数，r 为基数，n 为原数组个数。 在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d * (n + r))。</p>
<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="1、符号表"><a href="#1、符号表" class="headerlink" title="1、符号表"></a>1、符号表</h4><h4 id="2、二叉查找树"><a href="#2、二叉查找树" class="headerlink" title="2、二叉查找树"></a>2、二叉查找树</h4><h4 id="3、平衡查找树"><a href="#3、平衡查找树" class="headerlink" title="3、平衡查找树"></a>3、平衡查找树</h4><h4 id="4、散列表"><a href="#4、散列表" class="headerlink" title="4、散列表"></a>4、散列表</h4><blockquote>
<p>查找部分，参考文章 </p>
</blockquote>
<h4 id="二分查找算法（代码实现）"><a href="#二分查找算法（代码实现）" class="headerlink" title="二分查找算法（代码实现）"></a>二分查找算法（代码实现）</h4><p>二分查找又称折半查找，<strong>优点是比较次数少，查找速度快</strong>，平均性能好，占用系统内存较少；其<strong>缺点是要求待查表为有序表</strong>，<strong>且插入删除困难</strong>。这个是基础，最简单的查找算法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> srcArray[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">81</span>, <span class="number">95</span>, <span class="number">101</span>&#125;;</span><br><span class="line">        System.out.println(binSearch(srcArray, <span class="number">95</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找针对的是有序的数组</span></span><br><span class="line"><span class="comment">     * 二分查找普通循环实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcArray 有序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      查找元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> srcArray[], <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (srcArray.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出首尾判断key是否在指定的srcArray中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> srcArray[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> srcArray[srcArray.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (key &lt; first || key &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> srcArray.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key == srcArray[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分核心逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> srcArray.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (startIndex &lt;= endIndex) &#123;</span><br><span class="line">            mid = (endIndex - startIndex) / <span class="number">2</span> + startIndex;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">                endIndex = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">                startIndex = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>
</blockquote>
<h4 id="2-递归实现二分查找"><a href="#2-递归实现二分查找" class="headerlink" title="2.递归实现二分查找"></a>2.递归实现二分查找</h4><p>递归简单理解就是方法自身调用自身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">       System.out.println(binSearch(srcArray, <span class="number">0</span>,<span class="number">15</span>,<span class="number">28</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二分查找递归实现</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> srcArray  有序数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> start 数组低地址下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> end   数组高地址下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key  查找元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 查找元素不存在返回-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> srcArray[], <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start) / <span class="number">2</span> + start;</span><br><span class="line">       <span class="keyword">if</span> (srcArray[mid] == key) &#123;</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">           <span class="keyword">return</span> binSearch(srcArray, mid + <span class="number">1</span>, end, key);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">           <span class="keyword">return</span> binSearch(srcArray, start, mid - <span class="number">1</span>, key);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>递归几乎会经常用到，需要注意的一点是：递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>
</blockquote>
<h3 id="图（Graph）"><a href="#图（Graph）" class="headerlink" title="图（Graph）"></a>图（Graph）</h3><h4 id="1、无向图"><a href="#1、无向图" class="headerlink" title="1、无向图"></a>1、无向图</h4><h4 id="2、有向图"><a href="#2、有向图" class="headerlink" title="2、有向图"></a>2、有向图</h4><h4 id="3、最小生成树"><a href="#3、最小生成树" class="headerlink" title="3、最小生成树"></a>3、最小生成树</h4><h4 id="4、最短路径算法"><a href="#4、最短路径算法" class="headerlink" title="4、最短路径算法"></a>4、最短路径算法</h4><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1、字符串排序"><a href="#1、字符串排序" class="headerlink" title="1、字符串排序"></a>1、字符串排序</h4><h4 id="2、-单词查找"><a href="#2、-单词查找" class="headerlink" title="2、 单词查找"></a>2、 单词查找</h4><h4 id="3、-KMP查找算法"><a href="#3、-KMP查找算法" class="headerlink" title="3、 KMP查找算法"></a>3、 KMP查找算法</h4><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>见 详细专题贴</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xeons.cn">Calico</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xeons.cn/2023/01/03/data-structure-and-algorithm/">http://xeons.cn/2023/01/03/data-structure-and-algorithm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xeons.cn" target="_blank">Calico's Space</a>！</span></div></div><script>function setClipboardText(event){
    let clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) { return; }
    event.preventDefault();
    let text = window.getSelection().toString();
    if (text) {
        event.preventDefault();
        var copyright = "\n\n---\n著作权归 Calico 所有 \n原文链接: http://xeons.cn/2023/01/03/data-structure-and-algorithm/";
        clipboardData.setData('text/plain', text + copyright);
    }
};
var contents = document.getElementsByClassName("post");
contents[0].addEventListener('copy',function(e){
    setClipboardText(e);
});</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/2023/01/03/data-structure-and-algorithm/logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wxpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wxpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/03/spring-guide/" title="spring 文档手册"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/03/03/spring-guide/spring.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">spring 文档手册</div></div></a></div><div class="next-post pull-right"><a href="/2020/04/10/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/1gneicun1yishuju/algorithm_complexity_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">1g内存如何存储1亿数据</div></div></a></div><div><a href="/2024/04/09/40yiqqhaoquchong/" title="上亿号码去重方案"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/40yiqqhaoquchong/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">上亿号码去重方案</div></div></a></div><div><a href="/2024/04/09/alibaba_seata/" title="seate中的tcc"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/alibaba_seata/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">seate中的tcc</div></div></a></div><div><a href="/2024/04/09/cpu100100/" title="cpu打到100的分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/cpu100100/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">cpu打到100的分析</div></div></a></div><div><a href="/2024/04/09/24locks/" title="java中的各种锁"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/24locks/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">java中的各种锁</div></div></a></div><div><a href="/2024/04/09/cas/" title="java中CAS"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/cas/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">java中CAS</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTczMi8zNjE5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Calico</div><div class="author-info__description">It's my blog，Record everything！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xeonsuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xeonsuo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://weibo.com/xeons" target="_blank" title="微博"><i class="fab fa-weibo" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xeon511@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">python、aiAgent 进化中...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">数据结构的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">线性数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text">1. 数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">2. 线性表(链表)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%88-%EF%BC%88stack%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3. 栈 （stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97"><span class="toc-number">2.4.</span> <span class="toc-text">4. 队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%B2"><span class="toc-number">2.5.</span> <span class="toc-text">5. 串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">非线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">1、多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">3.2.</span> <span class="toc-text">2、集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text">3、树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%80%E5%A4%9A%E5%90%AB%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%A0%91%E7%A7%B0%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%82"><span class="toc-number">3.3.1.</span> <span class="toc-text">2) 二叉树：每个节点最多含有两个子节点的树称为二叉树。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.0.1.</span> <span class="toc-text">树的遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Hash"><span class="toc-number">4.1.</span> <span class="toc-text">4、Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84hash%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">1)  常见的hash函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.1.2.</span> <span class="toc-text">2) 哈希冲突的解决</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.</span> <span class="toc-text">5.各个数据结构的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86"><span class="toc-number">5.</span> <span class="toc-text">排序算法的评价标准</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">1、冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2、选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">3、插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-shell-Sort"><span class="toc-number">6.4.</span> <span class="toc-text">4、希尔排序(shell Sort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88MergeSort"><span class="toc-number">6.5.</span> <span class="toc-text">5、归并排序（MergeSort)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">7、堆排序（Heap Sort）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">6.7.</span> <span class="toc-text">8、计数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.</span> <span class="toc-text">9、桶排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">6.9.</span> <span class="toc-text">10、基数排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">1、符号表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">2、二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">3、平衡查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">7.4.</span> <span class="toc-text">4、散列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%88%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">二分查找算法（代码实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">7.6.</span> <span class="toc-text">2.递归实现二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%EF%BC%88Graph%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">图（Graph）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">8.1.</span> <span class="toc-text">1、无向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">8.2.</span> <span class="toc-text">2、有向图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">3、最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">4、最短路径算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F"><span class="toc-number">9.1.</span> <span class="toc-text">1、字符串排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81-%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">9.2.</span> <span class="toc-text">2、 单词查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81-KMP%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">3、 KMP查找算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">布隆过滤器</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/ai-appdev1/" title="AI之 应用开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/11/ai-appdev1/image-20250414235122630.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 应用开发"/></a><div class="content"><a class="title" href="/2024/09/11/ai-appdev1/" title="AI之 应用开发">AI之 应用开发</a><time datetime="2024-09-11T06:45:07.000Z" title="发表于 2024-09-11 14:45:07">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/ai-prompt/" title="AI之 提示词"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/11/ai-prompt/image-20250414235122630.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 提示词"/></a><div class="content"><a class="title" href="/2024/09/11/ai-prompt/" title="AI之 提示词">AI之 提示词</a><time datetime="2024-09-11T06:45:07.000Z" title="发表于 2024-09-11 14:45:07">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/ai-pandas1/" title="AI之 panda"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/09/ai-pandas1/e9e1d53513bac92c583f77534da579f7_9121a50daa7413dfe6ff9a47f91a0ad9_fullsize.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 panda"/></a><div class="content"><a class="title" href="/2024/09/09/ai-pandas1/" title="AI之 panda">AI之 panda</a><time datetime="2024-09-09T06:45:07.000Z" title="发表于 2024-09-09 14:45:07">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/ai-python1/" title="AI之 python 基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/09/ai-python1/algorithm_complexity_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 python 基础"/></a><div class="content"><a class="title" href="/2024/09/09/ai-python1/" title="AI之 python 基础">AI之 python 基础</a><time datetime="2024-09-09T05:45:07.000Z" title="发表于 2024-09-09 13:45:07">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/1gneicun1yishuju/algorithm_complexity_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1g内存如何存储1亿数据"/></a><div class="content"><a class="title" href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据">1g内存如何存储1亿数据</a><time datetime="2024-04-09T06:45:07.000Z" title="发表于 2024-04-09 14:45:07">2024-04-09</time></div></div></div></div></div></div></main><footer id="footer" style="background: none"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Calico</div><div class="footer_custom_text"><a href="icp"><span>Create By hexo,butterfly</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>