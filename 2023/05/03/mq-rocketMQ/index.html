<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>消息队列-rocketMQ | Calico's Space</title><meta name="author" content="Calico"><meta name="copyright" content="Calico"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="官网 概念RocketMQ 的基本概念1 消息（Message） 消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。 2 主题（Topic）    Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1一个生产者可以同">
<meta property="og:type" content="article">
<meta property="og:title" content="消息队列-rocketMQ">
<meta property="og:url" content="http://xeons.cn/2023/05/03/mq-rocketMQ/index.html">
<meta property="og:site_name" content="Calico&#39;s Space">
<meta property="og:description" content="官网 概念RocketMQ 的基本概念1 消息（Message） 消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。 2 主题（Topic）    Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。 topic:message 1:n message:topic 1:1一个生产者可以同">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://xeons.cn/2023/05/03/mq-rocketMQ/logo.jpg">
<meta property="article:published_time" content="2023-05-02T16:00:00.000Z">
<meta property="article:author" content="Calico">
<meta property="article:tag" content="java">
<meta property="article:tag" content="mq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://xeons.cn/2023/05/03/mq-rocketMQ/logo.jpg"><link rel="shortcut icon" href="/images/calico-ss.png"><link rel="canonical" href="http://xeons.cn/2023/05/03/mq-rocketMQ/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f97e3791752fae830e3db5ba194c6cb";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '消息队列-rocketMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-07 22:15:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Calico's Space" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/loading_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Calico's Space"><span class="site-name">Calico's Space</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list hide"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/demopage/"><i class="fa-fw fas fa-music"></i><span> Theme测试页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">消息队列-rocketMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-02T16:00:00.000Z" title="发表于 2023-05-03 00:00:00">2023-05-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/">dev</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/java/mq/">mq</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/dev/java/mq/rocketmq/">rocketmq</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>82分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="消息队列-rocketMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs">官网</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h4 id="RocketMQ-的基本概念"><a href="#RocketMQ-的基本概念" class="headerlink" title="RocketMQ 的基本概念"></a>RocketMQ 的基本概念</h4><p>1 消息（Message）</p>
<p>消息是指，消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主<br>题。</p>
<p>2 主题（Topic）</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600025288.png" class="">

<p>Topic表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行<br>消息订阅的基本单位。 topic:message 1:n message:topic 1:1<br>一个生产者可以同时发送多种Topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅<br>和消费一种Topic的消息。 producer:topic 1:n consumer:topic 1:1</p>
<p>3 标签（Tag）</p>
<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业<br>务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提<br>供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。<br>Topic是消息的一级分类，Tag是消息的二级分类。<br>Topic：货物<br>tag&#x3D;上海<br>tag&#x3D;江苏<br>tag&#x3D;浙江<br>——- 消费者 —–<br>topic&#x3D;货物 tag &#x3D; 上海<br>topic&#x3D;货物 tag &#x3D; 上海|浙江<br>topic&#x3D;货物 tag &#x3D; *</p>
<p>4 队列（Queue）</p>
<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一<br>个Topic的Queue也被称为一个Topic中消息的分区（Partition）。<br>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同<br>一个消费者组中的多个消费者同时消费。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600027490.png" class="">

<p>在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在RocketMQ<br>中，分片指的是存放相应Topic的Broker。每个分片中会创建出相应数量的分区，即Queue，每个<br>Queue的大小都是相同的。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600030121.png" class="">

<p>5 消息标识（MessageId&#x2F;Key）</p>
<p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。<br>不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId（msgId)，<br>当消息到达Broker后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都<br>称为消息标识。</p>
<ul>
<li>msgId：由producer端生成，其生成规则为：<br>producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode +<br>当前时间 + AutomicInteger自增计数器</li>
<li>offsetMsgId：由broker端生成，其生成规则为： brokerIp + 物理分区的offset（Queue中的<br>偏移量）</li>
<li>key：由用户指定的业务相关的唯一标识</li>
</ul>
<h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>RocketMQ 的系统架构</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600030774.png" class="">
<p>RocketMQ架构上主要分为四部分构成：</p>
<p>1 Producer</p>
<p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投<br>递，投递的过程支持快速失败并且低延迟。</p>
<blockquote>
<p>例如，业务系统产生的日志写入到MQ的过程，就是消息生产的过程<br>再如，电商平台中用户提交的秒杀请求写入到MQ的过程，就是消息生产的过程</p>
</blockquote>
<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产<br>者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>
<p>2 Consumer</p>
<p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务<br>处理。</p>
<blockquote>
<p>例如，QoS系统从MQ中读取日志，并对日志进行解析处理的过程就是消息消费的过程。<br>再如，电商平台的业务系统从MQ中读取到秒杀请求，并对请求进行处理的过程就是消息消费的<br>过程。</p>
</blockquote>
<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消<br>费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现<br>负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注<br>意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可<br>以接着消费原Consumer消费的Queue）的目标变得非常容易。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600032722.png" class=""><br>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的<br>Consumer将不能消费消息。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600034630.png" class=""><br>不过，一个Topic类型的消息可以被多个消费者组同时消费。</p>
<blockquote>
<p>注意，<br>1）消费者组只能消费一个Topic的消息，不能同时消费多个Topic消息<br>2）一个消费者组中的消费者必须订阅完全相同的Topic</p>
</blockquote>
<p>3 Name Server</p>
<p>功能介绍</p>
<p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。<br>RocketMQ的思想来自于Kafka，而Kafka是依赖了Zookeeper的。所以，在RocketMQ的早期版本，即在<br>MetaQ v1.0与v2.0版本中，也是依赖于Zookeeper的。从MetaQ v3.0，即RocketMQ开始去掉了<br>Zookeeper依赖，使用了自己的NameServer。</p>
<p>主要包括两个功能：</p>
<ul>
<li>Broker管理：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测<br>机制，检查Broker是否还存活</li>
<li>路由信息管理：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列<br>信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消<br>息的投递和消费</li>
</ul>
<p>路由注册</p>
<p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各<br>个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在<br>Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在<br>NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。</p>
<blockquote>
<p>注意，这是与其它像zk、Eureka、Nacos等注册中心不同的地方。<br>这种NameServer的无状态方式，有什么优缺点：<br>优点：NameServer集群搭建简单，扩容简单。<br>缺点：对于Broker，必须明确指出所有NameServer地址。否则未指出的将不会去注册。也正因<br>为如此，NameServer并不能随便扩容。因为，若Broker不重新配置，新增的NameServer对于<br>Broker来说是不可见的，其不会向这个NameServer进行注册。</p>
</blockquote>
<p>Broker节点为了证明自己是活着的，为了维护与NameServer间的长连接，会将最新的信息以心跳包的<br>方式上报给NameServer，每30秒发送一次心跳。心跳包中包含 BrokerId、Broker地址(IP+Port)、<br>Broker名称、Broker所属集群名称等等。NameServer在接收到心跳包后，会更新心跳时间戳，记录这<br>个Broker的最新存活时间。</p>
<p>路由剔除</p>
<p>由于Broker关机、宕机或网络抖动等原因，NameServer没有收到Broker的心跳，NameServer可能会将<br>其从Broker列表中剔除。</p>
<p>NameServer中有⼀个定时任务，每隔10秒就会扫描⼀次Broker表，查看每一个Broker的最新心跳时间<br>戳距离当前时间是否超过120秒，如果超过，则会判定Broker失效，然后将其从Broker列表中剔除。</p>
<blockquote>
<p>扩展：对于RocketMQ日常运维工作，例如Broker升级，需要停掉Broker的工作。OP需要怎么<br>做？<br>OP需要将Broker的读写权限禁掉。一旦client(Consumer或Producer)向broker发送请求，都会收<br>到broker的NO_PERMISSION响应，然后client会进行对其它Broker的重试。<br>当OP观察到这个Broker没有流量后，再关闭它，实现Broker从NameServer的移除。<br>OP：运维工程师<br>SRE：Site Reliability Engineer，现场可靠性工程师</p>
</blockquote>
<p>路由发现</p>
<p>RocketMQ的路由发现采用的是Pull模型。当Topic路由信息出现变化时，NameServer不会主动推送给<br>客户端，而是客户端定时拉取主题最新的路由。默认客户端每30秒会拉取一次最新的路由。</p>
<blockquote>
<p>扩展：<br>1）Push模型：推送模型。其实时性较好，是一个“发布-订阅”模型，需要维护一个长连接。而<br>长连接的维护是需要资源成本的。该模型适合于的场景：<br>实时性要求较高<br>Client数量不多，Server数据变化较频繁<br>2）Pull模型：拉取模型。存在的问题是，实时性较差。<br>3）Long Polling模型：长轮询模型。其是对Push与Pull模型的整合，充分利用了这两种模型的优<br>势，屏蔽了它们的劣势。</p>
</blockquote>
<p>客户端NameServer选择策略</p>
<blockquote>
<p>这里的客户端指的是Producer与Consumer</p>
</blockquote>
<p>客户端在配置时必须要写上NameServer集群的地址，那么客户端到底连接的是哪个NameServer节点<br>呢？客户端首先会生产一个随机数，然后再与NameServer节点数量取模，此时得到的就是所要连接的<br>节点索引，然后就会进行连接。如果连接失败，则会采用round-robin策略，逐个尝试着去连接其它节<br>点。</p>
<p>首先采用的是随机策略进行的选择，失败后采用的是轮询策略。</p>
<blockquote>
<p>扩展：Zookeeper Client是如何选择Zookeeper Server的？<br>简单来说就是，经过两次Shuf􀃦e，然后选择第一台Zookeeper Server。<br>详细说就是，将配置文件中的zk server地址进行第一次shuf􀃦e，然后随机选择一个。这个选择出<br>的一般都是一个hostname。然后获取到该hostname对应的所有ip，再对这些ip进行第二次<br>shuf􀃦e，从shuf􀃦e过的结果中取第一个server地址进行连接。</p>
</blockquote>
<p>4 Broker</p>
<p>功能介绍</p>
<p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从<br>生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括<br>消费者组消费进度偏移offset、主题、队列等。</p>
<blockquote>
<p>Kafka 0.8版本之后，offset是存放在Broker中的，之前版本是存放在Zookeeper中的。</p>
</blockquote>
<p>模块构成</p>
<p>下图为Broker Server的功能模块示意图。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600037003.png" class=""></p>
<ul>
<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模<br>块构成。</li>
<li>Client Manager：客户端管理器。负责接收、解析客户端(Producer&#x2F;Consumer)请求，管理客户端。例<br>如，维护Consumer的Topic订阅信息</li>
<li>Store Service：存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提<br>供根据Message Key对消息进行快速查询的功能。</li>
</ul>
<p>集群部署</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600037500.png" class="">
<p>为了增强Broker性能与吞吐量，Broker一般都是以集群形式出现的。各集群节点中可能存放着相同<br>Topic的不同Queue。不过，这里有个问题，如果某Broker节点宕机，如何保证数据不丢失呢？其解决<br>方案是，将每个Broker集群节点进行横向扩展，即将Broker节点再建为一个HA集群，解决单点问题。</p>
<p>Broker节点集群是一个主从集群，即集群中具有Master与Slave两种角色。Master负责处理读写操作请<br>求，Slave负责对Master中的数据进行备份。当Master挂掉了，Slave则会自动切换为Master去工作。所<br>以这个Broker集群是主备集群。一个Master可以包含多个Slave，但一个Slave只能隶属于一个Master。<br>Master与Slave 的对应关系是通过指定相同的BrokerName、不同的BrokerId 来确定的。BrokerId为0表<br>示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信<br>息到所有NameServer。</p>
<p>5 工作流程</p>
<p>具体流程</p>
<p>1）启动NameServer，NameServer启动后开始监听端口，等待Broker、Producer、Consumer连接。<br>2）启动Broker时，Broker会与所有的NameServer建立并保持长连接，然后每30秒向NameServer定时<br>发送心跳包。<br>3）发送消息前，可以先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，当然，在创<br>建Topic时也会将Topic与Broker的关系写入到NameServer中。不过，这步是可选的，也可以在发送消<br>息时自动创建Topic。<br>4）Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获<br>取路由信息，即当前发送的Topic消息的Queue与Broker的地址（IP+Port）的映射关系。然后根据算法<br>策略从队选择一个Queue，与队列所在的Broker建立长连接从而向Broker发消息。当然，在获取到路由<br>信息后，Producer会首先将路由信息缓存到本地，再每30秒从NameServer更新一次路由信息。<br>5）Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取其所订阅Topic的路由信息，<br>然后根据算法策略从路由信息中获取到其所要消费的Queue，然后直接跟Broker建立长连接，开始消费<br>其中的消息。Consumer在获取到路由信息后，同样也会每30秒从NameServer更新一次路由信息。不过<br>不同于Producer的是，Consumer还会向Broker发送心跳，以确保Broker的存活状态。</p>
<p>Topic的创建模式</p>
<p>手动创建Topic时，有两种模式：</p>
<ul>
<li>集群模式：该模式下创建的Topic在该集群中，所有Broker中的Queue数量是相同的。</li>
<li>Broker模式：该模式下创建的Topic在该集群中，每个Broker中的Queue数量可以不同。</li>
</ul>
<p>自动创建Topic时，默认采用的是Broker模式，会为每个Broker默认创建4个Queue。</p>
<p>读&#x2F;写队列</p>
<p>从物理上来讲，读&#x2F;写队列是同一个队列。所以，不存在读&#x2F;写队列数据同步问题。读&#x2F;写队列是逻辑上进<br>行区分的概念。一般情况下，读&#x2F;写队列数量是相同的。</p>
<p>例如，创建Topic时设置的写队列数量为8，读队列数量为4，此时系统会创建8个Queue，分别是0 1 2 3<br>456 7。Producer会将消息写入到这8个队列，但Consumer只会消费0 1 2 3这4个队列中的消息，4 5 6<br>7中的消息是不会被消费到的。</p>
<p>再如，创建Topic时设置的写队列数量为4，读队列数量为8，此时系统会创建8个Queue，分别是0 1 2 3<br>456 7。Producer会将消息写入到0 1 2 3 这4个队列，但Consumer只会消费0 1 2 3 4 5 6 7这8个队列中<br>的消息，但是4 5 6 7中是没有消息的。此时假设Consumer Group中包含两个Consuer，Consumer1消<br>费01 2 3，而Consumer2消费4 5 6 7。但实际情况是，Consumer2是没有消息可消费的。<br>也就是说，当读&#x2F;写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？<br>其这样设计的目的是为了，方便Topic的Queue的缩容。</p>
<p>例如，原来创建的Topic中包含16个Queue，如何能够使其Queue缩容为8个，还不会丢失消息？可以动<br>态修改写队列数量为8，读队列数量不变。此时新的消息只能写入到前8个队列，而消费都消费的却是<br>16个队列中的数据。当发现后8个Queue中的消息消费完毕后，就可以再将读队列数量动态设置为8。整<br>个缩容过程，没有丢失任何消息。</p>
<p>perm用于设置对当前创建Topic的操作权限：2表示只写，4表示只读，6表示读写。</p>
<h2 id="代码集成"><a href="#代码集成" class="headerlink" title="代码集成"></a>代码集成</h2><h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3><p>1 消息发送分类</p>
<p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>
<p>同步发送消息</p>
<p>同步发送消息是指，Producer发出⼀条消息后，会在收到MQ返回的ACK之后才发下⼀条消息。该方式的消息可靠性最高，但消息发送效率太低。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600071695.png" class=""></p>
<p>异步发送消息</p>
<p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下⼀条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600072055.png" class=""></p>
<p>单向发送消息</p>
<p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600072525.png" class="">

<p>2 代码举例</p>
<p>创建工程</p>
<p>创建一个Maven的Java工程rocketmq-test。</p>
<p>导入依赖</p>
<p>导入rocketmq的client依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-</span><br><span class="line"><span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;<span class="number">1.8</span>&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">4.8</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>定义同步消息发送生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 创建一个producer，参数为Producer Group名称</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定nameServer地址</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 设置当发送失败时重试发送的次数，默认为2次</span></span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置发送超时时限为5s，默认3s</span></span><br><span class="line">producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 开启生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="comment">// 生产并发送100条消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line"><span class="comment">// 为消息指定key</span></span><br><span class="line">msg.setKeys(<span class="string">&quot;key-&quot;</span> + i);</span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭producer</span></span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息发送的状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SendStatus</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">SEND_OK, <span class="comment">// 发送成功</span></span><br><span class="line">FLUSH_DISK_TIMEOUT, <span class="comment">// 刷盘超时。当Broker设置的刷盘策略为同步刷盘时才可能出</span></span><br><span class="line">现这种异常状态。异步刷盘不会出现</span><br><span class="line">FLUSH_SLAVE_TIMEOUT, <span class="comment">// Slave同步超时。当Broker集群设置的Master-Slave的复</span></span><br><span class="line">制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span><br><span class="line">SLAVE_NOT_AVAILABLE, <span class="comment">// 没有可用的Slave。当Broker集群设置为Master-Slave的</span></span><br><span class="line">复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义异步消息发送生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 指定新创建的Topic的Queue数量为2，默认为4</span></span><br><span class="line">producer.setDefaultTopicQueueNums(<span class="number">2</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;myTopicA&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line"><span class="comment">// 异步发送。指定回调</span></span><br><span class="line">producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 当producer接收到MQ发送来的ACK后就会触发该回调方法的执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end-for</span></span><br><span class="line"><span class="comment">// sleep一会儿</span></span><br><span class="line"><span class="comment">// 由于采用的是异步发送，所以若这里不sleep，</span></span><br><span class="line"><span class="comment">// 则消息还未发送就会将producer给关闭，报错</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义单向消息发送生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;single&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line"><span class="comment">// 单向发送</span></span><br><span class="line">producer.sendOneway(msg);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">System.out.println(<span class="string">&quot;producer shutdown&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义消息消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 定义一个pull消费者</span></span><br><span class="line"><span class="comment">// DefaultLitePullConsumer consumer = new</span></span><br><span class="line">DefaultLitePullConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 定义一个push消费者</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定nameServer</span></span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定从第一条消息开始消费</span></span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 指定消费topic与tag</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class="line"><span class="comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line"><span class="comment">// 注册消息监听器</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class="line"><span class="comment">// 其返回值为当前consumer消费的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 逐条消费消息</span></span><br><span class="line"><span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回消费状态：消费成功</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开启消费者消费</span></span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>1 什么是顺序消息</p>
<p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息(FIFO)。</p>
<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>
<p>2 为什么需要顺序消息</p>
<p>例如，现在有TOPIC ORDER_STATUS (订单状态)，其下有4个Queue队列，该Topic中的不同消息用于描述当前订单的不同状态。假设订单有状态： 未支付、已支付、发货中、发货成功、发货失败。</p>
<p>根据以上订单状态，生产者从时序上可以生成如下几个消息：<br>订单T0000001:未支付 –&gt; 订单T0000001:已支付 –&gt; 订单T0000001:发货中 –&gt; 订单T0000001:发货失败</p>
<p>消息发送到MQ中之后，Queue的选择如果采用轮询策略，消息在MQ的存储可能如下：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600072907.png" class=""><br>这种情况下，我们希望Consumer消费消息的顺序和我们发送是一致的，然而上述MQ的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600073439.png" class=""><br>基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个Queue中，然后消费者再采用一定的策略（例如，一个线程独立处理一个queue，保证处理消息的顺序性），能够保证消费的顺序性。</p>
<p>3 有序性分类</p>
<p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：分区有序与全局有序。</p>
<p>全局有序</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600073998.png" class="">
<p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为全局有序。</p>
<blockquote>
<p>在创建Topic时指定Queue的数量。有三种指定方式：<br>1）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量<br>2）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量<br>3）使用mqadmin命令手动创建Topic时指定Queue数量</p>
</blockquote>
<p>分区有序</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600074404.png" class="">
<p>如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为分区有序。</p>
<blockquote>
<p>如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。<br>在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。</p>
<p>一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。</p>
<p>取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。</p>
<p>以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p>
</blockquote>
<p>4 代码举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderedProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">Integer</span> <span class="variable">orderId</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicA&quot;</span>, <span class="string">&quot;TagA&quot;</span>, body);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, <span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs,</span></span><br><span class="line"><span class="params">Message msg, Object arg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size();</span><br><span class="line"><span class="keyword">return</span> mqs.get(index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, orderId);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h3><h4 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1 什么是延时消息"></a>1 什么是延时消息</h4><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。</p>
<p>采用RocketMQ的延时消息可以实现定时任务的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景，12306平台订票超时未支付取消订票的场景。</p>
<blockquote>
<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在30分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。<br>在12306平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在45分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>
</blockquote>
<h4 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2 延时等级"></a>2 延时等级</h4><p>延时消息的延迟时长不支持随意时长的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端的MessageStoreConfig 类中的如下变量中：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600074891.png" class=""><br>即，若指定的延时等级为3，则表示延迟时长为10s，即延迟等级是从1开始计数的。</p>
<p>当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m</span><br><span class="line">1h 2h <span class="number">1d</span></span><br></pre></td></tr></table></figure>

<h4 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3 延时消息实现原理"></a>3 延时消息实现原理</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600075267.png" class="">
<p>具体实现方案是：</p>
<h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600075726.png" class="">
<p>Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>
<ul>
<li>修改消息的Topic为SCHEDULE_TOPIC_XXXX</li>
<li>根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</li>
</ul>
<blockquote>
<p>延迟等级delayLevel与queueId的对应关系为queueId &#x3D; delayLevel -1<br>需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600076583.png" class="">

<ul>
<li>修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。<strong>投递时间 &#x3D; 消息存储时间 + 延时等级时间</strong>。消息存储时间指的是消息被发送到Broker时的时间戳。</li>
<li>将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中</li>
</ul>
<blockquote>
<p>SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？<br>是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到Broker的时间进行排序的。</p>
</blockquote>
<p>投递延时消息</p>
<p>Broker内部有⼀个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到⽬标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为0，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p>
<blockquote>
<p>ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p>
</blockquote>
<p>将消息重新写入commitlog</p>
<p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p>
<blockquote>
<p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService</p>
</blockquote>
<h4 id="4-代码举例"><a href="#4-代码举例" class="headerlink" title="4 代码举例"></a>4 代码举例</h4><p>定义DelayProducer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line"><span class="comment">// 指定消息延迟等级为3级，即延迟10s</span></span><br><span class="line"><span class="comment">// msg.setDelayTimeLevel(3);</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"><span class="comment">// 输出消息被发送的时间</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">Date</span>()));</span><br><span class="line">System.out.println(<span class="string">&quot; ,&quot;</span> + sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义OtherConsumer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TopicB&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 输出消息被消费的时间</span></span><br><span class="line">System.out.print(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">System.out.println(<span class="string">&quot; ,&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><h4 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1 问题引入"></a>1 问题引入</h4><p>这里的一个需求场景是：工行用户A向建行用户B转账1万元。<br>我们可以使用同步消息来处理该需求场景：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600076941.png" class=""></p>
<p><strong>1、</strong> 工行系统发送一个给B增款1万元的同步消息M给Broker；<br><strong>2、</strong> 消息被Broker成功接收后，向工行系统发送成功ACK；<br><strong>3、</strong> 工行系统收到成功ACK后从用户A中扣款1万元；<br><strong>4、</strong> 建行系统从Broker中获取到消息M；<br><strong>5、</strong> 建行系统消费消息M，即向用户B中增加1万元；</p>
<blockquote>
<p>这其中是有问题的：若第3步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来<br>说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了1万元。出<br>现了数据不一致问题。</p>
</blockquote>
<h4 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2 解决思路"></a>2 解决思路</h4><p>解决思路是，让第1、2、3步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要<br>保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用事务消息。这里要使用分布<br>式事务解决方案。</p>
<blockquote>
<p>注：如果不知道TC&#x2F;TM可以看下面的XA模式目录部分的内容</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600077284.png" class="">
<p>使用事务消息来处理该需求场景：</p>
<p><strong>1、</strong> 事务管理器TM向事务协调器TC发起指令，开启全局事务；<br><strong>2、</strong> 工行系统发一个给B增款1万元的事务消息M给TC；<br><strong>3、</strong> TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker此时的建行系统是看；<br>不到Broker中的消息M的 <strong>4、</strong> Broker会将预提交执行结果Report给TC；<br><strong>5、</strong> 如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会；<br>调用工行系统的回调操作，去完成工行用户A的预扣款1万元的操作 <strong>6、</strong> 工行系统会向TC发送预扣款执行结果，即本地事务的执行状态；<br><strong>7、</strong> TC收到预扣款执行结果后，会将结果上报给TM；<br>预扣款执行结果存在三种可能性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述本地事务执行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LocalTransactionState</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">COMMIT_MESSAGE, <span class="comment">// 本地事务执行成功</span></span><br><span class="line">ROLLBACK_MESSAGE, <span class="comment">// 本地事务执行失败</span></span><br><span class="line">UNKNOW, <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、</strong> TM会根据上报结果向TC发出不同的确认指令；</p>
<ul>
<li>若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</li>
<li>若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</li>
<li>若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态回查操作。回<br>查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</li>
</ul>
<p><strong>1、</strong> TC在接收到指令后会向Broker与工行系统发出确认指令；</p>
<ul>
<li>TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时<br>Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认</li>
<li>TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时<br>Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</li>
</ul>
<blockquote>
<p>以上方案就是为了确保消息投递与扣款操作能够在一个事务中，要成功都成功，有一个失败，<br>则全部回滚。<br>以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的<br>消息预提交与预扣款操作间是同步的。</p>
</blockquote>
<h4 id="3-基础"><a href="#3-基础" class="headerlink" title="3 基础"></a>3 基础</h4><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在<br>不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事<br>务一样，就是为了保证操作结果的一致性。</p>
<p>事务消息</p>
<p>RocketMQ提供了类似X&#x2F;Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA<br>是一种分布式事务解决方案，一种分布式事务处理模式。</p>
<p>半事务消息</p>
<p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时<br>该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>
<p>本地事务状态</p>
<p>Producer 回调操作执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发<br>送来的本地事务状态来决定全局事务确认指令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 描述本地事务执行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">LocalTransactionState</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">COMMIT_MESSAGE, <span class="comment">// 本地事务执行成功</span></span><br><span class="line">ROLLBACK_MESSAGE, <span class="comment">// 本地事务执行失败</span></span><br><span class="line">UNKNOW, <span class="comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息回查</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600077787.png" class="">
<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。</p>
<blockquote>
<p>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预<br>扣款操作执行的结果。</p>
</blockquote>
<blockquote>
<p>引发消息回查的原因最常见的有两个：<br>1)回调操作返回UNKNWON<br>2)TC没有接收到TM的最终全局事务确认指令</p>
</blockquote>
<p>RocketMQ中的消息回查设置</p>
<p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p>
<ul>
<li>transactionTimeout&#x3D;20，指定TM在20秒内应将最终确认状态发送给TC，否则引发消息回查。默<br>认为60秒</li>
<li>transactionCheckMax&#x3D;5，指定最多回查5次，超过后将丢弃消息并记录错误日志。默认15次。</li>
<li>transactionCheckInterval&#x3D;10，指定设置的多次消息回查的时间间隔为10秒。默认为60秒。</li>
</ul>
<h4 id="4-XA模式三剑客"><a href="#4-XA模式三剑客" class="headerlink" title="4 XA模式三剑客"></a>4 XA模式三剑客</h4><p>XA协议</p>
<p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。<br>XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩<br>展之后的Unix事务系统）首先提出的，并交给X&#x2F;Open组织，作为资源管理器与事务管理器的接口标<br>准。 XA模式中有三个重要组件：TC、TM、RM。</p>
<p>TC</p>
<p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<blockquote>
<p>RocketMQ中Broker充当着TC</p>
</blockquote>
<p>TM</p>
<p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它<br>实际是全局事务的发起者</p>
<blockquote>
<p>RocketMQ中事务消息的Producer充当着TM。</p>
</blockquote>
<p>RM</p>
<p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事<br>务的状态，并驱动分支事务提交或回滚。</p>
<blockquote>
<p>RocketMQ中事务消息的Producer及Broker均是RM。</p>
</blockquote>
<h4 id="5-XA模式架构"><a href="#5-XA模式架构" class="headerlink" title="5 XA模式架构"></a>5 XA模式架构</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600078196.png" class="">
<p>XA模式是一个典型的2PC，其执行原理如下：</p>
<p><strong>1、</strong> TM向TC发起指令，开启一个全局事务；<br><strong>2、</strong> 根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令；<br><strong>3、</strong> 各个RM在接收到指令后会在进行本地事务预执行；<br><strong>4、</strong> RM将预执行结果Report给TC当然，这个结果可能是成功，也可能是失败；<br><strong>5、</strong> TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指；<br>令。</p>
<ul>
<li>若所有结果都是成功响应，则向TC发送Global Commit指令。</li>
<li>只要有结果是失败响应，则向TC发送Global Rollback指令</li>
</ul>
<p><strong>1、</strong> TC在接收到指令后再次向RM发送确认指令；</p>
<blockquote>
<p>事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案<br>中的消息预提交与预扣款操作间是同步的。</p>
</blockquote>
<h4 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h4><p>事务消息不支持延时消息<br>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的<br>情况）</p>
<h4 id="7-代码举例"><a href="#7-代码举例" class="headerlink" title="7 代码举例"></a>7 代码举例</h4><p>定义工行事务监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICBCTransactionListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 回调操作方法</span></span><br><span class="line"><span class="comment">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg,</span></span><br><span class="line"><span class="params">Object arg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(<span class="string">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class="line"><span class="comment">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class="line"><span class="comment">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息回查方法</span></span><br><span class="line"><span class="comment">// 引发消息回查的原因最常见的有两个：</span></span><br><span class="line"><span class="comment">// 1)回调操作返回UNKNWON</span></span><br><span class="line"><span class="comment">// 2)TC没有接收到TM的最终全局事务确认指令</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(<span class="string">&quot;执行消息回查&quot;</span> + msg.getTags());</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义事物消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;tpg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个线程池</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量</span></span><br><span class="line"><span class="comment">是，</span></span><br><span class="line"><span class="comment">* 多余空闲线程的存活时长</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">100</span>, TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 为生产者指定一个线程池</span></span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line"><span class="comment">// 为生产者添加事务监听器</span></span><br><span class="line">producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">ICBCTransactionListener</span>());</span><br><span class="line">producer.start();</span><br><span class="line">String[] tags = &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="string">&quot;TAGA&quot;</span>,<span class="string">&quot;TAGB&quot;</span>,<span class="string">&quot;TAGC&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TTopic&quot;</span>, tags[i], body);</span><br><span class="line"><span class="comment">// 发送事务消息</span></span><br><span class="line"><span class="comment">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span></span><br><span class="line">producer.sendMessageInTransaction(msg,<span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;发送结果为：&quot;</span> +</span><br><span class="line">sendResult.getSendStatus());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义消费者</p>
<p>直接使用普通消息的SomeConsumer作为消费者即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 定义一个pull消费者</span></span><br><span class="line"><span class="comment">// DefaultLitePullConsumer consumer = new</span></span><br><span class="line">DefaultLitePullConsumer(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 定义一个push消费者</span></span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定nameServer</span></span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定从第一条消息开始消费</span></span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 指定消费topic与tag</span></span><br><span class="line">consumer.subscribe(<span class="string">&quot;TTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 指定采用“广播模式”进行消费，默认为“集群模式”</span></span><br><span class="line"><span class="comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></span><br><span class="line"><span class="comment">// 注册消息监听器</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span></span><br><span class="line"><span class="comment">// 其返回值为当前consumer消费的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 逐条消费消息</span></span><br><span class="line"><span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回消费状态：消费成功</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开启消费者消费</span></span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h3><h4 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1 批量发送消息"></a>1 批量发送消息</h4><p>发送限制</p>
<p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以<br>下几点：</p>
<ul>
<li>批量发送的消息必须具有相同的Topic</li>
<li>批量发送的消息必须具有相同的刷盘策略</li>
<li>批量发送的消息不能是延时消息与事务消息</li>
</ul>
<p>批量发送大小</p>
<p>默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：</p>
<ul>
<li>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</li>
<li>方案二：在Producer端与Broker端修改属性</li>
</ul>
<p>** Producer端需要在发送之前设置Producer的maxMessageSize属性 **<br>** Broker端需要修改其加载的配置文件中的maxMessageSize属性 **</p>
<p>生产者发送的消息大小</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600078904.png" class="">
<p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占20字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p>
<h4 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2 批量消费消息"></a>2 批量消费消息</h4><p>修改批量属性</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600079360.png" class="">
<p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过32。因为默认情况下消费者每次可以拉取的消息最多是32条。若要修改一次拉取的最大值，则可通过修改Consumer的pullBatchSize属性来指定。</p>
<p>存在的问题</p>
<p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p>
<ul>
<li>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</li>
<li>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</li>
</ul>
<h4 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3 代码举例"></a>3 代码举例</h4><p>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。</p>
<p>定义消息列表分割器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span></span><br><span class="line"><span class="comment">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span></span><br><span class="line"><span class="comment">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 指定极限值为4M</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">4</span> *<span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// 存放所有要发送的消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line"><span class="comment">// 要进行批量发送消息的小集合起始索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> currIndex;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MessageListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="built_in">this</span>.messages = messages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 判断当前开始遍历的消息索引要小于消息总数</span></span><br><span class="line"><span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> currIndex;</span><br><span class="line"><span class="comment">// 记录当前要发送的这一小批次消息列表的大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 获取当前遍历的消息</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line"><span class="comment">// 统计当前遍历的message的大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> message.getTopic().length() +</span><br><span class="line">message.getBody().length;</span><br><span class="line">Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry :</span><br><span class="line">properties.entrySet()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">tmpSize += entry.getKey().length() +</span><br><span class="line">entry.getValue().length();</span><br><span class="line">&#125;</span><br><span class="line">tmpSize = tmpSize + <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 判断当前消息本身是否大于4M</span></span><br><span class="line"><span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">totalSize += tmpSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end-for</span></span><br><span class="line"><span class="comment">// 获取当前messages列表的子集合[currIndex, nextIndex)</span></span><br><span class="line">List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line"><span class="comment">// 下次遍历的开始索引</span></span><br><span class="line">currIndex = nextIndex;</span><br><span class="line"><span class="keyword">return</span> subList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义批量消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定要发送的消息的最大大小，默认是4M</span></span><br><span class="line"><span class="comment">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span></span><br><span class="line"><span class="comment">// maxMessageSize属性</span></span><br><span class="line"><span class="comment">// producer.setMaxMessageSize(8 * 1024 * 1024);</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="comment">// 定义要发送的消息集合</span></span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;someTopic&quot;</span>, <span class="string">&quot;someTag&quot;</span>, body);</span><br><span class="line">messages.add(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span></span><br><span class="line"><span class="type">MessageListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListSplitter</span>(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">producer.send(listItem);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义批量消息消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;someTopicA&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 指定每次可以消费10条消息，默认为1</span></span><br><span class="line">consumer.setConsumeMessageBatchMaxSize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 指定每次可以从Broker拉取40条消息，默认为32</span></span><br><span class="line">consumer.setPullBatchSize(<span class="number">40</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费成功的返回结果</span></span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line"><span class="comment">// 消费异常时的返回结果</span></span><br><span class="line"><span class="comment">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。<br>对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。</p>
<h4 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1 Tag过滤"></a>1 Tag过滤</h4><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CID_EXAMPLE&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAGA || TAGB || TAGC&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2 SQL过滤"></a>2 SQL过滤</h4><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的用户属性进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用PUSH模式的消费者才能使用SQL过滤。</p>
<p>SQL过滤表达式中支持多种常量类型与运算符。</p>
<p>支持的常量类型：</p>
<ul>
<li>数值：比如：123，3.1415</li>
<li>字符：必须用单引号包裹起来，比如：‘abc’</li>
<li>布尔：TRUE 或 FALSE</li>
<li>NULL：特殊的常量，表示空</li>
</ul>
<p>支持的运算符有：</p>
<ul>
<li>数值比较：&gt;<code>，&gt;</code>&#x3D;，<code>&lt;，</code>&lt;&#x3D;，BETWEEN，&#x3D;</li>
<li>字符比较：&#x3D;，<code>&lt;&gt;</code>，IN</li>
<li>逻辑运算 ：AND，OR，NOT</li>
<li>NULL判断：IS NULL 或者 IS NOT NULL</li>
</ul>
<p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开启该功能：</p>
<blockquote>
<p>enablePropertyFilter 1 &#x3D; true</p>
</blockquote>
<p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是conf&#x2F;broker.conf，启动时使用如下命令：</p>
<blockquote>
<p>sh bin&#x2F;mqbroker -n localhost:9876 -c conf&#x2F;broker.conf &amp;</p>
</blockquote>
<h4 id="3-代码举例-1"><a href="#3-代码举例-1" class="headerlink" title="3 代码举例"></a>3 代码举例</h4><p>定义Tag过滤Producer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterByTagProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line">String[] tags = &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="string">&quot;myTagA&quot;</span>,<span class="string">&quot;myTagB&quot;</span>,<span class="string">&quot;myTagC&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">String</span> <span class="variable">tag</span> <span class="operator">=</span> tags[i%tags.length];</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;myTopic&quot;</span>,tag,body);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义Tag过滤Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterByTagConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTagA || myTagB&quot;</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (MessageExt me:msgs)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义SQL过滤Producer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterBySQLProducer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">byte</span>[] body = (<span class="string">&quot;Hi,&quot;</span> + i).getBytes();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;myTopic&quot;</span>, <span class="string">&quot;myTag&quot;</span>, body);</span><br><span class="line">msg.putUserProperty(<span class="string">&quot;age&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义SQL过滤Consumer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterBySQLConsumer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;myTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;age between</span></span><br><span class="line"><span class="string">0 and 6&quot;</span>));</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus</span><br><span class="line"><span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext</span></span><br><span class="line"><span class="params">context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (MessageExt me:msgs)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer Started&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="发送端消息重试"><a href="#发送端消息重试" class="headerlink" title="发送端消息重试"></a>发送端消息重试</h3><h4 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h4><p>Producer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。<br>对于消息重投，需要注意以下几点：</p>
<ul>
<li>生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式发送失败是没有重试机制的</li>
<li>只有普通消息具有发送重试机制，顺序消息是没有的</li>
<li>消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在RocketMQ中是无法避免的问题</li>
<li>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</li>
<li>producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息</li>
<li>消息重复无法避免，但要避免消息的重复消费。</li>
<li>避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消费判断来避免重复消费</li>
<li>消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li>
</ul>
<h4 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2 同步发送失败策略"></a>2 同步发送失败策略</h4><p>对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试2次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个producer，参数为Producer Group名称</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line"><span class="comment">// 指定nameServer地址</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 设置同步发送失败时重试发送的次数，默认为2次</span></span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置发送超时时限为5s，默认3s</span></span><br><span class="line">producer.setSendMsgTimeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<p>同时，Broker还具有失败隔离功能，使Producer尽量选择未发生过发送失败的Broker作为目标Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p>
<blockquote>
<p>思考：让我们自己实现失败隔离功能，如何来做？</p>
</blockquote>
<blockquote>
<p>1）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实<br>例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送异常的Broker清理出去，并添加到Set集合。</p>
</blockquote>
<blockquote>
<p>2）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的Broker。再定义一个定时任务，定期将Broker的该属性置为false。</p>
</blockquote>
<blockquote>
<p>3）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若该值相同，采用轮询方式选择。</p>
</blockquote>
<p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息</p>
<h4 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3 异步发送失败策略"></a>3 异步发送失败策略</h4><p>异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保证消息不丢。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;pg&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;rocketmqOS:9876&quot;</span>);</span><br><span class="line"><span class="comment">// 指定异步发送失败后不进行重试发送</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4 消息刷盘失败策略"></a>4 消息刷盘失败策略</h4><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。</p>
<h3 id="接收端消息重试"><a href="#接收端消息重试" class="headerlink" title="接收端消息重试"></a>接收端消息重试</h3><h4 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1 顺序消息的消费重试"></a>1 顺序消息的消费重试</h4><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为1000毫秒。重试期间应用会出现消息消费被阻塞的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为1000，其取值范围为[10,</span></span><br><span class="line"><span class="number">30000</span>]</span><br><span class="line">consumer.setSuspendCurrentQueueTimeMillis(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</p>
</blockquote>
<blockquote>
<p>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</p>
</blockquote>
<h4 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2 无序消息的消费重试"></a>2 无序消息的消费重试</h4><p>对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试只对集群消费方式生效，广播消费方式不提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p>
<h4 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3 消费重试次数与间隔"></a>3 消费重试次数与间隔</h4><p>对于无序消息集群消费下的重试消费，每条消息默认最多重试16次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600080049.png" class="">

<blockquote>
<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第4小时46分后进行第16次重试。若仍然失败，则将消息投递到死信队列</p>
</blockquote>
<p>修改消费重试次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;cg&quot;</span>);</span><br><span class="line"><span class="comment">// 修改消费重试次数</span></span><br><span class="line">consumer.setMaxReconsumeTimes(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>对于修改过的重试次数，将按照以下策略执行：</p>
<ul>
<li>若修改值小于16，则按照指定间隔进行重试</li>
<li>若修改值大于16，则超过16次的重试时间间隔均为2小时</li>
</ul>
<blockquote>
<p>对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。</p>
</blockquote>
<h4 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4 重试队列"></a>4 重试队列</h4><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>
<p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称为%RETRY%consumerGroup@consumerGroup 的重试队列。</p>
<blockquote>
<p>1）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br>2）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600080343.png" class="">

<blockquote>
<p>注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的</p>
</blockquote>
<p>Broker对于重试消息的处理是通过延时消息实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p>
<h4 id="5-消费重试配置方式"><a href="#5-消费重试配置方式" class="headerlink" title="5 消费重试配置方式"></a>5 消费重试配置方式</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600081352.png" class="">
<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：</p>
<ul>
<li>方式1：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</li>
<li>方式2：返回Null</li>
<li>方式3：抛出异常</li>
</ul>
<h4 id="6-消费不重试配置方式"><a href="#6-消费不重试配置方式" class="headerlink" title="6 消费不重试配置方式"></a>6 消费不重试配置方式</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600082137.png" class="">
<p>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p>
<h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>为了防⽌消息重复消费导致业务处理异常，消息队列 RocketMQ 版的消费者在接收到消息后，有必要根据业务上的唯⼀ Key 对消息做幂等处理。</p>
<h4 id="什么是消息幂等"><a href="#什么是消息幂等" class="headerlink" title="什么是消息幂等"></a>什么是消息幂等</h4><p>如果有⼀个操作，多次执⾏与⼀次执⾏所产⽣的影响是相同的，我们就称这个操作是幂等的。<br>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费⼀次的结果是相同的，并且多次消费并未对业务系统产⽣任何负⾯影响，那么这整个过程就可实现消息幂等。</p>
<p>适⽤场景</p>
<blockquote>
<p>在互联⽹应⽤中，尤其在⽹络不稳定的情况下，消息队列 RocketMQ 版的消息有可能会出现重复。如果消息重复会影响您的业务处理，请对消息做幂等处理。</p>
</blockquote>
<p>消息重复的场景如下：</p>
<ul>
<li>发送时消息重复 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600082811.png" class=""></li>
</ul>
<blockquote>
<p>当⼀条消息已被成功发送到服务端并完成持久化，此时出现了⽹络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时⽣产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</blockquote>
<ul>
<li>投递时消息重复 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600083828.png" class=""></li>
</ul>
<blockquote>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候⽹络闪断。为了保证消息⾄少被消费⼀次，消息队列 RocketMQ 版的服务端将在⽹络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID也相同的消息。</p>
</blockquote>
<ul>
<li>负载均衡时消息重复（包括但不限于⽹络抖动、Broker 重启以及消费者应⽤重启）</li>
</ul>
<p>当消息队列 RocketMQ 版的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
<p>实现消息幂等</p>
<p>定义消息幂等的两要素：</p>
<p>幂等令牌</p>
<p>幂等令牌是⽣产者和消费者两者中的既定协议，在业务中通常是具备唯⼀业务标识的字符串，如：<br>订单号、流⽔号等。且⼀般由⽣产者端⽣成并传递给消费者端。</p>
<p>处理唯⼀性的确保</p>
<p>缓存唯⼀索引<br>可以使用Redis缓存</p>
<p>RocketMQ如何处理消息幂等</p>
<p><strong>RocketMQ能够保证消息不丢失但不保证消息不重复。</strong></p>
<blockquote>
<p>如果在RocketMQ中实现消息去重实际也是可以的，但是考虑到⾼可⽤以及⾼性能的需求，如果做了服务端的消息去重，RocketMQ就需要对消息做额外的rehash、排序等操作，这会花费较⼤的时间和空间等资源代价，收益并不明显。<br>RocketMQ考虑到正常情况下出现重复消息的概率其实是很⼩的，因此RocketMQ将消息幂等操作交给了业务⽅处理。</p>
</blockquote>
<p>因为Message ID 有可能出现冲突（重复）的情况，因此不建议通过MessageID作为处理依据，⽽最好的⽅式是以业务唯⼀标识作为幂等处理的关键依据如：订单号、流⽔号等作为幂等处理的关键依据。⽽业务的唯⼀标识可以通过消息 Key 设置。</p>
<p>以⽀付场景为例，可以将消息的 Key 设置为订单号，作为幂等处理的依据。具体代码示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">message.setKeys(<span class="string">&quot;ORDERID_100&quot;</span>);</span><br><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message);</span><br></pre></td></tr></table></figure>

<p>消费者收到消息时可以根据消息的 Key，即订单号来实现消息幂等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext</span></span><br><span class="line"><span class="params">context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span>(MessageExt msg:msgs)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> msg.getKeys();</span><br><span class="line"><span class="comment">// 根据业务唯⼀标识的 Key 做幂等处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端常⻅的幂等操作</p>
<p><strong>1、</strong> 业务操作之前进⾏状态查询；</p>
<blockquote>
<p>消费端开始执⾏业务操作时，通过幂等id⾸先进⾏业务状态的查询，如：修改订单状态环节，当订单状态为成功&#x2F;失败则不需要再进⾏处理。那么我们只需要在消费逻辑执⾏之前通过订单号进⾏订单状态查询，⼀旦获取到确定的订单状态则对消息进⾏提交，通知broker消息状态为：ConsumeConcurrentlyStatus.CONSUME_SUCCESS 。</p>
</blockquote>
<p><strong>2、</strong> 唯⼀性约束保证最后⼀道防线；</p>
<blockquote>
<p>上述第⼆点操作并不能保证⼀定不出现重复的数据，如：并发插⼊的场景下，如果没有乐观锁、分布式锁作为保证的前提下，很有可能出现数据的重复插⼊操作，因此我们务必要对幂等id添加唯⼀性索引，这样就能够保证在并发场景下也能保证数据的唯⼀性。</p>
</blockquote>
<p><strong>3、</strong> 引⼊锁机制；</p>
<blockquote>
<p>上述的第⼀点中，如果是并发更新的情况，没有使⽤悲观锁、乐观锁、分布式锁等机制的前提下，进⾏更新，很可能会出现多次更新导致状态的不准确。如：对订单状态的更新，业务要求订单只能从初始化-&gt;处理中，处理中-&gt;成功，处理中-&gt;失败，不允许跨状态更新。如果没有锁机制，很可能会将初始化的订单更新为成功，成功订单更新为失败等异常的情况。<br>⾼并发下，建议通过状态机的⽅式定义好业务状态的变迁，通过乐观锁、分布式锁机制保证多次更新的结果是确定的，悲观锁在并发环境不利于业务吞吐量的提⾼因此不建议使⽤。</p>
</blockquote>
<h3 id="消息堆集问题"><a href="#消息堆集问题" class="headerlink" title="消息堆集问题"></a>消息堆集问题</h3><h4 id="消息堆积本质"><a href="#消息堆积本质" class="headerlink" title="消息堆积本质"></a>消息堆积本质</h4> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600084695.png" class="">
<p>⽣产者的⽣产速度 &gt;&gt; 消费者的处理速度</p>
<blockquote>
<p>⽣产者的⽣产速度骤增，⽐如⽣产者的流量突然骤增<br>消费速度变慢，⽐如消费者实例 IO 阻塞严重或者宕机</p>
</blockquote>
<h4 id="如何处理消息堆积"><a href="#如何处理消息堆积" class="headerlink" title="如何处理消息堆积"></a>如何处理消息堆积</h4><p>如何处理消息堆积呢？可以从两个当⾯考虑：</p>
<ul>
<li>如何通过解决系统问题、优化代码来避免消息堆积</li>
<li>消息已经堆积了，线上如何快速处理</li>
</ul>
<p>发送端性能优化</p>
<blockquote>
<p>从消息堆积若⼲原因来看，消息堆积的原因主要在消费端处理上，本身⽣产者端应该遵循的<br>原则应该是尽可能快的将消息发送到Broker中去，因此发送端除了业务处理时批量发送暂⽆好的<br>⼿段优化，⽽且并不是所有的业务处理都⽀持批量发送和批量接收处理。</p>
</blockquote>
<p>批量发送是发送端预防消息堆积的⽅式之⼀</p>
<p>消费端性能优化</p>
<p>在设计系统的时候，⼀定要保证消费端的消费性能要⾼于⽣产端的发送性能，这样的系统才能健康的<br>持续运⾏。</p>
<ul>
<li>⽅式1 增加单个消费者处理能⼒ <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600085486.png" class=""></li>
</ul>
<blockquote>
<p>增加单个消费者的处理能⼒这块没有绝对的办法，只能尽可能的优化消息处理业务逻辑的能<br>⼒，减少不必要的⾮业务相关处理时间消耗；如果消息处理业务已经优化到⽆法再优化了，那只<br>能通过⽅式2⽔平扩展消费者个数来优化。</p>
</blockquote>
<ul>
<li>⽅式2 ⽔平扩容消费者个数 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600086173.png" class=""></li>
</ul>
<blockquote>
<p>消费端的性能优化除了优化消费业务逻辑以外，也可以通过⽔平扩容，增加消费端的并发数<br>来提升总体的消费性能。</p>
</blockquote>
<p>如何快速处理</p>
<blockquote>
<p>如果消息已经堆积了，线上如何快速处理。对于系统发⽣消息积压的情况，需要先解决积<br>压，再分析原因，毕竟保证系统的可⽤性是⾸先要解决的问题。</p>
</blockquote>
<p><strong>1、</strong> 消费端扩容；–通⽤⽅式；<br><strong>2、</strong> 服务降级；–快速失败，不⼀定适⽤所有业务场景；<br><strong>3、</strong> 跳过⾮重要消息：发⽣消息堆积时，如果消费速度⼀直追不上发送速度，可以选择丢弃不重要的消息；<br><strong>4、</strong> 异常监控–属于运维层⾯措施；</p>
<h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><h4 id="消息查询介绍"><a href="#消息查询介绍" class="headerlink" title="消息查询介绍"></a>消息查询介绍</h4><p>3种消息查询⽅式：</p>
<ul>
<li>Message Key 查询：消息的key是业务开发在发送消息之前⾃⾏指定的，通常会把具有业务含义，区分度⾼的字段作为消息的key，如⽤户id，订单id等。</li>
<li>Unique Key查询：除了业务开发明确的指定消息中的key，RocketMQ⽣产者客户端在发送发送消息之前，会⾃动⽣成⼀个UNIQ_KEY，设置到消息的属性中，从逻辑上唯⼀代表⼀条消息。</li>
<li>Message Id 查询：Message Id 是消息发送后，在Broker端⽣成的，其包含了Broker的地址，和在CommitLog中的偏移信息，并会将Message Id作为发送结果的⼀部分进⾏返回。Message Id中属于精确匹配，可以唯⼀定位⼀条消息，不需要使⽤哈希索引机制，查询效率更⾼。</li>
</ul>
<blockquote>
<p>RocketMQ有意弱化Unique Key与Message Id的区别，对外都称之为Message Id。在通过RocketMQ的命令⾏⼯具或管理平台进⾏查询时，⼆者可以通⽤。在根据Unique Key进⾏查询时，本身是有可能查询到多条消息的，但是查询⼯具会进⾏过滤，只会返回⼀条消息。<br>业务开发同学在使⽤RocketMQ时，应该养成良好的习惯，在发送&#x2F;消费消息时，将这些信息记录下来，通常是记录到⽇志⽂件中，以便在出现问题时进⾏排查。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 构建消息对象Message</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">msg.setTopic(<span class="string">&quot;TopicA&quot;</span>);</span><br><span class="line">msg.setKeys(<span class="string">&quot;Key1&quot;</span>);</span><br><span class="line">msg.setBody(<span class="string">&quot;message body&quot;</span>.getBytes());</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//2 发送消息</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"><span class="comment">//3 打印发送结果</span></span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，⽤户主动设置的Key以及客户端⾃动⽣成的Unique Key，最终都会设置到Message对象的<br>properties属性中，如下图所示<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600087015.png" class=""><br>其中： KEYS：表示⽤户通过setKeys⽅法设置的消息key，<br>UNIQ_KEY：表示客户端⾃动⽣成的Unique Key。</p>
<p>结果中包含Unique Key和Message Id，如下所示：</p>
<blockquote>
<p>SendResult [sendStatus&#x3D;SEND_OK, msgId&#x3D;0A1427544F4818B4AAC27DD168880000,<br>offsetMsgId&#x3D;0A14275400002A9F00000000001F268E, messageQueue&#x3D;MessageQueue<br>[topic&#x3D;TopicTest, brokerName&#x3D;broker-a, queueId&#x3D;2], queueOffset&#x3D;1173]</p>
</blockquote>
<p>其中：</p>
<ul>
<li>sendStatus：表示消息发送结果的状态</li>
<li>msgId：注意这⾥的命名虽然是msgId，但实际上其是Unique Key</li>
<li>offsetMsgId：Broker返回的Message ID 。在后⽂中，未进⾏特殊说明的情况下，Message ID总<br>是表示offsetMsgId。</li>
<li>messageQueue：消息发送到了哪个的队列。</li>
<li>queueOffset：消息在队列中的偏移量，每次发送到⼀个队列时，offset+1</li>
</ul>
<h4 id="消息查询⼯具"><a href="#消息查询⼯具" class="headerlink" title="消息查询⼯具"></a>消息查询⼯具</h4><p>命令⾏⼯具<br>管理平台<br>客户端API</p>
<h4 id="命令⾏⼯具"><a href="#命令⾏⼯具" class="headerlink" title="命令⾏⼯具"></a>命令⾏⼯具</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sh bin/mqadmin</span><br><span class="line">The most commonly used mqadmin commands are:</span><br><span class="line">...</span><br><span class="line">queryMsgById 按照Message Id查询消息</span><br><span class="line">queryMsgByKey 按照Key查询消息</span><br><span class="line">queryMsgByUniqueKey 按照UNIQ_KEY查询消息</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>例如，要查询在TopicA中，key为Key-0的消息<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600088028.png" class=""><br>这⾥，我们看到输出结果中包含了2条记录。其中：</p>
<ul>
<li>Message ID列：这⾥这⼀列的名字显示有问题，实际上其代表的是Unique Key</li>
<li>QID列：表示队列的ID，注意在RocketMQ中唯⼀地位⼀个队列需要topic+brokerName+queueId。这⾥只显示了queueId，其实并不能知道在哪个Broker上。</li>
<li>Offset：消息在在队列中的偏移量</li>
</ul>
<p>在查询到Unique Key之后，我们就可以使⽤另外⼀个命令：queryMsgByUniqueKey，来查询消息的具<br>体内容。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600088526.png" class=""><br>对于消息体的内容，会存储到Message Body Path字段指定到的路径中。可通过cat命令查看(仅适⽤于<br>消息体是字符串)：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600089410.png" class=""><br>指定消费者重新消费：<br>queryMsgByUniqueKey⼦命令还接收另外两个参数：-g参数⽤于指定消费者组名称，-d参数指定消费<br>者client id。指定了这两个参数之后，消息将由消费者直接消费，⽽不是打印在控制台上。<br>⾸先，通过consumerStatus命令，查询出消费者组下的client id信息，如： <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600089818.png" class=""><br>这⾥显示了消费者组please_rename_unique_group_name下⾯只有⼀个消费者，client id为<br><strong>10、</strong> 20.39.84@20820；<br>接着我们可以在queryMsgByUniqueKey⼦命令中，添加-g和-d参数，如下所示：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600090361.png" class=""><br>可以看到，这⾥并没有打印出消息内容，取⽽代之的是消息消费的结果。<br>在内部，主要是分为3个步骤来完成让指定消费者来消费这条消息，如下图所示：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600090920.png" class=""><br>第1步：<br>命令⾏⼯具给所有Broker发起QUERY_MESSAGE请求查询消息，因为并不知道UNIQ_KEY这条消息在哪个Broker上，且最多只会返回⼀条消息，如果超过1条其他会过滤掉；如果查询不到就直接报错。<br>第2步：<br>根据消息中包含了Store Host信息，也就是消息存储在哪个Broker上，接来下命令⾏⼯具会直接给这<br>个Broker发起CONSUME_MESSAGE_DIRECTLY请求，这个请求会携带msgId，group和client id的信息<br>第3步：<br>Broker接收到这个请求，查询出消息内容后，主动给消费者发送CONSUME_MESSAGE_DIRECTLY通知请求，注意虽然与第2步使⽤了同⼀个请求码，但不同的是这个请求中包含了消息体的内容，消费者可直接处理。注意：这⾥并不是将消息重新发送到Topic中，否则订阅这个Topic的所有消费者组，都会重新消费这条消息。</p>
<h4 id="管理平台"><a href="#管理平台" class="headerlink" title="管理平台"></a>管理平台</h4><p>根据Topic时间范围查询：</p>
<blockquote>
<p>按Topic 查询属于范围查询，不推荐使⽤，因为时间范围内消息很多，不具备区分度。查询时，尽可能设置最为精确的时间区间，以便缩⼩查询范围，提⾼速度。最多返回2000条数据。</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600091429.png" class="">
<p>根据Message Key查询：</p>
<blockquote>
<p>按Message Key 查询属于模糊查询，仅适⽤于没有记录 Message ID 但是设置了具有区分度的Message Key的情况。 ⽬前，根据Message Key查询，有⼀个很⼤局限性：不能指定时间范围，且最多返回64条数据。如果⽤户指定的key重复率⽐较⾼的话，就有可能搜不到。</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600093067.png" class="">
<p>根据Message Id查询：</p>
<blockquote>
<p>按Message ID 查询属于精确查询，速度快，精确匹配，只会返回⼀条结果，推荐使⽤。在这⾥，传⼊Unique Key，offsetMsgId都可以。</p>
</blockquote>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600094244.png" class="">

<h4 id="客户端API"><a href="#客户端API" class="headerlink" title="客户端API"></a>客户端API</h4><blockquote>
<p>除了通过命令⾏⼯具和管理平台，还可以通过客户端API的⽅式来进⾏查询，这其实是最本质的⽅式，命令⾏⼯具和管理平台的查询功能都是基于此实现。</p>
</blockquote>
<p>在org.apache.rocketmq.client.MQAdmin接⼝中，定义了以下⼏个⽅法⽤于消息查询：</p>
<blockquote>
<p>常⽤的DefaultMQProducer、DefaultMQPushConsumer等，都实现了此接⼝，因此都具备消息查询的能⼒.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MQAdmin</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">...</span><br><span class="line"><span class="comment">//msgId参数：仅接收SendResult中的offsetMsgId，返回单条消息</span></span><br><span class="line">MessageExt <span class="title function_">viewMessage</span><span class="params">(<span class="keyword">final</span> String msgId)</span></span><br><span class="line"><span class="comment">//msgId参数：传⼊SendResult中的offsetMsgId、msgId都可以，返回单条消息</span></span><br><span class="line">MessageExt <span class="title function_">viewMessage</span><span class="params">(String topic,String msgId)</span></span><br><span class="line"><span class="comment">//在指定topic下，根据key进⾏查询，并指定最⼤返回条数，以及开始和结束时间</span></span><br><span class="line">QueryResult <span class="title function_">queryMessage</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String key,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> <span class="type">int</span> maxNum, <span class="keyword">final</span> <span class="type">long</span> begin,<span class="keyword">final</span> <span class="type">long</span> end)</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部，实际上都是基于MQAdminImpl这个类来完成的。</p>
<p>viewMessage⽅法：<br>两种viewMessage⽅法重载形式，都只会返回单条消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Producer</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line"><span class="comment">// Specify name server addresses.</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"><span class="comment">//Launch the instance.</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="comment">//根据UniqueKey查询</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uniqueKey</span> <span class="operator">=</span> <span class="string">&quot;0A1427544F4818B4AAC27DD168880000&quot;</span>;</span><br><span class="line"><span class="type">MessageExt</span> <span class="variable">msg</span> <span class="operator">=</span> producer.viewMessage(<span class="string">&quot;TopicTest&quot;</span>, uniqueKey);</span><br><span class="line"><span class="comment">//打印结果：这⾥仅输出Unique Key与offsetMsgId</span></span><br><span class="line">MessageClientExt msgExt= (MessageClientExt) msg;</span><br><span class="line">System.out.println(<span class="string">&quot;Unique Key:&quot;</span>+msgExt.getMsgId()<span class="comment">//即UNIQUE_KEY</span></span><br><span class="line">+<span class="string">&quot;\noffsetMsgId:&quot;</span>+msgExt.getOffsetMsgId());</span><br><span class="line"><span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<blockquote>
<p>Unique Key:0A1427544F4818B4AAC27DD168880000<br>offsetMsgId:0A14275400002A9F00000000001F268E</p>
</blockquote>
<p>如果我们把offsetMsgId当做⽅法参数传⼊，也可以查询到相同的结果。这是因为，在⽅法内部实际<br>上是分两步进⾏查询的：<br><strong>1、</strong> 先把参数当做offsetMsgId，即MessageId进⾏查询；<br><strong>2、</strong> 如果失败，再尝试当做UniqueKey进⾏查询；<br>源码如下所示：<br>DefaultMQProducer#viewMessage(String,String)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MessageExt <span class="title function_">viewMessage</span><span class="params">(String topic,</span></span><br><span class="line"><span class="params">String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span><br><span class="line">InterruptedException, MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//1 尝试当做offsetMsgId进⾏查询</span></span><br><span class="line"><span class="type">MessageId</span> <span class="variable">oldMsgId</span> <span class="operator">=</span> MessageDecoder.decodeMessageId(msgId);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.viewMessage(msgId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 尝试当做UNIQ_KEY进⾏查询</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="built_in">this</span>.defaultMQProducerImpl.queryMessageByUniqKey(withNamespace(topic), msgId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前⾯提到，Unique Key只是从逻辑上代表⼀条消息，实际上在Broker端可能存储了多条，因此在当做Unique Key进⾏查询时，会进⾏过滤，只取其中⼀条。源码如下所示：<br>MQAdminImpl#queryMessageByUniqKey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MessageExt <span class="title function_">queryMessageByUniqKey</span><span class="params">(String topic,</span></span><br><span class="line"><span class="params">String uniqKey)</span> <span class="keyword">throws</span> InterruptedException, MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//根据uniqKey进⾏查询</span></span><br><span class="line"><span class="type">QueryResult</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="built_in">this</span>.queryMessage(topic, uniqKey, <span class="number">32</span>,</span><br><span class="line">MessageClientIDSetter.getNearlyTimeFromID(uniqKey).getTime() -</span><br><span class="line"><span class="number">1000</span>, Long.MAX_VALUE, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//对查询结果进⾏过滤，最多只取⼀条</span></span><br><span class="line"><span class="keyword">if</span> (qr != <span class="literal">null</span> &amp;&amp; qr.getMessageList() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">qr.getMessageList().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> qr.getMessageList().get(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>Unqiue Key &amp; Message Key都需要利⽤RocketMQ的哈希索引机制来完成消息查询，Message Id是在Broker端⽣成的，其包含了Broker地址和commit Log offset信息，可以精确匹配⼀条消息，查询消息更好。</p>
<p>Unique Key 是⽣产者发送消息之前，由RocketMQ 客户端⾃动⽣成的。<br>DefaultMQProducerImpl#sendKernelImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> MessageQueue mq,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> SendCallback sendCallback,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//省略异常声明</span></span><br><span class="line"><span class="comment">//...略</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//如果不是批量消息，则⽣成Unique Key</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// 设置唯⼀编号</span></span><br><span class="line">MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...略</span></span><br></pre></td></tr></table></figure>

<p>MessageClientIDSetter#setUniqID</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUniqID</span><span class="params">(<span class="keyword">final</span> Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">// Unique Key为空的情况下，才进⾏设置</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line">(msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX) == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">msg.putProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX,</span><br><span class="line">createUniqID());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Unique Key作⽤</p>
<p>了解Unique Key的作⽤对于我们理解消息重复的原因有很⼤的帮助。RocketMQ并不保证消息投递过程中的Exactly Once语义，即消息只会被精确消费⼀次，需要消费者⾃⼰做幂等。⽽通常导致消息重复消费的原因，主要包括：</p>
<ul>
<li>⽣产者发送时消息重复：</li>
<li>消费者Rebalance时消息重复：</li>
</ul>
<blockquote>
<p>导致⽣产者发送重复消息的原因可能是：⼀条消息已被成功发送到服务端并完成持久化，由于⽹络超时此时出现了⽹络闪断或者客户端宕机，导致服务端对客户端应答失败，此时⽣产者将再次尝试发送消息。<br>在重试发送时，sendKernelImpl会被重复调⽤，意味着setUniqID⽅法会被重复调⽤，不过由于setUniqID⽅法实现中进⾏判空处理，因此重复设置Unique Key。在这种情况下，消费者后续会收到两条内容相同并且 Unique Key 也相同的消息(offsetMsgId不同，因为对Broker来说存储了多次)。</p>
</blockquote>
<p>那么消费者如何判断，消费重复是因为重复发送还是Rebalance导致的重复消费呢？<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600095477.png" class=""><br>消费者实现MessageListener接⼝监听到的消息类型是MessageExt，可以将其强制转换为<br>MessageClientExt，之后调⽤getMsgId⽅法获取Unique Key，调⽤getOffsetMsgId获得Message Id。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt;</span></span><br><span class="line"><span class="params">msgs,</span></span><br><span class="line"><span class="params">ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (MessageExt msg:msgs)&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="type">MessageClientExt</span> <span class="variable">mct</span> <span class="operator">=</span> (MessageClientExt)msg;</span><br><span class="line"><span class="type">String</span> <span class="variable">uniqueKey</span> <span class="operator">=</span> mct.getMsgId();</span><br><span class="line"><span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> mct.getOffsetMsgId();</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>,</span><br><span class="line">Thread.currentThread().getName(), msgs);</span><br><span class="line"><span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批量发送模式下的Unique Key</p>
<p>DefaultMQProducer提供了批量发送消息的接⼝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span></span><br></pre></td></tr></table></figure>

<p>在内部，这批消息⾸先会被构建成⼀个MessageBatch对象。在前⾯sendKernelImpl⽅法中我们也看到了，对于MessageBatch对象，并不会设置Unique Key。</p>
<blockquote>
<p>这是因为在将批量消息转换成MessageBatch时，已经设置过了。</p>
</blockquote>
<p>⼀个批量消息中每条消息Unique Key是相同的？？？？？？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line"><span class="comment">// Specify name server addresses.</span></span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;localhost:9876&quot;</span>);</span><br><span class="line"><span class="comment">//Launch the instance.</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="comment">//构建批量消息</span></span><br><span class="line">ArrayList&lt;Message&gt; msgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,(<span class="string">&quot;message3&quot;</span>).getBytes());</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TopicTest&quot;</span>,(<span class="string">&quot;message4&quot;</span>).getBytes());</span><br><span class="line">msgs.add(msg1);</span><br><span class="line">msgs.add(msg2);</span><br><span class="line"><span class="comment">//发送</span></span><br><span class="line"><span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> producer.send(msgs);</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>输出如下所示：<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600096035.png" class=""><br>可以看到，此时输出的msgId(即Unique Key)和offsetMsgId都会包含多个值。客户端给批量消息中每条消息设置不同的Unqiue Key，参考DefaultMQProducer#batch()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageBatch <span class="title function_">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">MessageBatch msgBatch;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//1 将消息集合转换为MessageBatch</span></span><br><span class="line">msgBatch = MessageBatch.generateFromList(msgs);</span><br><span class="line"><span class="comment">//2 迭代每个消息，逐⼀设置Unique Key</span></span><br><span class="line"><span class="keyword">for</span> (Message message : msgBatch) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">Validators.checkMessage(message, <span class="built_in">this</span>);</span><br><span class="line">MessageClientIDSetter.setUniqID(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3 设置批量消息的消息体</span></span><br><span class="line">msgBatch.setBody(msgBatch.encode());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;Failed to initiate the MessageBatch&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msgBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Message Id</p>
<p>Message Id是在Broker端⽣成的，⽤于唯⼀标识⼀条消息，在根据Message Id查询的情况下，最多只能查询到⼀条消息。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600096463.png" class=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.common.message;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageId</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">private</span> SocketAddress address;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> offset;</span><br></pre></td></tr></table></figure>

<p>并提供了⼀个MessageDecoder对象来创建或者解码MessageId。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createMessageId</span><span class="params">(<span class="keyword">final</span> ByteBuffer input,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> ByteBuffer addr, <span class="keyword">final</span> <span class="type">long</span> offset)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MessageId <span class="title function_">decodeMessageId</span><span class="params">(<span class="keyword">final</span> String msgId)</span></span><br></pre></td></tr></table></figure>

<p>Broker端在顺序存储消息时，⾸先会通过createMessageId⽅法创建msgId<br>CommitLog.DefaultAppendMessageCallback#doAppend</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">..........................</span><br><span class="line">String msgId;</span><br><span class="line"><span class="comment">//3 创建msgId</span></span><br><span class="line"><span class="keyword">if</span> ((sysflag &amp; MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">msgId = MessageDecoder.createMessageId(<span class="built_in">this</span>.msgIdMemory,</span><br><span class="line">msgInner.getStoreHostBytes(storeHostHolder), wroteOffset);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">msgId = MessageDecoder.createMessageId(<span class="built_in">this</span>.msgIdV6Memory,</span><br><span class="line">msgInner.getStoreHostBytes(storeHostHolder), wroteOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⽽客户端在根据msgId向Broker查询消息时，⾸先会将通过MessageDecoder的decodeMessageId⽅法，之后直接向这个broker进⾏查询指定位置的消息。<br>参⻅：MQAdminImpl#viewMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MessageExt <span class="title function_">viewMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span><br><span class="line">InterruptedException, MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="comment">//1 根据msgId解码成MessageId对象</span></span><br><span class="line"><span class="type">MessageId</span> <span class="variable">messageId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">messageId = MessageDecoder.decodeMessageId(msgId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.NO_MESSAGE, <span class="string">&quot;query</span></span><br><span class="line"><span class="string">message by id finished, but no message.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 根据MessageId中的Broker地址和commit log offset信息进⾏查询</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().viewMessage(RemotingUtil.socketAddre</span><br><span class="line"><span class="title function_">ss2String</span><span class="params">(messageId.getAddress()</span>),</span><br><span class="line">messageId.getOffset(), timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于根据Message Id进⾏查询，实际上是直接从特定Broker的CommitLog中的指定位置进⾏查询的，属于精确匹配，并不像⽤户设置的key，或者Unique Key那么样，需要使⽤到哈希索引机制，因此效率很⾼。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>3种消息查询⽅式：Message Key &amp; Unique Key &amp; Message Id</li>
<li>3种消息查询⼯具：命令⾏、管理平台、客户端API，且⽀持将查询到让特定&#x2F;所有消费者组重新消费</li>
<li>屏蔽Unique Key &amp; Message Id区别，很多地⽅⼆者可以通⽤</li>
<li>Message Key &amp; Unique Key 需要使⽤到哈希索引机制，有额外的索引维护成本</li>
<li>Message Id由Broker和commit log offset组成，属于精确匹配，查询效率更好</li>
</ul>
<h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><h3 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h3> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600049260.png" class="">

<p>1 数据复制与刷盘策略</p>
 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600050073.png" class="">

<p>复制策略</p>
<p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p>
<ul>
<li>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</li>
<li>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成<br>功</li>
</ul>
<blockquote>
<p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p>
</blockquote>
<p>刷盘策略</p>
<p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为<br>同步刷盘与异步刷盘：</p>
<ul>
<li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功。</li>
<li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li>
</ul>
<blockquote>
<p>1）异步刷盘策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量<br>2）消息写入到Broker的内存，一般是写入到了PageCache<br>3）对于异步 刷盘策略，消息会写入到PageCache后立即返回成功ACK。但并不会立即做落盘操<br>作，而是当PageCache到达一定量时会自动进行落盘</p>
</blockquote>
<p>2 Broker集群模式</p>
<p>根据Broker集群中各个节点间关系的不同，Broker集群可以分为以下几类：</p>
<p>单Master</p>
<p>只有一个broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使<br>用，因为存在单点问题。</p>
<p>多Master</p>
<p>broker集群仅由多个master构成，不存在Slave。同一Topic的各个Queue会平均分布在各个master节点<br>上。</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器<br>宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步<br>刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），<br>消息实时性会受到影响。</li>
</ul>
<blockquote>
<p>以上优点的前提是，这些Master都配置了RAID磁盘阵列。如果没有配置，一旦出现某Master宕<br>机，则会发生大量消息丢失的情况。</p>
</blockquote>
<p>多Master多Slave模式-异步复制</p>
<p>broker集群由多个master构成，每个master又配置了多个slave（在配置了RAID磁盘阵列的情况下，一<br>个master一般配置一个slave即可）。master与slave的关系是主备关系，即master负责处理消息的读写<br>请求，而slave仅负责消息的备份与master宕机后的角色切换。</p>
<p>异步复制即前面所讲的复制策略中的异步复制策略，即消息写入master成功后，master立即向<br>producer返回成功ACK，无需等待slave同步数据成功。</p>
<p>该模式的最大特点之一是，当master宕机后slave能够自动切换为master。不过由于slave从master的同<br>步具有短暂的延迟（毫秒级），所以当master宕机后，这种异步复制方式可能会存在少量消息的丢失问<br>题。</p>
<blockquote>
<p>Slave从Master同步的延迟越短，其可能丢失的消息就越少<br>对于Master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能<br>会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会<br>更少。</p>
</blockquote>
<p>多Master多Slave模式-同步双写</p>
<p>该模式是多Master多Slave模式的同步复制实现。所谓同步双写，指的是消息写入master成功后，<br>master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会<br>返回成功ACK，也即双写。</p>
<p>该模式与异步复制模式相比，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的RT略<br>高，从而导致性能要略低（大约低10%）。</p>
<p>该模式存在一个大的问题：对于目前的版本，Master宕机后，Slave 不会自动切换到Master。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave。即利用了RAID10磁盘阵列的高<br>效、安全性，又解决了可能会影响订阅的问题。</p>
<p>1）RAID磁盘阵列的效率要高于Master-Slave集群。因为RAID是硬件支持的。也正因为如此，<br>所以RAID阵列的搭建成本较高。</p>
<p>2）多Master+RAID阵列，与多Master多Slave集群的区别是什么？</p>
<ul>
<li>多Master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到<br>消息的订阅。但其执行效率要远高于多Master多Slave集群</li>
<li>多Master多Slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低<br>于多Master+RAID阵列</li>
</ul>
<h4 id="集群搭建实例"><a href="#集群搭建实例" class="headerlink" title="集群搭建实例"></a>集群搭建实例</h4><p>1 <strong>集群架构</strong></p>
<p>这里要搭建一个双主双从异步复制的Broker集群。为了方便，这里使用了两台主机来完成集群的搭建。<br>这两台主机的功能与broker角色分配如下表。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600052474.png" class=""></p>
<p><strong>2 克隆生成rocketmqOS1</strong></p>
<p>克隆rocketmqOS主机，并修改配置。指定主机名为rocketmqOS1。</p>
<p><strong>3 修改rocketmqOS1配置文件</strong></p>
<p>要修改的配置文件在rocketMQ解压目录的conf&#x2F;2m-2s-async目录中。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rocketMQ/1697600052853.png" class=""></p>
<p><strong>修改broker-a.properties</strong></p>
<p>将该配置文件内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 指定整个broker集群的名称，或者说是RocketMQ集群的名称</span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"># 指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span><br><span class="line">brokerName=broker-a</span><br><span class="line"># master的brokerId为<span class="number">0</span></span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line"># 指定删除消息存储过期文件的时间为凌晨<span class="number">4</span>点</span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line"># 指定未发生更新的消息存储文件的保留时长为<span class="number">48</span>小时，<span class="number">48</span>小时后过期，将会被删除</span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line"># 指定当前broker为异步复制master</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"># 指定刷盘策略为异步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"># 指定Name Server的地址</span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.59</span><span class="number">.164</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.59</span><span class="number">.165</span>:<span class="number">9876</span></span><br></pre></td></tr></table></figure>

<p><strong>修改broker-b-s.properties</strong></p>
<p>将该配置文件内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"># 指定这是另外一个master-slave集群</span><br><span class="line">brokerName=broker-b</span><br><span class="line"># slave的brokerId为非<span class="number">0</span></span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line"># 指定当前broker为slave</span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.59</span><span class="number">.164</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.59</span><span class="number">.165</span>:<span class="number">9876</span></span><br><span class="line"># 指定Broker对外提供服务的端口，即Broker与producer与consumer通信的端口。默认</span><br><span class="line"><span class="number">10911</span>。由于当前主机同时充当着master1与slave2，而前面的master1使用的是默认端口。这</span><br><span class="line">里需要将这两个端口加以区分，以区分出master1与slave2</span><br><span class="line">listenPort=<span class="number">11911</span></span><br><span class="line"># 指定消息存储相关的路径。默认路径为~/store目录。由于当前主机同时充当着master1与</span><br><span class="line">slave2，master1使用的是默认路径，这里就需要再指定一个不同路径</span><br><span class="line">storePathRootDir=~/store-s</span><br><span class="line">storePathCommitLog=~/store-s/commitlog</span><br><span class="line">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class="line">storePathIndex=~/store-s/index</span><br><span class="line">storeCheckpoint=~/store-s/checkpoint</span><br><span class="line">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>

<p><strong>其它配置</strong></p>
<p>除了以上配置外，这些配置文件中还可以设置其它属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#指定整个broker集群的名称，或者说是RocketMQ集群的名称</span><br><span class="line">brokerClusterName=rocket-MS</span><br><span class="line">#指定master-slave集群的名称。一个RocketMQ集群可以包含多个master-slave集群</span><br><span class="line">brokerName=broker-a</span><br><span class="line">#<span class="number">0</span> 表示 Master，&gt;<span class="number">0</span> 表示 Slave</span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=nameserver1:<span class="number">9876</span>;nameserver2:<span class="number">9876</span></span><br><span class="line">#默认为新建Topic所创建的队列数</span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line">#是否允许 Broker 自动创建Topic，建议生产环境中关闭</span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议生产环境中关闭</span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line">#Broker对外提供服务的端口，即Broker与producer与consumer通信的端口</span><br><span class="line">listenPort=<span class="number">10911</span></span><br><span class="line">#HA高可用监听端口，即Master与Slave间通信的端口，默认值为listenPort+<span class="number">1</span></span><br><span class="line">haListenPort=<span class="number">10912</span></span><br><span class="line">#指定删除消息存储过期文件的时间为凌晨<span class="number">4</span>点</span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">#指定未发生更新的消息存储文件的保留时长为<span class="number">48</span>小时，<span class="number">48</span>小时后过期，将会被删除</span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">#指定commitLog目录中每个文件的大小，默认1G</span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line">#指定ConsumeQueue的每个Topic的每个Queue文件中可以存放的消息数量，默认30w条</span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line">#在清除过期文件时，如果该文件被其他线程所占用（引用数大于<span class="number">0</span>，比如读取消息），此时会阻止</span><br><span class="line">此次删除任务，同时在第一次试图删除该文件时记录当前时间戳。该属性则表示从第一次拒绝删除</span><br><span class="line">后开始计时，该文件最多可以保留的时长。在此时间内若引用数仍不为<span class="number">0</span>，则删除仍会被拒绝。不过</span><br><span class="line">时间到后，文件将被强制删除</span><br><span class="line">destroyMapedFileIntervalForcibly=<span class="number">120000</span></span><br><span class="line">#指定commitlog、consumequeue所在磁盘分区的最大使用率，超过该值，则需立即清除过期文</span><br><span class="line">件</span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line">#指定store目录的路径，默认在当前用户主目录中</span><br><span class="line">storePathRootDir=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store</span><br><span class="line">#commitLog目录路径</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store/commitlog</span><br><span class="line">#consumeueue目录路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store/consumequeue</span><br><span class="line">#index目录路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store/index</span><br><span class="line">#checkpoint文件路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store/checkpoint</span><br><span class="line">#abort文件路径</span><br><span class="line">abortFile=/usr/local/rocketmq-all-<span class="number">4.5</span><span class="number">.0</span>/store/abort</span><br><span class="line">#指定消息的最大大小</span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line">#Broker的角色</span><br><span class="line"># - ASYNC_MASTER 异步复制Master</span><br><span class="line"># - SYNC_MASTER 同步双写Master</span><br><span class="line"># - SLAVE</span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line">#刷盘策略</span><br><span class="line"># - ASYNC_FLUSH 异步刷盘</span><br><span class="line"># - SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line">#发消息线程池数量</span><br><span class="line">sendMessageThreadPoolNums=<span class="number">128</span></span><br><span class="line">#拉消息线程池数量</span><br><span class="line">pullMessageThreadPoolNums=<span class="number">128</span></span><br><span class="line">#强制指定本机IP，需要根据每台机器进行修改。官方介绍可为空，系统默认自动识别，但多网卡</span><br><span class="line">时IP地址可能读取错误</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.3</span><span class="number">.105</span></span><br></pre></td></tr></table></figure>

<p><strong>4 克隆生成rocketmqOS2</strong></p>
<p>克隆rocketmqOS1主机，并修改配置。指定主机名为rocketmqOS2。</p>
<p><strong>5 修改rocketmqOS2配置文件</strong></p>
<p>对于rocketmqOS2主机，同样需要修改rocketMQ解压目录的conf目录的子目录2m-2s-async中的两个配<br>置文件。</p>
<p><strong>修改broker-b.properties</strong></p>
<p>将该配置文件内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.59</span><span class="number">.164</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.59</span><span class="number">.165</span>:<span class="number">9876</span></span><br></pre></td></tr></table></figure>

<p>修改broker-a-s.properties</p>
<p>将该配置文件内容修改为如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.59</span><span class="number">.164</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.59</span><span class="number">.165</span>:<span class="number">9876</span></span><br><span class="line">listenPort=<span class="number">11911</span></span><br><span class="line">storePathRootDir=~/store-s</span><br><span class="line">storePathCommitLog=~/store-s/commitlog</span><br><span class="line">storePathConsumeQueue=~/store-s/consumequeue</span><br><span class="line">storePathIndex=~/store-s/index</span><br><span class="line">storeCheckpoint=~/store-s/checkpoint</span><br><span class="line">abortFile=~/store-s/abort</span><br></pre></td></tr></table></figure>

<p><strong>6 启动服务器</strong></p>
<p>启动NameServer集群</p>
<p>分别启动rocketmqOS1与rocketmqOS2两个主机中的NameServer。启动命令完全相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>

<p>启动两个Master</p>
<p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker master。注意，它们指定所要加载的配置<br>文件是不同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>

<p>启动两个Slave</p>
<p>分别启动rocketmqOS1与rocketmqOS2两个主机中的broker slave。注意，它们指定所要加载的配置文<br>件是不同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-b-s.properties &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line">nohup sh bin/mqbroker -c conf/2m-2s-async/broker-a-s.properties &amp;</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>















<h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://xeons.cn">Calico</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://xeons.cn/2023/05/03/mq-rocketMQ/">http://xeons.cn/2023/05/03/mq-rocketMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xeons.cn" target="_blank">Calico's Space</a>！</span></div></div><script>function setClipboardText(event){
    let clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) { return; }
    event.preventDefault();
    let text = window.getSelection().toString();
    if (text) {
        event.preventDefault();
        var copyright = "\n\n---\n著作权归 Calico 所有 \n原文链接: http://xeons.cn/2023/05/03/mq-rocketMQ/";
        clipboardData.setData('text/plain', text + copyright);
    }
};
var contents = document.getElementsByClassName("post");
contents[0].addEventListener('copy',function(e){
    setClipboardText(e);
});</script><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/mq/">mq</a></div><div class="post_share"><div class="social-share" data-image="/2023/05/03/mq-rocketMQ/logo.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wxpay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wxpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/03/mq-basic/" title="消息队列-ActiveMQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-basic/mq.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">消息队列-ActiveMQ</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/03/mq-rabbitMQ/" title="消息队列-RabbitMQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rabbitMQ/logo.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">消息队列-RabbitMQ</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/04/mq-kafka/" title="消息队列-kafka"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/04/mq-kafka/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-04</div><div class="title">消息队列-kafka</div></div></a></div><div><a href="/2023/05/03/mq-basic/" title="消息队列-ActiveMQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-basic/mq.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">消息队列-ActiveMQ</div></div></a></div><div><a href="/2023/05/03/mq-rabbitMQ/" title="消息队列-RabbitMQ"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2023/05/03/mq-rabbitMQ/logo.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">消息队列-RabbitMQ</div></div></a></div><div><a href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/1gneicun1yishuju/algorithm_complexity_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">1g内存如何存储1亿数据</div></div></a></div><div><a href="/2024/04/09/40yiqqhaoquchong/" title="上亿号码去重方案"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/40yiqqhaoquchong/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">上亿号码去重方案</div></div></a></div><div><a href="/2024/04/09/alibaba_seata/" title="seate中的tcc"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/alibaba_seata/640.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-09</div><div class="title">seate中的tcc</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81OTczMi8zNjE5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/calico.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Calico</div><div class="author-info__description">It's my blog，Record everything！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xeonsuo"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xeonsuo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://weibo.com/xeons" target="_blank" title="微博"><i class="fab fa-weibo" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xeon511@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">python、aiAgent 进化中...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RocketMQ-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.0.1.</span> <span class="toc-text">RocketMQ 的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.0.2.</span> <span class="toc-text">系统架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9B%86%E6%88%90"><span class="toc-number">2.</span> <span class="toc-text">代码集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">普通消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">2.2.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF"><span class="toc-number">2.3.</span> <span class="toc-text">延迟消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">2.3.1.</span> <span class="toc-text">1 什么是延时消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">2 延时等级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">3 延时消息实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B6%88%E6%81%AF"><span class="toc-number">2.3.4.</span> <span class="toc-text">修改消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">2.4.</span> <span class="toc-text">事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">1 问题引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.4.2.</span> <span class="toc-text">2 解决思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.4.3.</span> <span class="toc-text">3 基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">2.4.4.</span> <span class="toc-text">分布式事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-XA%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">2.4.5.</span> <span class="toc-text">4 XA模式三剑客</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-XA%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.4.6.</span> <span class="toc-text">5 XA模式架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F"><span class="toc-number">2.4.7.</span> <span class="toc-text">6 注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.4.8.</span> <span class="toc-text">7 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number">2.5.</span> <span class="toc-text">批量消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">2.5.1.</span> <span class="toc-text">1 批量发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">2.5.2.</span> <span class="toc-text">2 批量消费消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">2.6.</span> <span class="toc-text">消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Tag%E8%BF%87%E6%BB%A4"><span class="toc-number">2.6.1.</span> <span class="toc-text">1 Tag过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SQL%E8%BF%87%E6%BB%A4"><span class="toc-number">2.6.2.</span> <span class="toc-text">2 SQL过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">2.6.3.</span> <span class="toc-text">3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95"><span class="toc-number">2.7.</span> <span class="toc-text">发送端消息重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-number">2.7.1.</span> <span class="toc-text">1 说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">2.7.2.</span> <span class="toc-text">2 同步发送失败策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">2.7.3.</span> <span class="toc-text">3 异步发送失败策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">2.7.4.</span> <span class="toc-text">4 消息刷盘失败策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AB%AF%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95"><span class="toc-number">2.8.</span> <span class="toc-text">接收端消息重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">2.8.1.</span> <span class="toc-text">1 顺序消息的消费重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">2.8.2.</span> <span class="toc-text">2 无序消息的消费重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E4%B8%8E%E9%97%B4%E9%9A%94"><span class="toc-number">2.8.3.</span> <span class="toc-text">3 消费重试次数与间隔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-number">2.8.4.</span> <span class="toc-text">4 重试队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.5.</span> <span class="toc-text">5 消费重试配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E4%B8%8D%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.6.</span> <span class="toc-text">6 消费不重试配置方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">2.9.</span> <span class="toc-text">消息幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89"><span class="toc-number">2.9.1.</span> <span class="toc-text">什么是消息幂等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E9%9B%86%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">消息堆集问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.10.1.</span> <span class="toc-text">消息堆积本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="toc-number">2.10.2.</span> <span class="toc-text">如何处理消息堆积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.11.</span> <span class="toc-text">消息查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.11.1.</span> <span class="toc-text">消息查询介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2%E2%BC%AF%E5%85%B7"><span class="toc-number">2.11.2.</span> <span class="toc-text">消息查询⼯具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E2%BE%8F%E2%BC%AF%E5%85%B7"><span class="toc-number">2.11.3.</span> <span class="toc-text">命令⾏⼯具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0"><span class="toc-number">2.11.4.</span> <span class="toc-text">管理平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFAPI"><span class="toc-number">2.11.5.</span> <span class="toc-text">客户端API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.11.6.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.11.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">高可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">3.1.</span> <span class="toc-text">集群部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">集群搭建实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF-1"><span class="toc-number">3.2.</span> <span class="toc-text">延迟消息</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/ai-appdev1/" title="AI之 应用开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/11/ai-appdev1/image-20250414235122630.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 应用开发"/></a><div class="content"><a class="title" href="/2024/09/11/ai-appdev1/" title="AI之 应用开发">AI之 应用开发</a><time datetime="2024-09-11T06:45:07.000Z" title="发表于 2024-09-11 14:45:07">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/ai-prompt/" title="AI之 提示词"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/11/ai-prompt/image-20250414235122630.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 提示词"/></a><div class="content"><a class="title" href="/2024/09/11/ai-prompt/" title="AI之 提示词">AI之 提示词</a><time datetime="2024-09-11T06:45:07.000Z" title="发表于 2024-09-11 14:45:07">2024-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/ai-pandas1/" title="AI之 panda"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/09/ai-pandas1/e9e1d53513bac92c583f77534da579f7_9121a50daa7413dfe6ff9a47f91a0ad9_fullsize.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 panda"/></a><div class="content"><a class="title" href="/2024/09/09/ai-pandas1/" title="AI之 panda">AI之 panda</a><time datetime="2024-09-09T06:45:07.000Z" title="发表于 2024-09-09 14:45:07">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/ai-python1/" title="AI之 python 基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/09/09/ai-python1/algorithm_complexity_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI之 python 基础"/></a><div class="content"><a class="title" href="/2024/09/09/ai-python1/" title="AI之 python 基础">AI之 python 基础</a><time datetime="2024-09-09T05:45:07.000Z" title="发表于 2024-09-09 13:45:07">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/09/1gneicun1yishuju/algorithm_complexity_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1g内存如何存储1亿数据"/></a><div class="content"><a class="title" href="/2024/04/09/1gneicun1yishuju/" title="1g内存如何存储1亿数据">1g内存如何存储1亿数据</a><time datetime="2024-04-09T06:45:07.000Z" title="发表于 2024-04-09 14:45:07">2024-04-09</time></div></div></div></div></div></div></main><footer id="footer" style="background: none"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Calico</div><div class="footer_custom_text"><a href="icp"><span>Create By hexo,butterfly</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const loadLivere = () => {
    if (typeof LivereTower === 'object') window.LivereTower.init()
    else {
      (function(d, s) {
          var j, e = d.getElementsByTagName(s)[0];
          if (typeof LivereTower === 'function') { return; }
          j = d.createElement(s);
          j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
          j.async = true;
          e.parentNode.insertBefore(j, e);
      })(document, 'script');
    }
  }

  if ('Livere' === 'Livere' || !false) {
    if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
    else loadLivere()
  } else {
    window.loadOtherComment = loadLivere
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>